<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[LeetCode]——x的平方根</title>
    <url>/2020/03/18/%5BLeetCode%5D%E2%80%94%E2%80%94x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<h2 id="NO-69-x的平方根-简单"><a href="#NO-69-x的平方根-简单" class="headerlink" title="NO.69 x的平方根 简单 "></a>NO.69 x的平方根 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/17/8ax9YD.png" alt="8ax9YD.png"></p>
<h3 id="思路一：二分法"><a href="#思路一：二分法" class="headerlink" title="思路一：二分法"></a><strong><font color=red>思路一：二分法</font></strong></h3><p>一个数的平方根一定不会大于这个数的一半，4的平方根2，8的平方根2.xxx。</p>
<p>也就是说我们只需要寻找[1,x/2]这个范围里的出就可以了，0单独判断，在确定的区间里二分查找。</p>
<p>left、right、mid、平方数 都要用long类型防止大整形测试用例。</p>
<p>mid一定取右中位数，如果取左中位数，可能死循环。例如9，left=3，right=4，一直是9&lt;9不成立进入<code>left=mid</code>这个分支，区间不发生收缩。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> left=<span class="number">1</span>,right=x/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="comment">//取右中位数</span></span><br><span class="line">        <span class="keyword">long</span> mid=(left+right+<span class="number">1</span>)&gt;&gt;&gt;<span class="number">1</span>;<span class="comment">//(right-left+1)/2+left</span></span><br><span class="line">        <span class="keyword">long</span> square=mid*mid;</span><br><span class="line">        <span class="keyword">if</span> (square &gt; x) &#123;<span class="comment">//向左收缩</span></span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<h3 id="思路二：牛顿迭代法"><a href="#思路二：牛顿迭代法" class="headerlink" title="思路二：牛顿迭代法"></a><strong><font color=red>思路二：牛顿迭代法</font></strong></h3><p>数学粉末直接搬运<a href="https://liweiwei1419.gitee.io/leetcode-algo/" target="_blank" rel="noopener">liweiwei1419</a>大佬的讲解。</p>
<p>使用牛顿法可以得到一个正实数的算术平方根，因为题目中说“结果只保留整数部分”，因此，我们把使用牛顿法得到的浮点数转换为整数即可。</p>
<p>这里给出牛顿法的思想：</p>
<blockquote>
<p>在迭代过程中，以直线代替曲线，用一阶泰勒展式（即在当前点的切线）代替原曲线，求直线与 xx 轴的交点，重复这个过程直到收敛。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/03/18/8dQD00.gif" alt="8dQD00.gif"></p>
<p>说明：</p>
<ol>
<li>以上图片来自<a href="https://blog.csdn.net/batuwuhanpei/article/details/51979831" target="_blank" rel="noopener">《牛顿法与拟牛顿法》</a>；</li>
<li>题解<a href="https://leetcode-cn.com/problems/sqrtx/solution/niu-dun-die-dai-fa-by-loafer/" target="_blank" rel="noopener">《牛顿迭代法》</a> 的图和文字说明更好，而知乎问答<a href="https://www.zhihu.com/question/20690553" target="_blank" rel="noopener">《如何通俗易懂地讲解牛顿迭代法求开方？数值分析？》</a>里面干货就更多了，建议大家出门左转观看，我这篇题解只是展示一下迭代公式如何计算。</li>
</ol>
<p><img src="https://s1.ax1x.com/2020/03/18/8dl1gJ.png" alt="8dl1gJ.png"></p>
<p>注意：牛顿法得到的是平方根的浮点型精确值（可能会有一定误差），根据题目中的要求，把最后得到的这个数转换为 int 型，即去掉小数部分即可。</p>
<p>对“牛顿法”感兴趣的朋友们可以查一下牛顿法的应用：一个是求方程的根，另一个是求解最优化问题，在这里就不展开了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a=x;</span><br><span class="line">    <span class="keyword">while</span> (a * a &gt; x) &#123;</span><br><span class="line">        a=(a+x/a)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：1e-6 是科学计数法，表示 11 乘以 1010 的负 66 次方，也就是 0.0000010.000001。有的地方使用 epsilon（ϵ）表示 1e-6 ，用来抵消浮点运算中因为误差造成的相等无法判断的情况，它通常是一个非常小的数字，具体多小要根据你的精度需求来设置。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和源码:<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
        <tag>牛顿迭代法</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——文本左右对齐</title>
    <url>/2020/03/17/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%96%87%E6%9C%AC%E5%B7%A6%E5%8F%B3%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p>又是一道很恶心的题，本身没有什么难以理解的算法或结构，全是细节堆积出来的。<a id="more"></a></p>
<h2 id="NO-68-文本左右对齐-困难"><a href="#NO-68-文本左右对齐-困难" class="headerlink" title="NO.68 文本左右对齐 困难"></a>NO.68 文本左右对齐 <font color=#ff0099>困难</font></h2><p><img src="https://s1.ax1x.com/2020/03/17/8tq18P.png" alt="8tq18P.png"></p>
<p><img src="https://s1.ax1x.com/2020/03/17/8tqM4I.png" alt="8tqM4I.png"></p>
<p><strong><font color=red>思路一：顺着思路模拟</font></strong> 直接贴一个discuss，看一下思路：</p>
<p>首先要理顺题意，给定一堆单词，让你放在固定长度字符串里</p>
<ol>
<li><p>两个单词之间至少有一个空格，如果单词加空格长度超过<code>maxWidth</code>，说明该单词放不下，比如示例1:当我们保证<code>this is an</code>再加入<code>example</code>变成<code>this is an example</code>总长度超过<code>maxWidth</code>，所以这一行只能放下<code>this is an</code> 这三个单词;</p>
</li>
<li><p><code>this is an</code>长度小于<code>maxWidth</code>，我们考虑分配空格，并保证左边空格数大于右边的</p>
</li>
<li><p>最后一行，要尽量靠左，例如示例2的:”shall be “<br>我们针对上面三个问题，有如下解决方案.</p>
</li>
<li><p>先找到一行最多可以容下几个单词;</p>
</li>
<li><p>分配空格，例如<code>this is an</code>，对于宽度为<code>maxWidth</code>，我们可以用<code>maxWidth - all_word_len</code>与需要空格数商为 单词间 空格至少的个数，余数是一个一个分配给左边.就能保证左边空格数大于右边的.例如<code>16 - 8 = 8</code>，<code>a = 8 / 2</code>， <code>b = 8 % 2</code>两个单词间要有4个空格，因为余数为零不用分配;</p>
</li>
<li><p>针对最后一行单独考虑;</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fullJustify</span><span class="params">(String[] words, <span class="keyword">int</span> maxWidth)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = words.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 找到一行可以容下单词</span></span><br><span class="line">        <span class="keyword">int</span> left = i;</span><br><span class="line">        <span class="comment">// 至少一行能放下一个单词</span></span><br><span class="line">        <span class="keyword">int</span> cur_row_len = words[i].length();</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur_row_len + words[i].length() + <span class="number">1</span> &gt; maxWidth) <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">            cur_row_len += words[i].length() + <span class="number">1</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder tmp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">// 考虑最后一行</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; i; j++) &#123;</span><br><span class="line">                tmp.append(words[j] + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.deleteCharAt(tmp.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = tmp.length(); j &lt; maxWidth; j++)</span><br><span class="line">                tmp.append(<span class="string">" "</span>);</span><br><span class="line">            res.add(tmp.toString());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 所有单词长度</span></span><br><span class="line">        <span class="keyword">int</span> all_word_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; i; j++) &#123;</span><br><span class="line">            all_word_len += words[j].length();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//System.out.println(all_word_len);</span></span><br><span class="line">        <span class="comment">// 至少空格个数</span></span><br><span class="line">        <span class="keyword">int</span> space_num = i - left - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 可以为空格的位置个数</span></span><br><span class="line">        <span class="keyword">int</span> remain_space = maxWidth - all_word_len;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (space_num != <span class="number">0</span>) &#123;</span><br><span class="line">            a = remain_space / space_num;</span><br><span class="line">            b = remain_space % space_num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = left; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; a; k++) tmp.append(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">if</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">                    tmp.append(<span class="string">" "</span>);</span><br><span class="line">                    b--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.append(words[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = tmp.length(); j &lt; maxWidth; j++) &#123;</span><br><span class="line">            tmp.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    遍历</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和源码:<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——拼写单词</title>
    <url>/2020/03/17/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/</url>
    <content><![CDATA[<h2 id="NO-1160-拼写单词-简单"><a href="#NO-1160-拼写单词-简单" class="headerlink" title="NO.1160 拼写单词 简单 "></a>NO.1160 拼写单词 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/17/8tIKN6.png" alt="8tIKN6.png"></p>
<p><strong><font color=red>思路一：哈希表</font></strong> map先统计chars字符以及每个字符的数量。遍历words每个单词，遍历每个单词每个字符如果字符存在map中就加入临时表并统计数量，如果当前字符不存在或者数量超了都将有效标志置为false。最后如果当前单词有效就将长度加入到结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(String[] words, String chars)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chars==<span class="keyword">null</span>||chars.length()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//统计chars</span></span><br><span class="line">    HashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length(); i++) &#123;</span><br><span class="line">        Integer value = map.getOrDefault(chars.charAt(i), <span class="number">0</span>);</span><br><span class="line">        map.put(chars.charAt(i),value+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历每个单词</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="comment">//临时长度遍历，临时表，有效标志</span></span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; has=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> ok=<span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//遍历单词每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">            <span class="comment">//存在于map</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(words[i].charAt(j)))&#123;</span><br><span class="line">                <span class="keyword">int</span> value=has.getOrDefault(words[i].charAt(j),<span class="number">0</span>);</span><br><span class="line">                has.put(words[i].charAt(j),value+<span class="number">1</span>);</span><br><span class="line">                temp++;</span><br><span class="line">                <span class="comment">//数量超了</span></span><br><span class="line">                <span class="keyword">if</span> (has.get(words[i].charAt(j))&gt;map.get(words[i].charAt(j)))&#123;</span><br><span class="line">                    ok=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//不存在于map</span></span><br><span class="line">                ok=<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有效加入结果</span></span><br><span class="line">        <span class="keyword">if</span> (ok)count+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n+m)  n是words字符数量，m是chars字符数量。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和源码:<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式之Redis之为什么</title>
    <url>/2020/03/15/(%E8%BD%AC)%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRedis/</url>
    <content><![CDATA[<p>作者：孤独烟 </p>
<p>出处：<a href="http://rjzheng.cnblogs.com/" target="_blank" rel="noopener"> http://rjzheng.cnblogs.com/</a></p>
<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<a id="more"></a></p>
<p>[TOC]</p>
<h1 id="1、为什么使用redis"><a href="#1、为什么使用redis" class="headerlink" title="1、为什么使用redis"></a>1、为什么使用redis</h1><p><strong>分析</strong>:博主觉得在项目中使用redis，主要是从两个角度去考虑:<strong>性能</strong>和<strong>并发</strong>。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。<br><strong>回答</strong>:如下所示，分为两点</p>
<h2 id="（一）性能"><a href="#（一）性能" class="headerlink" title="（一）性能"></a>（一）性能</h2><p>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>迅速响应</strong>。<br><img src="https://s2.ax1x.com/2019/10/09/uopDIO.png" alt="uopDIO.png"><br><strong>题外话：</strong>忽然想聊一下这个<strong>迅速响应</strong>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在<strong>瞬间</strong>解决，对于页内操作则需要在<strong>刹那</strong>间解决。另外，超过<strong>一弹指</strong>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”<br>那么<strong>瞬间、刹那、一弹指</strong>具体是多少时间呢？<br>根据《摩诃僧祗律》记载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</span><br></pre></td></tr></table></figure>

<p>那么，经过周密的计算，一<strong>瞬间</strong>为0.36 秒,一<strong>刹那</strong>有 0.018 秒.一<strong>弹指</strong>长达 7.2 秒。</p>
<h2 id="（二）并发"><a href="#（二）并发" class="headerlink" title="（二）并发"></a>（二）并发</h2><p>如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。<br><img src="https://s2.ax1x.com/2019/10/09/uopBdK.png" alt="uopBdK.png"></p>
<h1 id="2、使用redis有什么缺点"><a href="#2、使用redis有什么缺点" class="headerlink" title="2、使用redis有什么缺点"></a>2、使用redis有什么缺点</h1><p><strong>分析</strong>:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。<br><strong>回答</strong>:主要是四个问题：</p>
<ol>
<li>缓存和数据库双写一致性问题</li>
<li>缓存雪崩问题</li>
<li>缓存击穿问题</li>
<li>缓存的并发竞争问题</li>
</ol>
<p>这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。</p>
<h1 id="3、单线程的redis为什么这么快"><a href="#3、单线程的redis为什么这么快" class="headerlink" title="3、单线程的redis为什么这么快"></a>3、单线程的redis为什么这么快</h1><p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。<br><strong>回答</strong>:主要是以下三点：</p>
<ol>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>采用了非阻塞<strong>I/O多路复用机制</strong></li>
</ol>
<h2 id="题外话：I-O多路复用机制"><a href="#题外话：I-O多路复用机制" class="headerlink" title="题外话：I/O多路复用机制"></a><font color=red>题外话：I/O多路复用机制</font></h2><p>我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了<strong>一批</strong>快递员，然后小曲发现资金不够了，只够买<strong>一辆</strong>车送快递。<br><strong>经营方式一</strong><br>客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题</p>
<ul>
<li>几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递</li>
<li>随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了</li>
<li>快递员之间的协调很花时间</li>
</ul>
<p>综合上述缺点，小曲痛定思痛，提出了下面的经营方式<br><strong>经营方式二</strong><br>小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按<strong>送达地点</strong>标注好，然后<strong>依次</strong>放在一个地方。最后，那个快递员<strong>依次</strong>的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。</p>
<p><strong>对比：</strong><br>上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:</p>
<ul>
<li>每个快递员——————&gt;每个线程</li>
<li>每个快递——————–&gt;每个socket(I/O流)</li>
<li>快递的送达地点————–&gt;socket的不同状态</li>
<li>客户送快递请求————–&gt;来自客户端的请求</li>
<li>小曲的经营方式————–&gt;服务端运行的代码</li>
<li>一辆车———————-&gt;CPU的核数</li>
</ul>
<p>于是我们有如下结论：</p>
<ol>
<li>经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。</li>
<li>经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。</li>
</ol>
<p>下面类比到真实的redis线程模型，如图所示<br><img src="https://s2.ax1x.com/2019/10/09/uopsiD.png" alt="uopsiD.png"><br>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。<br>需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。</p>
<h1 id="4、redis的数据类型，以及每种数据类型的使用场景"><a href="#4、redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="4、redis的数据类型，以及每种数据类型的使用场景"></a>4、redis的数据类型，以及每种数据类型的使用场景</h1><p><strong>分析</strong>：是不是觉得这个问题很基础，其实我也这么觉得。然而根据面试经验发现，至少百分八十的人答不上这个问题。建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。<br><strong>回答</strong>：一共五种</p>
<h2 id="一-String"><a href="#一-String" class="headerlink" title="(一)String"></a>(一)String</h2><p>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<font color=red><strong>一些复杂的计数功能的缓存。</strong></font></p>
<h2 id="二-hash"><a href="#二-hash" class="headerlink" title="(二)hash"></a>(二)hash</h2><p>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做<font color=red><strong>单点登录</strong></font>的时候，就是用这种数据结构存储用户信息，<strong><u>以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</u></strong></p>
<h2 id="三-list"><a href="#三-list" class="headerlink" title="(三)list"></a>(三)list</h2><p>使用List的数据结构，可以<font color=red><strong>做简单的消息队列的功能</strong></font>。另外还有一个就是，可以利用<strong>lrange</strong>命令，<font color=red><strong>做基于redis的分页功能</strong></font>，性能极佳，用户体验好。</p>
<h2 id="四-set"><a href="#四-set" class="headerlink" title="(四)set"></a>(四)set</h2><p>因为set堆放的是一堆不重复值的集合。所以可以做<font color=red><strong>全局去重的功能</strong></font>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用<strong><u>交集、并集、差集</u></strong>等操作，可以<font color=red><strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong></font>。</p>
<h2 id="五-sorted-set"><a href="#五-sorted-set" class="headerlink" title="(五)sorted set"></a>(五)sorted set</h2><p>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<font color=red><strong>排行榜应用，取TOP N操作</strong></font>。另外，参照另一篇<a href="https://www.cnblogs.com/rjzheng/p/8972725.html" target="_blank" rel="noopener">《分布式之延时任务方案解析》</a>，该文指出了sorted set可以用来做<font color=red><strong>延时任务</strong></font>。最后一个应用就是可以做<font color=red><strong>范围查找</strong></font>。</p>
<h1 id="5、redis的过期策略以及内存淘汰机制"><a href="#5、redis的过期策略以及内存淘汰机制" class="headerlink" title="5、redis的过期策略以及内存淘汰机制"></a>5、redis的过期策略以及内存淘汰机制</h1><p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?<br><strong>回答</strong>:<br>redis采用的是<strong>定期删除+惰性删除</strong>策略。<br><strong>为什么不用定时删除策略?</strong><br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略。<br><strong>定期删除+惰性删除是如何工作的呢?</strong><br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。<br><strong>采用定期删除+惰性删除就没其他问题了么?</strong><br>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。<br>在redis.conf中有一行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>

<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</p>
<ol>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>应该没人用吧。</strong></li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用，目前项目在用这种。</strong></li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>应该也没人用吧，你不删最少使用Key,去随机删。</strong></li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</strong></li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>依然不推荐</strong></li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong></li>
</ol>
<p><u>ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</u></p>
<h1 id="6、redis和数据库双写一致性问题"><a href="#6、redis和数据库双写一致性问题" class="headerlink" title="6、redis和数据库双写一致性问题"></a>6、redis和数据库双写一致性问题</h1><p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。<strong><u>就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</u></strong></p>
<p><strong>回答</strong>:<a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">《分布式之数据库和缓存双写一致性方案解析》</a>给出了详细的分析，在这里简单的说一说。<font color=red><strong><u>首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</u></strong></font></p>
<h1 id="7、如何应对缓存穿透和缓存雪崩问题"><a href="#7、如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="7、如何应对缓存穿透和缓存雪崩问题"></a>7、如何应对缓存穿透和缓存雪崩问题</h1><p><strong>分析</strong>:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。<br><strong>回答</strong>:如下所示<br><strong>缓存穿透：</strong>即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。<br><strong><font color=red>解决方案：</font></strong></p>
<ol>
<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。</li>
<li>采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。</li>
<li>提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</li>
</ol>
<p><strong>缓存雪崩：</strong>即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。<br><font color=red><strong>解决方案：</strong></font></p>
<ol>
<li>给缓存的失效时间，加上一个随机值，避免集体失效。</li>
<li>使用互斥锁，但是该方案吞吐量明显下降了。</li>
<li>双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做<strong>缓存预热</strong>操作。然后细分以下几个小点：<ul>
<li>从缓存A读数据库，有则直接返回。</li>
<li>A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。</li>
<li>更新线程同时更新缓存A和缓存B。</li>
</ul>
</li>
</ol>
<h1 id="8、如何解决redis的并发竞争key问题"><a href="#8、如何解决redis的并发竞争key问题" class="headerlink" title="8、如何解决redis的并发竞争key问题"></a>8、如何解决redis的并发竞争key问题</h1><p><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong><br><strong>回答:</strong>如下所示<br>(1)如果对这个key操作，<strong>不要求顺序</strong><br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，<strong>要求顺序</strong><br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC。希望key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br></pre></td></tr></table></figure>

<p>那么，假设这会儿系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>
<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>补码(为什么按位取反再加一)</title>
    <url>/2020/03/15/(%E8%BD%AC)%E8%A1%A5%E7%A0%81(%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D%E5%86%8D%E5%8A%A0%E4%B8%80)/</url>
    <content><![CDATA[<p>首先，阅读这篇文章的你，肯定是一个在网上已经纠结了很久的读者，因为你查阅了所有你能查到的资料，然后他们都会很耐心的告诉你，补码：就是按位取反，然后加一。准确无误，毫无破绽。但是，你搜遍了所有俯拾即是而且准确无误的答案，却仍然选择来看这篇毫不起眼的文章，原因只有一个，只因为你还没有得到你想要的东西。<a id="more"></a></p>
<p> 因为你想要的，不是1+1=2，而是，1+1为什么等于2。当然，我们不讨论1+1的问题。我们讨论的，是补码。</p>
<p> 你已经困惑了很久，你明明知道补码就是按位取反，然后加一，但是你想知道的，不是它怎么求滴，而是，它怎来滴。当然，对于阅读这篇文章的你，既然想要知道这个答案，一定是有一定编程基础的读者，肯定知道补码与有符号数与无符号数的关系（有符号数指带有正负号的数，无符号可以理解为只大于0的数），你所查阅的所有资料首先都会用一个8位的二进制数给你举例，ok，我们也用一个8位的二进制数。</p>
<p> 8位二进制数，最小00000000，最大数11111111，换算十进制为0<del>255，当然，所有的参考资料都会这样讲，而且这也不是你想要的，但我们必须说下去。1</del>255，一共255的字符，再加上最前面的0，一共256个字符。现在，我们要用一个8位二进制数字来表示一个负数，可是二进制里没有负号，谁都知道二进制里只有0,1，再无其他符号。那么所以我们必须用一种方式来代替正负，也就是我们规定，当然是人规定的，而不是电脑，我们规定这个8位的二进制数的最前面一位数来表示这个数的正负，0代表是正，1代表是负。那么当第一位是0时，我们一共可以表示00000000<del>01111111这么多正数，因为第一位必须是0来代表正数；当第一位是1时，我们一共可以表示10000000</del>11111111这么多负数，然后，我们用00000000<del>01111111来代表0</del>127，那岂不是10000000~11111111代表  -0  ~  -127？？可是网上都说不能有 负0，可是我觉的没什么不妥啊，负0不还是0 吗？10-0=10，不就是相当于10+（-0）=10吗，现在我们不讨论正负0的问题，我们来讨论一个小学生的问题。</p>
<p> 我们现在要把00000000~11111111分成两组数，一组是正数，另一组是负数，正数是0,1,2,3,4,5,6,7,8，… 负数是 -1，-2，-3，-4，-5，-6，-7，-8，… 那么这里就有一个小学问题，那就是1+（-1）肯定要等于0，2+（-2）=0，他们是相反数，相加等于0，小学生都会。后面都是一样，那么现在我们使用上面的编码的方式进行一个计算，现在上面的编码中 1 对应的二进制是00000001，-1对应的二进制是10000001，然后你把这俩二进制数加起来，看看等于几，对，答案是10000010，不是00000000，也不是10000000,  10000010在上面的编码中代表 -2，00000000和10000000都在上面代表0，可是结果并不是他们。而00000001与10000001分别对应着1和-1，加起来理论的结果应该是0才对，也就是说上面的编码是错误的。</p>
<p> 或许接下来很多资料又讨论了反码，但是我们不，我们来求一个一元一次函数，一个小学的函数，1+x=0,求x=？,答：-1。没错，而且准确无误。那么现在问题来了，前面的正数编码应该是没有错的，00000000代表0,  00000001代表1，这些都符合我们的习惯，那么出错的是在后面的负数编码上，我们到底该如何编码对应负数编码它才能正确呢，因为我们知道1+（-1）必须等于0，也就是他们对应的二进制相加也必须等于0，1对应00000001，那么00000001+x=00000000，里面的x就应该代替 -1的二进制编码才对，这样，我们得到 x=11111111，大家看一下这和按位取反，然后加一的结果一样吗。</p>
<p>所以我们的结论是，一个正数对应的负数（也就是俩相反数），这两个数的二进制编码加起来必须等于0才对，所以我们只要知道其中一个数的编码x，然后用0-x就是他对应的数的编码，这样的话，从0<del>127，我们用（0 - 其中一个二进制数的编码）=（另一个二进制数的编码），例如 2 的二进制编码是00000010，那么-2 的二进制编码就是0 - 00000010=11111110，因为他就应该这样，因为它就是一个小学问题，他俩加起来就应该等于0。那么1000000对应的编码是多少呢，当然也必须满足加起来等于0才行，那么10000000+x=0，求解x，答x=10000000，还是它本身，也就是在00000000</del>11111111这个范围里所有的二进制数都无法满足它，也就是没有一个数加上它等于0，但是两个数要有对应的编码，就必须加起来等于0才行，其实不止它没有，0也没有，0+x=0，那么x=0，也是它本身，既然这样了，那么也没有办法了，无可奈何只能做单身汉了，然后我们规定，既然10000000第一位是1，代表负数，那么我们规定它是一个负数，那么10000000就代替了-128，而且，它只自己一个人，也就是只有-128，没有正数128。</p>
<p> 然后，他们每个数都有了自己对应的编码，而且准确无误。1<del>127对应-1</del> -127，再加上两个单身汉0和-128。然后呢，不知道谁起的名字，就把这种编码叫做了补码，如果你乐意，你也可以给它起个名字。但是呢，还有一个问题，为什么补码的求法是按位取反再加一呢，其实当你不明白为什么各大书籍都要用按位取反来计算补码的时候，我们完全可以直接用0减去它就得到他相反数的二进制编码了，譬如随便一个十六进制数 6C ，那么我们可以直接0-6C就得到他的相反数的补码了，结果为十六进制的94，跟按位取反再加一的效果一样。</p>
<p> 现在我们知道补码是怎么来的了，也就是为了保证两个相反数对应二进制的和必须是0，然后又不知道谁给它起了补码这个名字。补码补码，有没有感觉两个相反数是互补的呢，也就是任意两个相反数加起来一定等0，其中一个数变大，另一个就一定会变小互补保证结果为0。但是你肯定还在纠结，为啥要按位取反，为啥还要加一呢。其实，这涉及到一个二进制减法的问题，你既然知道补码这个概念，就一定会知道有进位丢失这么个东西。现在我们知道了补码是怎么来的，也就是（00000000 - 其中一个正数的补码）=（这个数相反数的补码），那么我们知道了1的二进制是00000001，那么我们来求-1的补码，也就是应该00000000 - 00000001=？，我们该怎么计算这个二进制减法呢，而且还是一个小数减去大数，连借位都没地方借，前面我们提到进位丢失这个东西，那么我们来计算一个算式，11111111+00000001=？知道进位丢失的你，肯定知道加起来后等于00000000，虽然结果应该是100000000（后面是8个0），但是只能有8位，所以最高位的1丢失了，那么现在好了，也就是说，我们可以把00000000看做（11111111+00000001）因为他俩是相等的，我们已经计算过的了，那么我们现在就可以把前面讲的公式中的00000000换成（11111111+00000001），也就是我们要计算-1的补码，我们就0-1的编码，也就是00000000-00000001，也就是（11111111+00000001）-00000001=(-1的补码)，这个算式我觉的你应该会计算了，大数减小数，到现在，或许你现在已经发现什么了，是的，你发现了之前一直迷惑你的一个东西，“按位取反再加一”，但是可能还有一点迷惑，我们继续，因为我们每次都是用一个0减去一个数的补码来得到另一个数的补码，也就是里面的（11111111+00000001）是不变的，因为它就是0，那么我们现在要求一个数的补码，就是（11111111+00000001）- 一个数的补码=它相反数的补码，咱们把括号去掉，也就是11111111 - 一个数的补码+00000001=它相反数的补码，这是加法交换法则，只是把位置交换一下，小学生都会的，然后呢再加个括号方便我们理解，也就是（1111111 - 一个数的补码）+00000001=它相反数的补码。好了，问题来了，（11111111 - 一个数的补码）的结果是什么，这个你心里应该是清楚的，你也可以算一下，它正好的等于它的反码，也就是按位取反的一个数，其实也好理解，你减几个数就看见规律了，描述好麻烦，现在好了，也就是（11111111 - 一个数的补码）=这个数的反码，也就是（11111111 - 一个数的补码）=把这个数按位取反，到现在，你应该你已经很清楚他是怎么来的了。</p>
<p>那么我们现在就可以把公式写成这样，（11111111 - 一个数的补码）+00000001=它相反数的补码，现在我们知道了（11111111 - 一个数的补码）=把这个数按位取反，然后把公式里的（11111111 - 一个数的补码）换成 “按位取反”，也就是 （按位取反）+000000001=它相反数的补码，现在，按位取反，再加一，就终于出来了，这就是各大书籍资料所讲的，补码=按位取反+1..。好了，真相大白！！！</p>
<p>本文章属个人领悟，错误必有，不吝赐教</p>
<hr>
<p>版权声明：本文为CSDN博主「wenxinwukui234」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wenxinwukui234/article/details/42119265" target="_blank" rel="noopener">https://blog.csdn.net/wenxinwukui234/article/details/42119265</a></p>
]]></content>
      <categories>
        <category>Mark</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装Docker</title>
    <url>/2020/03/15/CentOS%207%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p><strong>CentOS-7-x86_64-Everything-1908</strong>  下载地址：<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/" target="_blank" rel="noopener">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a></p>
<p><strong>Vmware 15.1.0</strong> 下载地址：<a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe</a>       ( win10 1903版本之后，要使用15+版本，不然主系统向虚拟机拖拽文件时经常会卡死）<a id="more"></a></p>
<p>博文记录时的Docker版本：<strong>Docker v19.03</strong></p>
<p>可以参考官方文档安装：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>
<h2 id="话不多说开始安装："><a href="#话不多说开始安装：" class="headerlink" title="话不多说开始安装："></a>话不多说开始安装：</h2><p>安装过程中最好要保证虚拟机一直可以访问外网！！！</p>
<ul>
<li><p>安装一下gcc：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum -y install gcc</span><br><span class="line">$ yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<p> <img src="https://s2.ax1x.com/2019/11/27/Q9XP1g.png" alt="Q9XP1g.png"></p>
</li>
<li><p>如果之前安装过docker，卸载旧版本docker，不知道之前有没有docker也可以执行一下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p> <img src="https://s2.ax1x.com/2019/11/27/Q9Xd3D.png" alt="Q9Xd3D.png"></p>
<p> 说明我之前没有安装过docker。</p>
</li>
<li><p>安装软件包：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置stable镜像仓库：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>

<p> <font color=red>上述命令是官方提供了，但是由于一些不可抗拒因素，导致我们不能很好地访问Docker提供的这个官方链接，所以经常产生Timeout或者TCP connection reset by peer的错误。所以我们可以使用下面的加速地址指令。</font></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>

<p> <a href="https://imgchr.com/i/Q9zCan" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/27/Q9zCan.md.png" alt="Q9zCan.md.png"></a></p>
<p> 设置成功。</p>
</li>
<li><p>更新一下yum索引，以后下载东西会快点：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum makecache fast</span><br></pre></td></tr></table></figure>

<p> <a href="https://imgchr.com/i/Q9zMI1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/27/Q9zMI1.md.png" alt="Q9zMI1.md.png"></a></p>
<p> 更新成功。</p>
</li>
<li><p>安装Docker:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum -y install docker-ce</span><br></pre></td></tr></table></figure>

<p> <a href="https://imgchr.com/i/QCSH9P" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/27/QCSH9P.md.png" alt="QCSH9P.md.png"></a></p>
<p> 安装完成。</p>
</li>
<li><p>启动Docker，测试一下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl start docker</span><br><span class="line">$ docker run hello-world</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure>

<p> <img src="https://s2.ax1x.com/2019/11/27/QC9Cad.png" alt="QC9Cad.png"></p>
<p> 一切正常。</p>
</li>
<li><p>配置镜像加速，然后重新加载配置文件（  演示中使用网易云镜像地址：{“registry-mirrors”: [“<a href="http://hub-mirror.c.163.com&quot;]">http://hub-mirror.c.163.com&quot;]</a> }  ），重启Docker：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">$ vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/11/27/QC9Wod.png" alt="QC9Wod.png"></p>
<p><font color=red>这里保存退出时一定要用“wq!”，不要用“wq”，不然重启docker时会出问题。</font></p>
<p>可以用以下命令查看一下docker是否安装完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep docker|grep -v grep </span><br><span class="line">$ docker version</span><br></pre></td></tr></table></figure>

<hr>
<p>完成上述步骤，Docker就基本算是安装完成可以开始学习使用了。</p>
]]></content>
      <categories>
        <category>工具环境</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA中Tomcat在控制台乱码问题以及IDEA编码设置UTF-8</title>
    <url>/2020/03/15/IDEA%E7%BC%96%E8%BE%91%E5%99%A8%E5%92%8CTomcat%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%97%A5%E5%BF%97%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p>初次使用IDEA（IDEA2019.1 x64）布局和快捷键等等都还不适应，比较痛苦。<a id="more"></a></p>
<p>忘记设置编码方式导致<strong>代码中的中文错乱</strong>，但是解决起来还是很容易的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting→Editor→FileEncodings</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2019/08/17/mKNwfx.md.png" alt="FileEncodings"></p>
<p>紧接住发现<strong>Tomcat</strong>运行时<strong>控制台相关日志的中文</strong>也错乱了，百度解决方案后解决：</p>
<p><img src="https://s2.ax1x.com/2019/08/17/mKNakR.md.png" alt="Tomcat运行时控制台相关日志的中文也错乱"></p>
<p>然后配置tomcat的编码问题：</p>
<p>Run/DeBug Configurations中</p>
<p>在VM options填写-Dfile.encoding=UTF-8：</p>
<p><img src="https://s2.ax1x.com/2019/08/17/mKNdt1.md.png" alt="在VM options填写-Dfile.encoding=UTF-8："></p>
<p>但是此时依然没有解决问题，继续。。。</p>
<p><strong>打开idea安装目录-bin</strong></p>
<p>用记事本打开<strong>idea.exe.vmoptions</strong>和<strong>idea64.exe.vmoptions</strong>文件</p>
<p><img src="https://s2.ax1x.com/2019/08/18/mKDmvt.png" alt="mKDmvt.png"></p>
<p>分别在文件的最后一行写入：<strong>-Dfile.encoding=UTF-8</strong> </p>
<p><img src="https://s2.ax1x.com/2019/08/17/mKNN79.png" alt="mKNN79.png"></p>
<p> 保存文件，重启IDEA，问题解决！</p>
]]></content>
      <categories>
        <category>工具环境</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8特性(一)</title>
    <url>/2020/03/15/Java8%E7%89%B9%E6%80%A7(%E4%B8%80)/</url>
    <content><![CDATA[<p>默认方法&amp;Lambda表达式&amp;函数式接口&amp;方法引用<a id="more"></a></p>
<p>Java8的重要特性之四：默认方法、函数式接口、Lambda表达式和方法引用，之所以将这四个特性拿出来一起记录学习，因为其作用都是为了在接口定义时或者实现时进一步优化编程体验。其中Lambda表达式和方法引用可以看做是匿名内部类的进一步的抽象，合理的使用这些特性可以使编程更加高效，代码更加简洁清晰。</p>
<h2 id="默认方法："><a href="#默认方法：" class="headerlink" title="默认方法："></a>默认方法：</h2><p>Java的接口用起来很方便，使编程更加易于规范化、格式化，但是也存在一些问题：当修改接口的方法时，所有实现该接口的类都要进行修改，这是很糟糕的体验。于是Java8中引入了默认方法，可以使接口中存在非抽象方法，目的是为了解决接口的修改与现有的实现类不兼容的问题。</p>
<p>关键字：<strong>default</strong></p>
<p>默认语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm B..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意:</strong></font>当B、C两个接口同时存在同名默认方法show()，并且同时被一个类D实现时会报出编译错误：<strong>D inherits unrelated defaults for show() from B and C</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm C..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong>必须在实现类D中重写show()方法进行覆盖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>,<span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm D..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望使用接口中的某个默认方法，可以在重写的方法中使用<strong>接口名.super.方法()</strong>的方式调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>,<span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B.<span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java8中不但允许接口内实现方法，还允许接口实现<strong>静态方法</strong>并通过<strong>接口名.静态方法</strong>来调用。<font color=red>但是接口的实现类和实现类对象不能直接调用接口的静态方法。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>,<span class="title">C</span></span>&#123;<span class="comment">//在B接口中加入静态方法static  void hello()&#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	B.<span class="keyword">super</span>.show();</span><br><span class="line">        B.hello();</span><br><span class="line">        C.<span class="keyword">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">"I'm D..."</span>);</span><br><span class="line">    &#125;<span class="comment">//运行结果： I'm B...</span></span><br><span class="line">&#125;	<span class="comment">//			HelloWorld!</span></span><br><span class="line">	<span class="comment">//			I'm C... </span></span><br><span class="line">	<span class="comment">//			I'm D...</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h2><p>基本语法：(params) -&gt; expression;   或者 (params) -&gt; {expression; expression；…};</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Runnable()&#123;<span class="comment">//匿名内部类实现</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"run..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.run();</span><br><span class="line">		<span class="comment">//改用Lambda表达式</span></span><br><span class="line">        Runnable runnable = ()-&gt; System.out.println(<span class="string">"run..."</span>);</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] atp = &#123;<span class="string">"Rafael Nadal"</span>, <span class="string">"Novak Djokovic"</span>,</span><br><span class="line">                <span class="string">"Stanislas Wawrinka"</span>,</span><br><span class="line">                <span class="string">"David Ferrer"</span>,<span class="string">"Roger Federer"</span>,</span><br><span class="line">                <span class="string">"Andy Murray"</span>,<span class="string">"Tomas Berdych"</span>,</span><br><span class="line">                <span class="string">"Juan Martin Del Potro"</span>&#125;;</span><br><span class="line">        List&lt;String&gt; players =  Arrays.asList(atp);</span><br><span class="line">        <span class="comment">//Java5的增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String player : players) &#123;</span><br><span class="line">            System.out.println(player);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Java8的Lambda表达式</span></span><br><span class="line">        players.forEach((player)-&gt; System.out.println(player));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Lambda表达式只支持<strong>函数式接口</strong>，也就是只有<strong>一个抽象方法</strong>但可以有<strong>多个default方法</strong>的接口。</li>
<li>-&gt;Lambda运算符，左边是<strong>参数</strong>列表，右边是需要执行的<strong>表达式</strong>语句。</li>
<li>当且仅当只有<strong>一个</strong>参数时可以<strong>省略()</strong>，当且仅当只有<strong>一条语句</strong>可以<strong>省略{}和return</strong>。</li>
<li>参数的<strong>类型</strong>可以<strong>不写</strong>，Javac编译时会根据上下文推断出参数的类型，即“类型推断”。</li>
<li>当有多个参数和多条语句时：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator =<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"函数式接口..."</span>);</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">//Lambda表达式</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator1 = (x,y) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"函数式接口..."</span>);</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数式接口："><a href="#函数式接口：" class="headerlink" title="函数式接口："></a>函数式接口：</h2><p><u>函数式接口：有且仅有只有一个抽象方法，但可以有多个非抽象方法的接口。</u></p>
<p>函数式接口可以被隐式的转换为Lambda表达式，并对现有的函数非常友好的支持Lambda表达式。</p>
<p><strong>JDK 1.8 之前已有的函数式接口:</strong></p>
<blockquote>
<ul>
<li>java.lang.Runnable</li>
<li>java.util.concurrent.Callable</li>
<li>java.security.PrivilegedAction</li>
<li>java.util.Comparator</li>
<li>java.io.FileFilter</li>
<li>java.nio.file.PathMatcher</li>
<li>java.lang.reflect.InvocationHandler</li>
<li>java.beans.PropertyChangeListener</li>
<li>java.awt.event.ActionListener</li>
<li>javax.swing.event.ChangeListener</li>
</ul>
</blockquote>
<p><strong>JDK 1.8 新增加的函数接口：</strong></p>
<blockquote>
<ul>
<li>java.util.function</li>
</ul>
</blockquote>
<p>java.util.function包中有很多接口，用来支持函数式编程：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>BiConsumer&lt;T,U&gt;</strong></td>
<td>代表了一个接受两个输入参数的操作，并且不返回任何结果</td>
</tr>
<tr>
<td>2</td>
<td><strong>BiFunction&lt;T,U,R&gt;</strong></td>
<td>代表了一个接受两个输入参数的方法，并且返回一个结果</td>
</tr>
<tr>
<td>3</td>
<td><strong>BinaryOperator<T></strong></td>
<td>代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果</td>
</tr>
<tr>
<td>4</td>
<td><strong>BiPredicate&lt;T,U&gt;</strong></td>
<td>代表了一个两个参数的boolean值方法</td>
</tr>
<tr>
<td>5</td>
<td><strong>BooleanSupplier</strong></td>
<td>代表了boolean值结果的提供方</td>
</tr>
<tr>
<td>6</td>
<td><strong>Consumer<T></strong></td>
<td>代表了接受一个输入参数并且无返回的操作</td>
</tr>
<tr>
<td>7</td>
<td><strong>DoubleBinaryOperator</strong></td>
<td>代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。</td>
</tr>
<tr>
<td>8</td>
<td><strong>DoubleConsumer</strong></td>
<td>代表一个接受double值参数的操作，并且不返回结果。</td>
</tr>
<tr>
<td>9</td>
<td><strong>DoubleFunction<R></strong></td>
<td>代表接受一个double值参数的方法，并且返回结果</td>
</tr>
<tr>
<td>10</td>
<td><strong>DoublePredicate</strong></td>
<td>代表一个拥有double值参数的boolean值方法</td>
</tr>
<tr>
<td>11</td>
<td><strong>DoubleSupplier</strong></td>
<td>代表一个double值结构的提供方</td>
</tr>
<tr>
<td>12</td>
<td><strong>DoubleToIntFunction</strong></td>
<td>接受一个double类型输入，返回一个int类型结果。</td>
</tr>
<tr>
<td>13</td>
<td><strong>DoubleToLongFunction</strong></td>
<td>接受一个double类型输入，返回一个long类型结果</td>
</tr>
<tr>
<td>14</td>
<td><strong>DoubleUnaryOperator</strong></td>
<td>接受一个参数同为类型double,返回值类型也为double 。</td>
</tr>
<tr>
<td>15</td>
<td><strong>Function&lt;T,R&gt;</strong></td>
<td>接受一个输入参数，返回一个结果。</td>
</tr>
<tr>
<td>16</td>
<td><strong>IntBinaryOperator</strong></td>
<td>接受两个参数同为类型int,返回值类型也为int 。</td>
</tr>
<tr>
<td>17</td>
<td><strong>IntConsumer</strong></td>
<td>接受一个int类型的输入参数，无返回值 。</td>
</tr>
<tr>
<td>18</td>
<td><strong>IntFunction<R></strong></td>
<td>接受一个int类型输入参数，返回一个结果 。</td>
</tr>
<tr>
<td>19</td>
<td><strong>IntPredicate</strong></td>
<td>接受一个int输入参数，返回一个布尔值的结果。</td>
</tr>
<tr>
<td>20</td>
<td><strong>IntSupplier</strong></td>
<td>无参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>21</td>
<td><strong>IntToDoubleFunction</strong></td>
<td>接受一个int类型输入，返回一个double类型结果 。</td>
</tr>
<tr>
<td>22</td>
<td><strong>IntToLongFunction</strong></td>
<td>接受一个int类型输入，返回一个long类型结果。</td>
</tr>
<tr>
<td>23</td>
<td><strong>IntUnaryOperator</strong></td>
<td>接受一个参数同为类型int,返回值类型也为int 。</td>
</tr>
<tr>
<td>24</td>
<td><strong>LongBinaryOperator</strong></td>
<td>接受两个参数同为类型long,返回值类型也为long。</td>
</tr>
<tr>
<td>25</td>
<td><strong>LongConsumer</strong></td>
<td>接受一个long类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>26</td>
<td><strong>LongFunction<R></strong></td>
<td>接受一个long类型输入参数，返回一个结果。</td>
</tr>
<tr>
<td>27</td>
<td><strong>LongPredicate</strong></td>
<td>R接受一个long输入参数，返回一个布尔值类型结果。</td>
</tr>
<tr>
<td>28</td>
<td><strong>LongSupplier</strong></td>
<td>无参数，返回一个结果long类型的值。</td>
</tr>
<tr>
<td>29</td>
<td><strong>LongToDoubleFunction</strong></td>
<td>接受一个long类型输入，返回一个double类型结果。</td>
</tr>
<tr>
<td>30</td>
<td><strong>LongToIntFunction</strong></td>
<td>接受一个long类型输入，返回一个int类型结果。</td>
</tr>
<tr>
<td>31</td>
<td><strong>LongUnaryOperator</strong></td>
<td>接受一个参数同为类型long,返回值类型也为long。</td>
</tr>
<tr>
<td>32</td>
<td><strong>ObjDoubleConsumer<T></strong></td>
<td>接受一个object类型和一个double类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>33</td>
<td><strong>ObjIntConsumer<T></strong></td>
<td>接受一个object类型和一个int类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>34</td>
<td><strong>ObjLongConsumer<T></strong></td>
<td>接受一个object类型和一个long类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>35</td>
<td><strong>Predicate<T></strong></td>
<td>接受一个输入参数，返回一个布尔值结果。</td>
</tr>
<tr>
<td>36</td>
<td><strong>Supplier<T></strong></td>
<td>无参数，返回一个结果。</td>
</tr>
<tr>
<td>37</td>
<td><strong>ToDoubleBiFunction&lt;T,U&gt;</strong></td>
<td>接受两个输入参数，返回一个double类型结果</td>
</tr>
<tr>
<td>38</td>
<td><strong>ToDoubleFunction<T></strong></td>
<td>接受一个输入参数，返回一个double类型结果</td>
</tr>
<tr>
<td>39</td>
<td><strong>ToIntBiFunction&lt;T,U&gt;</strong></td>
<td>接受两个输入参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>40</td>
<td><strong>ToIntFunction<T></strong></td>
<td>接受一个输入参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>41</td>
<td><strong>ToLongBiFunction&lt;T,U&gt;</strong></td>
<td>接受两个输入参数，返回一个long类型结果。</td>
</tr>
<tr>
<td>42</td>
<td><strong>ToLongFunction<T></strong></td>
<td>接受一个输入参数，返回一个long类型结果。</td>
</tr>
<tr>
<td>43</td>
<td><strong>UnaryOperator<T></strong></td>
<td>接受一个参数为类型T,返回值类型也为T。</td>
</tr>
</tbody></table>
<p>不难发现，提供的这么多的接口摘要出来无非五种：Consumer(消费型)、Supplier(供给型)、Function(函数型)、Predicate(断言型)、Operator(工具型) 。接下来逐一举例介绍：</p>
<h4 id="Consumer-消费型"><a href="#Consumer-消费型" class="headerlink" title="Consumer(消费型):"></a><font color=#00ffff>Consumer(消费型):</font></h4><p>接口方法 <strong>void accept(T t)</strong>：参数类型是T，无返回值 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了精简代码都使用Lambda表达式实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接受一个T类型参数可以泛型指定，无返回值</span></span><br><span class="line">    Consumer&lt;String&gt; Consumer = (name) -&gt; System.out.println(name);</span><br><span class="line">    Consumer.accept(<span class="string">"张三"</span>);</span><br><span class="line">    <span class="comment">//接受T类型、U类型两个参数可以分别用泛型指定，无返回值</span></span><br><span class="line">    BiConsumer&lt;String,Integer&gt; biConsumer = (name,age)-&gt; System.out.println(name+age);</span><br><span class="line">    biConsumer.accept(<span class="string">"zhangsan"</span>,<span class="number">18</span>);</span><br><span class="line">    <span class="comment">//接受Double类型的参数已指定，无返回值</span></span><br><span class="line">    DoubleConsumer doubleConsumer = (money)-&gt; System.out.println(money);</span><br><span class="line">    doubleConsumer.accept(<span class="number">24.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; consumer)</span></span>&#123;</span><br><span class="line">        consumer.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//就像匿名内部类做参数一样</span></span><br><span class="line">        happy(<span class="number">1000</span>,(e)-&gt; System.out.println(<span class="string">"happy消费了"</span>+ e +<span class="string">"元"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Supplier-供给型"><a href="#Supplier-供给型" class="headerlink" title="Supplier(供给型):"></a><font color=#00ffff>Supplier(供给型):</font></h4><p>接口方法 <strong>T get()</strong>：无参数，有T类型返回值。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无参数，返回String类型返回值，因为只有一条语句所以省略return</span></span><br><span class="line">    Supplier&lt;String&gt; supplier = ()-&gt;<span class="string">"I'm Supplier"</span>;</span><br><span class="line">    System.out.println(supplier.get());</span><br><span class="line">    <span class="comment">//无参数，返回Boolean类型返回值</span></span><br><span class="line">    BooleanSupplier booleanSupplier = ()-&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(booleanSupplier.getAsBoolean());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成size大小的ArrayList集合并填充数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getList</span><span class="params">(<span class="keyword">int</span> size, Supplier&lt;Integer&gt; supplier)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;size ; i++) &#123;</span><br><span class="line">        Integer num = supplier.get();</span><br><span class="line">        list.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = getList(<span class="number">10</span>, ()-&gt;(<span class="keyword">int</span>)(Math.random()*<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Function-函数型"><a href="#Function-函数型" class="headerlink" title="Function(函数型):"></a><font color=#00ffff>Function(函数型):</font></h4><p>接口方法<strong>R apply(T)</strong>：有T类型参数，有R类型返回值 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有T类型参数，有R类型返回值</span></span><br><span class="line">    Function&lt;String, String&gt; function = (str) -&gt; <span class="string">"I'm "</span> + str;</span><br><span class="line">    System.out.println(function.apply(<span class="string">"Function"</span>));</span><br><span class="line">    <span class="comment">//接受两个参数T、U类型，有R类型返回值</span></span><br><span class="line">    BiFunction&lt;String,String,String&gt; stringStringStringBiFunction = (str1,str2)-&gt;str1+str2;</span><br><span class="line">    System.out.println(stringStringStringBiFunction.apply(<span class="string">"I''m"</span>,<span class="string">"BiFunction"</span>));</span><br><span class="line">    <span class="comment">//接受Long类型参数，返回Double类型值</span></span><br><span class="line">    LongToDoubleFunction longToDoubleFunction = (tlong)-&gt;(<span class="keyword">double</span>) (tlong-<span class="number">10</span>);</span><br><span class="line">    System.out.println(longToDoubleFunction.applyAsDouble(<span class="number">123456789</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String,String&gt; function)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function.apply(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//去除首尾空格</span></span><br><span class="line">    String s = strHandler(<span class="string">"\t\t123456  789"</span>, (str) -&gt; (str + <span class="string">"-&gt;no blank space  "</span>).trim());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Predicate-断言型"><a href="#Predicate-断言型" class="headerlink" title="Predicate(断言型):"></a><font color=#00ffff>Predicate(断言型):</font></h4><p>接口方法 <strong>boolean test（T t）</strong>：对T类型参数进行条件筛选操作，返回boolean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个Integer类型参数，有boolean类型返回值</span></span><br><span class="line">    Predicate&lt;Integer&gt; predicate =(num)-&gt;num&gt;<span class="number">10</span>;</span><br><span class="line">    System.out.println(predicate.test(<span class="number">11</span>));</span><br><span class="line">    <span class="comment">//两个参数，有boolean类型返回值</span></span><br><span class="line">    BiPredicate&lt;Double,Double&gt; biPredicate = (num1,num2)-&gt;num1&gt;num2;</span><br><span class="line">    System.out.println(biPredicate.test((<span class="keyword">double</span>)<span class="number">12</span>,<span class="number">13.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回满足条件的新集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getNewList</span><span class="params">(List&lt;String&gt; strList, Predicate&lt;String&gt; predicate)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; newlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : strList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(s))</span><br><span class="line">            newlist.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newlist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"d34"</span>);</span><br><span class="line">    list.add(<span class="string">"d8wq9"</span>);</span><br><span class="line">    list.add(<span class="string">"c9"</span>);</span><br><span class="line">    list.add(<span class="string">"rnglj"</span>);</span><br><span class="line">    <span class="comment">//返回s.length()&gt;3的元素的新集合</span></span><br><span class="line">    List&lt;String&gt; newList = getNewList(list,(s)-&gt;s.length()&gt;<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : newList) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回以9结尾元素的新集合</span></span><br><span class="line">    List&lt;String&gt; newList2 = getNewList(list,(s)-&gt;s.endsWith(<span class="string">"9"</span>));</span><br><span class="line">    <span class="keyword">for</span> (String s : newList2) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="XXXOperator"><a href="#XXXOperator" class="headerlink" title="XXXOperator:"></a><font color=#00ffff>XXXOperator:</font></h4><p>各种XXXOperator接口和Function使用非常类似。。。其中UnaryOperator就是继承了Function&lt;T,T&gt;。</p>
<p>XXXOperator可以看作是Function接口的特殊形式，即参数和返回值类型一致时的Function接口。</p>
<p>举几个例子：</p>
<p>UnaryOperator，就是一个T类型参数，有T类型返回值的情况下的Function&lt;T,T&gt;。</p>
<p>IntUnaryOperator，就是一个Int类型参数，有Int类型返回值情况下的Function&lt;int,int&gt;。</p>
<p>BinaryOperator，就是有两个T类型参数，有T类型返回值的情况下的Function&lt;T,T,T&gt;。</p>
<p>IntBinaryOperator，就是有就是有两个Int类型参数，有Int类型返回值的情况下的Function&lt;Int,Int,Int&gt;。</p>
<p>同理，以此类推。。。</p>
<hr>
<h2 id="方法引用："><a href="#方法引用：" class="headerlink" title="方法引用："></a>方法引用：</h2><p>Lambda表达式的进一步优化，将接口实现的内容封装在一个具体方法里，然后去进行方法引用作为接口的实现。增强方法的可复用性。</p>
<p>基本语法：<strong>CLassName::MethodName</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = &#123;<span class="string">"c"</span>,<span class="string">"D"</span>,<span class="string">"e"</span>,<span class="string">"de"</span>,<span class="string">"qw"</span>,<span class="string">"Aeq"</span>&#125;;</span><br><span class="line">    	<span class="comment">//匿名内部类方式实现接口</span></span><br><span class="line">   		Arrays.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    	<span class="comment">//Lambda表达式中只是调用了一个现有的方法</span></span><br><span class="line">        Arrays.sort(strings,(s1,s2)-&gt;s1.compareToIgnoreCase(s2));</span><br><span class="line">    	<span class="comment">//可以用方法引用的方式实现匿名内部类</span></span><br><span class="line">        Arrays.sort(strings,String::compareToIgnoreCase);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：<u>sort(T[] a, Comparator c) 该方法中的接口参数Comparator是一个函数式接口。</u></p>
<p>方法引用也分几种情况：</p>
<ol>
<li><p><strong>静态方法引用：</strong> <strong>ClassName::staticMethodName</strong></p>
</li>
<li><p><strong>实例对象的方法引用：</strong> <strong>instanceReference::methodName</strong> </p>
</li>
<li><p><strong>超类上的实例方法引用：</strong> <strong>super::methodName</strong> </p>
<p><font color=red>注：</font>通过使用super，可以引用方法的超类版本。 还可以捕获this 指针，this :: equals  等价于lambda表达式  x -&gt; this.equals(x); </p>
</li>
<li><p><strong>类型上的实例方法引用：</strong> <strong>ClassName::methodName</strong>  </p>
</li>
</ol>
<p><font color=red>注：</font>要区别于静态方法引用，实例方法的调用是要依赖于对象去调用的，那么这个对象从何而来呢？   例如：String::toString 等价于lambda表达式 (s) -&gt; s.toString()   方法引用对应Lambda，Lambda的第一个参数会成为调用实例方法的对象。 有时候实例方法时泛型的，方法引用时可以在方法前加上&lt;类型参数&gt;，但大多数情况并不需要手动添加类型参数，编译器往往可以根据上下文推断出类型。</p>
<ol start="5">
<li><p><strong>构造方法引用： Class::new</strong> </p>
<p>例子：String::new， 等价于lambda表达式 () -&gt; new String() </p>
</li>
<li><p><strong>数组构造方法引用： TypeName[]::new</strong> </p>
<p>例子：int[]::new 是一个含有一个参数的构造器引用，这个参数就是数组的长度。等价于lambda表达式  x -&gt; new int[x]。</p>
</li>
</ol>
<p>无论Lambda表达式还是方法引用实质上都是匿名实现了函数式接口，都是对匿名内部类的进一步抽象。</p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>流式语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8特性(二)</title>
    <url>/2020/03/15/Java8%E7%89%B9%E6%80%A7(%E4%BA%8C)/</url>
    <content><![CDATA[<p><a href="https://jerrymouse1998.github.io/post/java8特性一/">Java8特性—流式语法</a>总结过Java8流式语法相关特性：函数式接口、默认方法、Lambda表达式、方法引用。<a id="more"></a></p>
<p>这次学一下Java8的其他特性：Stream API、Optional类、Date-Time API、Base64编码、Nashorn。</p>
<blockquote>
<p>——转载自<a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">RUNOOB</a>、<a href="https://www.cnblogs.com/rjzheng/p/9163246.html#4025294" target="_blank" rel="noopener">孤独烟</a>、<a href="https://blog.csdn.net/h_xiao_x/article/details/79729507" target="_blank" rel="noopener">回梦游先</a></p>
</blockquote>
<p>[TOC]</p>
<h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a><strong>Stream API</strong></h2><p>Java8API添加了一个新的抽象成为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream使用一种类似于SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。</p>
<ul>
<li>StreamAPI可以极大提高Java程序员的生产力，让程序员写出高效率，干净，简洁的代码。</li>
</ul>
<p>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的结点上进行处理，比如筛选，排序，聚合等。。。</p>
<p>元素流在管道中经过中间操作(intermediate operation)的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
<p>流程：stream of elements —–&gt; filter-&gt; sorted-&gt; map-&gt; collect</p>
<p>以上的流程转换为Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure>

<h3 id="什么是Stream？"><a href="#什么是Stream？" class="headerlink" title="什么是Stream？"></a>什么是Stream？</h3><p>Stream(流)是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成的一个队列。Java中的Steam并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong> 流的来源。可以是集合、数组、I/O channel、产生器geanerator等等。</li>
<li><strong>聚合操作</strong> 类似SQL语句一样的操作，比如filter、map、reduce、find、match、sorted等。和以前的Collection操作不同，Stream操作还有两个基础的特征：<ul>
<li><strong>Pipelining</strong>：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格(fluent style)。这样做可以对操作进行优化，比如延迟执行(laziness)和短路(shor-circuiting)。</li>
<li><strong>内部迭代</strong>：以前对集合遍历都是通过Iterator或者For-Each的方式，显式的在集合外部进行迭代，这叫做<strong>外部迭代</strong>。Stream提供了<strong>内部迭代</strong>的方式，通过<strong>访问者模式(Visitor)</strong>实现。</li>
</ul>
</li>
</ul>
<h3 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h3><p>在Java8中，集合接口有两个方法来生成流：</p>
<ul>
<li><strong>stream()</strong>—为集合创建串行流。</li>
<li><strong>parallel Stream()</strong>—为集合创建并行流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Stream提供了新的方法“forEach”来迭代流中的每个数据。以下代码片段使用forEach输出了10个随机数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map方法用于映射每个元素到对应的结果，以下代码片段使用map输出了元素对应的平方数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter方法用于通过设置的条件过滤出元素。以下代码片段使用filter方法过滤出空字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit方法用于获取指定数量的流。以下代码片段使用limit方法打印出10条数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted方法用于对流进行排序。以下代码片段使用sorted方法对输出的10个随机数进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="并行-parallel-程序"><a href="#并行-parallel-程序" class="headerlink" title="并行(parallel)程序"></a>并行(parallel)程序</h3><p>parallelStream是流并行处理程序的替代方法。以下实例我们使用parallelStream来输出空字符串的数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><p>Collectors类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"筛选列表: "</span> + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br></pre></td></tr></table></figure>

<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>一些产生统计结果的收集器也非常有用。他们主要用于int、double、long等基本类型上，他们可以用来产生类似如下的统计结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//mapToInt((x) -&gt; x)返回一个IntStream对象</span></span><br><span class="line"><span class="comment">//summaryStatistics()返回一个IntSummaryStatistics对象</span></span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"列表中最大的数 : "</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">"列表中最小的数 : "</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">"所有数之和 : "</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">"平均数 : "</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a><strong>Optional类</strong></h2><p>Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional是个容器：他可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>Optional类的引用很好的解决空指针异常。</p>
<h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>java.util.Optinoal&lt;T&gt;类的声明:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt;<span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p><strong>注意：</strong> 这些方法是从 <strong>java.lang.Object</strong> 类继承来的。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="left">方法   &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">*<em>static &lt;T&gt;  Optional&lt;T&gt;   empty()  *</em>      返回空的 Optional 实例。</td>
</tr>
<tr>
<td>2</td>
<td align="left"><strong>boolean equals(Object   obj)</strong>        判断其他对象是否等于 Optional。</td>
</tr>
<tr>
<td>3</td>
<td align="left">*<em>Optional&lt;T&gt;   filter(Predicate&lt;? super &lt;T&gt; predicate)   *</em>如果值存在，并且这个值匹配给定的   predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</td>
</tr>
<tr>
<td>4</td>
<td align="left"><strong>Optional&lt;T&gt; filter(Predicate&lt;? super &lt;T&gt; predicate)</strong>      如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</td>
</tr>
<tr>
<td>5</td>
<td align="left">*<em>T   get() *</em>  如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException，使用get()方法前，最好进行isPresent()校验。</td>
</tr>
<tr>
<td>6</td>
<td align="left"><strong>int hashCode()</strong>      返回存在值的哈希码，如果值不存在 返回   0。</td>
</tr>
<tr>
<td>7</td>
<td align="left"><strong>void ifPresent(Consumer&lt;? super   T&gt; consumer)</strong>     如果值存在则使用该值调用 consumer</td>
</tr>
<tr>
<td>8</td>
<td align="left"><strong>boolean   isPresent()</strong>      如果值存在则方法会返回true，否则返回 false。</td>
</tr>
<tr>
<td>9</td>
<td align="left"><strong>&lt;U&gt;Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper)</strong>  如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</td>
</tr>
<tr>
<td>10</td>
<td align="left"><strong>static &lt;T&gt; Optional&lt;T&gt;   of(T value)</strong>  返回一个指定非null值的Optional。</td>
</tr>
<tr>
<td>11</td>
<td align="left">*<em>static &lt;T&gt; Optional&lt;T&gt;   ofNullable(T value)  *</em>如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</td>
</tr>
<tr>
<td>12</td>
<td align="left"><strong>T orElse(T other)</strong>  如果存在该值，返回值， 否则返回   other。</td>
</tr>
<tr>
<td>13</td>
<td align="left"><strong>T orElseGet(Supplier&lt;? extends   T&gt; other)</strong>   如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td>
</tr>
<tr>
<td>14</td>
<td align="left">*<em>&lt;X extends Throwable&gt; T   orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)    *</em>如果存在该值，返回包含的值，否则抛出由   Supplier 继承的异常。</td>
</tr>
<tr>
<td>15</td>
<td align="left"><strong>String   toString()</strong>    返回一个Optional的非空字符串，用来调试。</td>
</tr>
</tbody></table>
<h4 id="1、Optional-T-value-empty-of-T-value-ofNullable-T-value"><a href="#1、Optional-T-value-empty-of-T-value-ofNullable-T-value" class="headerlink" title="1、Optional(T value),empty(),of(T value),ofNullable(T value)"></a>1、Optional(T value),empty(),of(T value),ofNullable(T value)</h4><p>这四个函数之间具有相关性，因此放在一组进行记忆。</p>
<p>先说明一下，Optional(T value)即构造函数，它是private权限的，不能由外部调用的。其余三个函数是public权限，供用户调用。<strong>那么Optional的本质就是内部储存了一个真实的值，在构造的时候，就直接判断其值是否为空</strong>。直接上Optional(T value)构造函数的源码，如下图：</p>
<p><img src="https://s2.ax1x.com/2019/09/21/nxrlVO.png" alt="nxrlVO.png"></p>
<p><strong>of(T value)</strong>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Optional(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其内部直接调用了构造函数，根据构造函数可以得到两个结论：</p>
<ol>
<li>通过of(T value)函数所构造出的Optional对象，当value属性值为空时，依然会报出NPE。</li>
<li>通过of(T value)函数所构造出的Optional对象，当value属性值不为空是，能正常构造Optional对象。</li>
</ol>
<p>除此之外，Optional内部还维护一个value为null的对象，大概长下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，<strong>empty()的作用</strong>就是返回EMPTY对象。</p>
<p>说前面三个方法都是为了铺垫，可以说<strong>ofNullable(T value)的作用</strong>了，上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> var0 == <span class="keyword">null</span> ? empty() : of(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，相比较of(T value)的<strong>区别</strong>就是，当value值为null时，<strong>of(T value)</strong>会报NPE异常；而<strong>ofNullable(T value)</strong>不会throw Exception，ofNullable(T value)直接返回一个EMPTY对象。</p>
<p><strong>那是不是意味着，我们在项目中只用ofNullable(T value)函数而不需要of(T value)函数了呢？</strong></p>
<p>不是的，既然存在那么自然有存在的价值。当我们在运行过程中，不想隐藏NPE，而是要立刻报告，这种情况下就用of(T value)函数。但是不得不说，这种场景很少很少，博主也仅在写junit测试用例中用到过此函数。</p>
<h4 id="2、orElse-T-other-、orElseGet-Supplier-lt-extendsT-gt-other-、orElseThrow-Supplier-lt-extends-X-gt-exceptionSupplier"><a href="#2、orElse-T-other-、orElseGet-Supplier-lt-extendsT-gt-other-、orElseThrow-Supplier-lt-extends-X-gt-exceptionSupplier" class="headerlink" title="2、orElse(T other)、orElseGet(Supplier&lt;? extendsT&gt; other)、orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)"></a>2、orElse(T other)、orElseGet(Supplier&lt;? extendsT&gt; other)、orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</h4><p>这三个函数放一组进行记忆，都是在构造函数传入的value值为null时，进行调用的。<strong>orElse</strong>和<strong>orElseGet</strong>的用法如下所示，相当于value值为null时，给予一个默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    user = Optional.ofNullable(user).orElse(createUser());</span><br><span class="line">    user = Optional.ofNullable(user).orElseGet(() -&gt; createUser());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">createUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"zhangsan"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数的<strong>区别</strong>：当user值不为null时，orElse函数依然会执行createUser()函数，而orElseGet函数并不会执行createUser()函数。</p>
<p>至于orElseThrow，就是value值为null时，直接抛一个异常出去，用法如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">Optional.ofNullable(user).orElseThrow(()-&gt;<span class="keyword">new</span> Exception(<span class="string">"用户不存在"</span>));</span><br></pre></td></tr></table></figure>

<h4 id="3、map-Function-lt-super-T-extends-U-gt-mapper-和flatMap-Function-lt-super-T-Optional-lt-U-gt-gt-mapper"><a href="#3、map-Function-lt-super-T-extends-U-gt-mapper-和flatMap-Function-lt-super-T-Optional-lt-U-gt-gt-mapper" class="headerlink" title="3、map(Function &lt;? super T,? extends U&gt; mapper)和flatMap(Function &lt;? super T,Optional&lt;U&gt;&gt; mapper)"></a>3、map(Function &lt;? super T,? extends U&gt; mapper)和flatMap(Function &lt;? super T,Optional&lt;U&gt;&gt; mapper)</h4><p>这两个函数放在一组记忆，这两个函数做的是转换值的操作。上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; var1)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(var1);</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.isPresent() ? empty() : ofNullable(var1.apply(<span class="keyword">this</span>.value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Optional&lt;U&gt;&gt; var1)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(var1);</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.isPresent() ? empty() : (Optional)Objects.requireNonNull(var1.apply(<span class="keyword">this</span>.value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数，在函数体的上的区别不大，<strong>主要的区别</strong>就是入参，map函数所接受的入参类型为Function&lt;? supper T,? extends U&gt;,而flapMap的入参类型为Function&lt;? super T,Optional&lt;U&gt;&gt;。</p>
<p>具体用法上，对于<strong>map</strong>而言：</p>
<p>如果User结构是下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候取name的写法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = Optional.ofNullable(user).map(u-&gt; u.getName()).get()；</span><br></pre></td></tr></table></figure>

<p>对于<strong>flatmap</strong>而言则是这样：</p>
<p>如果User结构是下面这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候取name的写法如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = Optional.ofNullable(user).flatMap(u-&gt;u.getName()).get()；</span><br></pre></td></tr></table></figure>

<h4 id="4、isPresent-和ifPresent-Consumer-lt-super-T-gt-consumer"><a href="#4、isPresent-和ifPresent-Consumer-lt-super-T-gt-consumer" class="headerlink" title="4、isPresent()和ifPresent(Consumer&lt;? super T&gt; consumer)"></a>4、isPresent()和ifPresent(Consumer&lt;? super T&gt; consumer)</h4><p>这两个函数放在一起记忆，isPresent即判断value值是否为空，而ifPresent就是在value值不为空时，做一些操作。上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        var1.accept(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>注意：</font>不要进行下面这种鸡肋的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写成</span></span><br><span class="line">User user = Optional.ofNullable(user);</span><br><span class="line"><span class="keyword">if</span> (Optional.isPresent())&#123;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这样写，代码结构依然丑陋。后面会给出正确写法</p>
<p>至于ifPresent(Consumer &lt;?super T&gt; consumer),用法也很简单，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(user).ifPresent(u-&gt;&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5、filter-Predicate-lt-super-T-gt-predicate"><a href="#5、filter-Predicate-lt-super-T-gt-predicate" class="headerlink" title="5、filter(Predicate&lt;? super T&gt; predicate)"></a>5、filter(Predicate&lt;? super T&gt; predicate)</h4><p>直接上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//省略....</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="keyword">this</span> : empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>filter方法接受一个Predicate来对Optional中包含的值进行过滤，如果包含的值满足条件，那么还是返回这个Optional；否则返回Optional.empty。</p>
<p>用法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; user1 = Optional.ofNullable(user).filter(u -&gt; u.getName().length()&lt;<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>如上所示，如果user的name的长度是小于6的，则返回。如果是大于6的，则返回一个EMPTY对象。</p>
<h3 id="实战使用"><a href="#实战使用" class="headerlink" title="实战使用"></a>实战使用</h3><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">(User user)</span>  <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(user.getAddress()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Address address = user.getAddress();</span><br><span class="line">            <span class="keyword">if</span>(address.getCity()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> address.getCity();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Excpetion(<span class="string">"取值错误"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JAVA8写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(user)</span><br><span class="line">        .map(u-&gt; u.getAddress())</span><br><span class="line">        .map(a-&gt;a.getCity())</span><br><span class="line">        .orElseThrow(()-&gt;<span class="keyword">new</span> Exception(<span class="string">"取指错误"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前写法</span></span><br><span class="line"><span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    dosomething(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JAVA8写法</span></span><br><span class="line">Optional.ofNullable(user)</span><br><span class="line">    .ifPresent(u-&gt;&#123;</span><br><span class="line">        dosomething(u);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        String name = user.getName();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"zhangsan"</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"zhangsan"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java8写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(user)</span><br><span class="line">        .filter(u-&gt;<span class="string">"zhangsan"</span>.equals(u.getName()))</span><br><span class="line">        .orElseGet(()-&gt; &#123;</span><br><span class="line">            User user1 = <span class="keyword">new</span> User();</span><br><span class="line">            user1.setName(<span class="string">"zhangsan"</span>);</span><br><span class="line">            <span class="keyword">return</span> user1;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有很多应用的例子，就不一一列举了。不过采用这种链式编程，虽然代码优雅了。但是，逻辑性没那么明显，可读性有所下降，大家项目中看情况酌情使用。</p>
<hr>
<h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a><strong>Date-Time API</strong></h2><p>Java8发布新的Date-Time API(JSR 310)来进一步加强对日期和时间的处理。</p>
<p>在旧版的Java中，日期时间API存在诸多问题，其中有：</p>
<ul>
<li><strong>非线程安全</strong>：java.util.Date是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li><strong>设计很差</strong>：Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li>
<li><strong>时区处理麻烦</strong>：日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。</li>
</ul>
<p>Java8在<strong>java.time</strong>包下提供了很多的新的API。以下为两个比较重要的API：</p>
<ul>
<li><strong>Local(本地)</strong>：简化了日期时间的处理，没有时区的问题。</li>
<li><strong>Zoned(时区)</strong>：通过制定的时区处理日期时间。</li>
</ul>
<p>新的java.time包涵盖了所有处理日期、时间、日期/时间、时区、时刻(instants)、过程(during)与时钟(clock)的操作。</p>
<h3 id="常用、重要对象介绍："><a href="#常用、重要对象介绍：" class="headerlink" title="常用、重要对象介绍："></a>常用、重要对象介绍：</h3><p><strong>ZoneId：时区ID，用来确定Instant和LocalDateTime互相转换的规则。</strong></p>
<p><strong>Instant：用来表示时间线上的一个点（瞬时）。</strong></p>
<p><strong>LocalDate：表示没有时区的日期，LocalDate是不可变并且线程安全的。</strong></p>
<p><strong>LocalTime：表示没有时区的时间，LocalTime是不可变并且线程安全的。</strong></p>
<p><strong>LocalDateTime：表示没有时区的日期时间，LocalDateTime是不可变并且线程安全的。</strong></p>
<p><strong>Clock：用于访问当前时刻、日期、时间，用到时区。</strong></p>
<p><strong>Duration：用秒和纳秒表示时间的数量（长短），用于计算两个日期的“时间”间隔。</strong></p>
<p><strong>Period：用于计算两个“日期”间隔。</strong></p>
<p><u>其中，LocalDate、LocalTime、LocalDateTime都是新API里的基础对象，绝大多数操作都是围绕这三个对象来进行的，有必要啰嗦一遍：</u></p>
<p><strong>LocalDate：只含年 月 日的日期对象。</strong></p>
<p><strong>LocalTime：只含时 分 秒的时间对象。</strong></p>
<p><strong>LocalDateTime：同时含有年 月 日 时 分 秒的日期对象。</strong></p>
<h3 id="直接上示例："><a href="#直接上示例：" class="headerlink" title="直接上示例："></a>直接上示例：</h3><h4 id="1-获取当前时间："><a href="#1-获取当前时间：" class="headerlink" title="1.获取当前时间："></a>1.获取当前时间：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2019-09-22T12:22:10.214</span></span><br><span class="line"><span class="comment">//2019-09-22</span></span><br><span class="line"><span class="comment">//12:22:10.215</span></span><br></pre></td></tr></table></figure>

<h4 id="2-根据指定日期-时间创建对象："><a href="#2-根据指定日期-时间创建对象：" class="headerlink" title="2.根据指定日期/时间创建对象："></a>2.根据指定日期/时间创建对象：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2018</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">        LocalDate localDate = LocalDate.of(<span class="number">2018</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">        LocalTime localTime = LocalTime.of(<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2018-08-08T08:08:08</span></span><br><span class="line"><span class="comment">//2018-08-08</span></span><br><span class="line"><span class="comment">//08:08:08</span></span><br></pre></td></tr></table></figure>

<h4 id="3-日期时间的加减："><a href="#3-日期时间的加减：" class="headerlink" title="3.日期时间的加减："></a>3.日期时间的加减：</h4><p><font color=red>注意：对于<strong>LocalDate</strong>，只有精度大于等于日的加减，如年，月，日；对于<strong>LocalTime</strong>，只有精度小于等于时加减，如时，分，秒，纳秒；对于<strong>LocalDateTime</strong>，则可以进行任意精度的时间相加减；否则会抛出异常：java.time.temporal.UnsupportedTemporalTypeException: Unsupported unit: XXX</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line"><span class="comment">//以下方法的参数都是long型，返回值都是LocalDateTime</span></span><br><span class="line">        LocalDateTime plusYearsResult = localDateTime.plusYears(<span class="number">2L</span>);</span><br><span class="line">        LocalDateTime plusMonthsResult = localDateTime.plusMonths(<span class="number">4L</span>);</span><br><span class="line">        LocalDateTime plusDaysResult = localDateTime.plusDays(<span class="number">7L</span>);</span><br><span class="line">        LocalDateTime plusHoursResult = localDateTime.plusHours(<span class="number">2L</span>);</span><br><span class="line">        LocalDateTime plusMinutesResult = localDateTime.plusMinutes(<span class="number">10L</span>);</span><br><span class="line">        LocalDateTime plusSecondsResult = localDateTime.plusSeconds(<span class="number">10L</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前时间是 : "</span> + localDateTime + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加2年后为 : "</span> + plusYearsResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加3个月后为 : "</span> + plusMonthsResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加7日后为 : "</span> + plusDaysResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加2小时后为 : "</span> + plusHoursResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加10分钟后为 : "</span> + plusMinutesResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加10秒后为 : "</span> + plusSecondsResult + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line"><span class="comment">//也可以以另一种方式来相加减日期，即plus(long amountToAdd, TemporalUnit unit)</span></span><br><span class="line"><span class="comment">//             参数1 ： 相加的数量， 参数2 ： 相加的单位</span></span><br><span class="line">        LocalDateTime nextMonth = localDateTime.plus(<span class="number">1</span>, ChronoUnit.MONTHS);</span><br><span class="line">        LocalDateTime nextYear = localDateTime.plus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">        LocalDateTime nextWeek = localDateTime.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"now : "</span> + localDateTime + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"nextYear : "</span> + nextYear + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"nextMonth : "</span> + nextMonth + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"nextWeek :"</span> + nextWeek + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line"><span class="comment">//日期的减法用法一样，在此不再举例用minus()方法或者minusXXX()方法</span></span><br><span class="line">        LocalDateTime minus = localDateTime.minus(<span class="number">1L</span>, ChronoUnit.YEARS);</span><br><span class="line">        System.out.println(minus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前时间是 : 2019-09-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加2年后为 : 2021-09-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加3个月后为 : 2020-01-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加7日后为 : 2019-09-29T13:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加2小时后为 : 2019-09-22T15:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加10分钟后为 : 2019-09-22T13:11:41.773</span></span><br><span class="line"><span class="comment">//当前时间加10秒后为 : 2019-09-22T13:01:51.773</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//now : 2019-09-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//nextYear : 2020-09-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//nextMonth : 2019-10-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//nextWeek :2019-09-29T13:01:41.773</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2018-09-22T13:01:41.773</span></span><br></pre></td></tr></table></figure>

<h4 id="4-将年、月、日、等修改为指定的值，并返回新的日期-时间对象："><a href="#4-将年、月、日、等修改为指定的值，并返回新的日期-时间对象：" class="headerlink" title="4.将年、月、日、等修改为指定的值，并返回新的日期/时间对象："></a>4.将年、月、日、等修改为指定的值，并返回新的日期/时间对象：</h4><p><font color=red>注意：在指定日期/时间时要注意取值范围，日期还要注意日期基础上是否为闰年(leap year)，如果超出取值范围会报出：java.time.DateTimeException: Invalid value for DayOfYear (valid values 1 - 365/366): XXX，如果没有注意是否为闰年去特殊范围值的时候会报出：java.time.DateTimeException: Invalid date ‘DayOfYear XXX’ as ‘XXXX’ is not a leap year</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line"><span class="comment">//当前时间基础上，指定本年当中的第几天，取值范围为1-365,366</span></span><br><span class="line">        LocalDate withDayOfYearResult = localDate.withDayOfYear(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//当前时间基础上，指定本月当中的第几天，取值范围为1-29,30,31</span></span><br><span class="line">        LocalDate withDayOfMonthResult = localDate.withDayOfMonth(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//当前时间基础上，直接指定年份</span></span><br><span class="line">        LocalDate withYearResult = localDate.withYear(<span class="number">2017</span>);</span><br><span class="line"><span class="comment">//当前时间基础上，直接指定月份</span></span><br><span class="line">        LocalDate withMonthResult = localDate.withMonth(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前时间是 : "</span> + localDate + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"指定本年当中的第200天 : "</span> + withDayOfYearResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"指定本月当中的第5天 : "</span> + withDayOfMonthResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"直接指定年份为2017 : "</span> + withYearResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"直接指定月份为5月 : "</span> + withMonthResult + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前时间是 : 2019-09-22</span></span><br><span class="line"><span class="comment">//指定本年当中的第200天 : 2019-07-19</span></span><br><span class="line"><span class="comment">//指定本月当中的第5天 : 2019-09-05</span></span><br><span class="line"><span class="comment">//直接指定年份为2017 : 2017-09-22</span></span><br><span class="line"><span class="comment">//直接指定月份为5月 : 2019-05-22</span></span><br></pre></td></tr></table></figure>

<h4 id="5-获取日期的年月日周时分秒："><a href="#5-获取日期的年月日周时分秒：" class="headerlink" title="5.获取日期的年月日周时分秒："></a>5.获取日期的年月日周时分秒：</h4><p>直接用getDayOfWeek或者getMonth取得的是枚举类型(enum)的英文单词，可以用可以再用Week或者Month枚举类提供的getValue方法转换为数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        <span class="keyword">int</span> dayOfYear = localDateTime.getDayOfYear();</span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = localDateTime.getDayOfMonth();</span><br><span class="line">        DayOfWeek dayOfWeek = localDateTime.getDayOfWeek();</span><br><span class="line">        System.out.println(<span class="string">"今天是"</span> + localDateTime + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"本年当中第"</span> + dayOfYear + <span class="string">"天"</span> + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"本月当中第"</span> + dayOfMonth + <span class="string">"天"</span> + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"本周中星期"</span> + dayOfWeek.getValue() + <span class="string">"-即"</span> + dayOfWeek + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当天时间的年月日时分秒</span></span><br><span class="line">        <span class="keyword">int</span> year = localDateTime.getYear();</span><br><span class="line">        Month month = localDateTime.getMonth();</span><br><span class="line">        <span class="keyword">int</span> day = localDateTime.getDayOfMonth();</span><br><span class="line">        <span class="keyword">int</span> hour = localDateTime.getHour();</span><br><span class="line">        <span class="keyword">int</span> minute = localDateTime.getMinute();</span><br><span class="line">        <span class="keyword">int</span> second = localDateTime.getSecond();</span><br><span class="line">        System.out.println(<span class="string">"今天是"</span> + localDateTime + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"年 ： "</span> + year + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"月 ： "</span> + month.getValue() + <span class="string">"-即 "</span>+ month + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"日 ： "</span> + day + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"时 ： "</span> + hour + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"分 ： "</span> + minute + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"秒 ： "</span> + second + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//今天是2019-09-22T13:30:03.943</span></span><br><span class="line"><span class="comment">//本年当中第265天</span></span><br><span class="line"><span class="comment">//本月当中第22天</span></span><br><span class="line"><span class="comment">//本周中星期7-即SUNDAY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//今天是2019-09-22T13:30:03.943</span></span><br><span class="line"><span class="comment">//年 ： 2019</span></span><br><span class="line"><span class="comment">//月 ： 9-即 SEPTEMBER</span></span><br><span class="line"><span class="comment">//日 ： 22</span></span><br><span class="line"><span class="comment">//时 ： 13</span></span><br><span class="line"><span class="comment">//分 ： 30</span></span><br><span class="line"><span class="comment">//秒 ： 3</span></span><br></pre></td></tr></table></figure>

<h4 id="6-时间-日期前后的比较与判断："><a href="#6-时间-日期前后的比较与判断：" class="headerlink" title="6.时间/日期前后的比较与判断："></a>6.时间/日期前后的比较与判断：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断两个时间点的前后</span></span><br><span class="line">        LocalDate localDate1 = LocalDate.of(<span class="number">2019</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        LocalDate localDate2 = LocalDate.of(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">boolean</span> date1IsBeforeDate2 = localDate1.isBefore(localDate2);</span><br><span class="line">        System.out.println(<span class="string">"date1IsBeforeDate2 : "</span> + date1IsBeforeDate2);</span><br><span class="line">        <span class="comment">//API还提供了isAfter()、isEqual()，顾名思义就不必举例了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//date1IsBeforeDate2 : false</span></span><br></pre></td></tr></table></figure>

<h4 id="7-判断是否为闰年："><a href="#7-判断是否为闰年：" class="headerlink" title="7.判断是否为闰年："></a>7.判断是否为闰年：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDate now = LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">"now : "</span> + now + <span class="string">", is leap year ? "</span> + now.isLeapYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//now : 2019-09-22, is leap year ? false</span></span><br></pre></td></tr></table></figure>

<h4 id="8-java8时钟-：-clock"><a href="#8-java8时钟-：-clock" class="headerlink" title="8.java8时钟 ： clock()"></a>8.java8时钟 ： clock()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回当前时间，根据系统时间和UTC</span></span><br><span class="line">        Clock clock = Clock.systemUTC();</span><br><span class="line">        System.out.println(clock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SystemClock[Z]</span></span><br></pre></td></tr></table></figure>

<h4 id="9-时间戳"><a href="#9-时间戳" class="headerlink" title="9.时间戳:"></a>9.时间戳:</h4><p><font color=red>事实上<strong>Instant</strong>就是Java8之前的Date，可以使用以下两个类中的方法在这两个类型之间进行转换，比如Date.from(Instant)就是用来把Instant转换成java.util.date的，而new Date().toInstant()就是将Date转换为Instant的。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant instant = Instant.now();</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">        Date date = Date.from(instant);</span><br><span class="line">        Instant instant2 = date.toInstant();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        System.out.println(instant2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2019-09-22T05:51:30.257Z</span></span><br><span class="line"><span class="comment">//Sun Sep 22 13:51:30 CST 2019</span></span><br><span class="line"><span class="comment">//2019-09-22T05:51:30.257Z</span></span><br></pre></td></tr></table></figure>

<h4 id="10-计算时间-日期间隔"><a href="#10-计算时间-日期间隔" class="headerlink" title="10.计算时间/日期间隔:"></a>10.计算时间/日期间隔:</h4><p>Duration：用于计算两个“时间”间隔</p>
<p>Period：用于计算两个“日期”间隔</p>
<p><font color=red>注意：当获取两个日期的间隔时，并不是单纯的年月日对应的数字相加减，而是会先算出具体差多少天，在折算成相差几年几月几日的</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算两个日期的日期间隔-年月日</span></span><br><span class="line">        LocalDate date1 = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">13</span>);</span><br><span class="line">        LocalDate date2 = LocalDate.of(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//内部是用date2-date1，所以得到的结果是负数</span></span><br><span class="line">        Period period = Period.between(date1, date2);</span><br><span class="line">        System.out.println(<span class="string">"相差年数 ： "</span> + period.getYears());</span><br><span class="line">        System.out.println(<span class="string">"相差月数 ： "</span> + period.getMonths());</span><br><span class="line">        System.out.println(<span class="string">"相差日数 ： "</span> + period.getDays());</span><br><span class="line"><span class="comment">//还可以这样获取相差的年月日</span></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        <span class="keyword">long</span> years = period.get(ChronoUnit.YEARS);</span><br><span class="line">        <span class="keyword">long</span> months = period.get(ChronoUnit.MONTHS);</span><br><span class="line">        <span class="keyword">long</span> days = period.get(ChronoUnit.DAYS);</span><br><span class="line">        System.out.println(<span class="string">"相差的年月日分别为 ： "</span> + years + <span class="string">","</span> + months + <span class="string">","</span> + days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算两个时间的间隔</span></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        LocalDateTime date3 = LocalDateTime.now();</span><br><span class="line">        LocalDateTime date4 = LocalDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line">        Duration duration = Duration.between(date3, date4);</span><br><span class="line">        System.out.println(date3 + <span class="string">" 与 "</span> + date4 + <span class="string">" 间隔  "</span> + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 天 :"</span> + duration.toDays() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 时 :"</span> + duration.toHours() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 分 :"</span> + duration.toMinutes() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 毫秒 :"</span> + duration.toMillis() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 纳秒 :"</span> + duration.toNanos() + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相差年数 ： 0</span></span><br><span class="line"><span class="comment">//相差月数 ： -11</span></span><br><span class="line"><span class="comment">//相差日数 ： -1</span></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"><span class="comment">//相差的年月日分别为 ： 0,-11,-1</span></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"><span class="comment">//2019-09-22T13:58:43.623 与 2018-01-13T22:30:10 间隔  </span></span><br><span class="line"><span class="comment">// 天 :-616</span></span><br><span class="line"><span class="comment">// 时 :-14799</span></span><br><span class="line"><span class="comment">// 分 :-887968</span></span><br><span class="line"><span class="comment">// 毫秒 :-53278113623</span></span><br><span class="line"><span class="comment">// 纳秒 :-53278113623000000</span></span><br></pre></td></tr></table></figure>

<h4 id="11-当计算程序的运行时间时，应当使用时间戳Instant"><a href="#11-当计算程序的运行时间时，应当使用时间戳Instant" class="headerlink" title="11.当计算程序的运行时间时，应当使用时间戳Instant:"></a>11.当计算程序的运行时间时，应当使用时间戳Instant:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant ins1 = Instant.now();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//循环一百万次</span></span><br><span class="line">        &#125;</span><br><span class="line">        Instant ins2 = Instant.now();</span><br><span class="line">        Duration duration = Duration.between(ins1, ins2);</span><br><span class="line">        System.out.println(<span class="string">"程序运行耗时为 ： "</span> + duration.toMillis() + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序运行耗时为 ： 1毫秒</span></span><br></pre></td></tr></table></figure>

<h4 id="12-时间日期的格式化（格式化后返回的类型是String）"><a href="#12-时间日期的格式化（格式化后返回的类型是String）" class="headerlink" title="12.时间日期的格式化（格式化后返回的类型是String）:"></a>12.时间日期的格式化（格式化后返回的类型是String）:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用jdk自身配置好的日期格式</span></span><br><span class="line">        DateTimeFormatter formatter1 = DateTimeFormatter.ISO_DATE_TIME;</span><br><span class="line">        LocalDateTime date1 = LocalDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">"LocalDateTime："</span>+date1);</span><br><span class="line">        <span class="comment">//反过来调用也可以 : date1.format(formatter1);</span></span><br><span class="line">        String date1Str = formatter1.format(date1);</span><br><span class="line">        System.out.println(<span class="string">"jdk自身配置好的日期格式："</span>+date1Str);</span><br><span class="line">        <span class="comment">//使用自定义的日期格式</span></span><br><span class="line">        DateTimeFormatter dtf= DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String formatDateTime = date1.format(dtf);</span><br><span class="line">        System.out.println(<span class="string">"自定义日期格式:"</span>+formatDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LocalDateTime：2019-09-22T14:21:21.762</span></span><br><span class="line"><span class="comment">//jdk自身配置好的日期格式：2019-09-22T14:21:21.762</span></span><br><span class="line"><span class="comment">//自定义日期格式:2019-09-22 14:21:21</span></span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意</strong>：格式的写法必须与字符串的形式一样：如：</font></p>
<p><font color=red>2018-01-13 21:27:30 对应  yyyy-MM-dd HH:mm:ss</font></p>
<p><font color=red>20180113213328  对应   yyyyMMddHHmmss</font></p>
<p><font color=red>否则会有运行时异常！</font></p>
<p>看一个例子，思考原因：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新的格式化API中，格式化后的结果都默认是String，有时我们也需要返回经过格式化的同类型对象</span></span><br><span class="line">        LocalDateTime ldt1 = LocalDateTime.now();</span><br><span class="line">        System.out.println(ldt1);</span><br><span class="line">        DateTimeFormatter dtf1 = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String temp = dtf1.format(ldt1);</span><br><span class="line">        LocalDateTime formatedDateTime = LocalDateTime.parse(temp, dtf1);</span><br><span class="line">        System.out.println(formatedDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2019-09-22T14:34:24.653</span></span><br><span class="line"><span class="comment">//2019-09-22 14:39:54</span></span><br><span class="line"><span class="comment">//2019-09-22T14:34:24</span></span><br></pre></td></tr></table></figure>

<p><font color=red><strong>记住</strong>：得到的最终结果都是类似2019-09-22T14:34:24的格式因为在输出LocalDateTime对象时，会调用其重写的toString方法，读者可以读读源码就可知道，对于LocalDateTime对象，无论是String类型的时间日期转为LocalDatetime对象，还是LocalDateTime对象转为格式化后的LocalDateTime对象，得到的最终输出都是：yyyy-MM-ddThh:mm:ss 这样的格式！</font></p>
<p><font color=red>至于为什么这样，应该是为了符合国际化吧，也正因为如此，才有了LocalDate和LocalTime，以便于开发者有更多的选择。</font></p>
<p><font color=red>但上述说法仅限于LocalDateTime对象，而如果是LocalDateTime对象格式化转为String对象是可以任意格式的，如上文自定义格式示例！<br></font></p>
<h4 id="13-long毫秒值转换为日期"><a href="#13-long毫秒值转换为日期" class="headerlink" title="13.long毫秒值转换为日期:"></a>13.long毫秒值转换为日期:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------long毫秒值转换为日期---------"</span>);</span><br><span class="line">        DateTimeFormatter df= DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String longToDateTime = df.format(LocalDateTime.ofInstant(Instant.ofEpochMilli(System.currentTimeMillis()), ZoneId.of(<span class="string">"Asia/Shanghai"</span>)));</span><br><span class="line">        System.out.println(longToDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------long毫秒值转换为日期---------</span></span><br><span class="line"><span class="comment">//2019-09-22 14:41:25</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a><strong>Base64编码</strong></h2><p>在Java8中，Base64编码已经成为Java类库的标准。</p>
<p>Java8内置了Base64编码的编码器和解码器。</p>
<p>Base64工具类提供了一套静态方法获取下面三种Base64编解码器：</p>
<ul>
<li><strong>基本：</strong>输出被映射到一组字符A-Z a-z 0-9+/，编码不添加任何行标，输出的解码仅支持A-Z a-z 0-9+/。</li>
<li><strong>URL：</strong>输出映射到一组字符A-Z a-z 0-9+_，输出时URL和文件。</li>
<li><strong>MIME：</strong>输出映射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li>
</ul>
<h3 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h3><table>
<thead>
<tr>
<th>序号</th>
<th>内嵌类   &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>static class   Base64.Decoder</strong>    该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</td>
</tr>
<tr>
<td>2</td>
<td><strong>static class   Base64.Encoder</strong>    该类实现一个编码器，使用 Base64 编码来编码字节数据。</td>
</tr>
</tbody></table>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th>序号</th>
<th>方法名   &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>static Base64.Decoder   getDecoder()</strong>      返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td>2</td>
<td>*<em>static Base64.Encoder   getEncoder() *</em>     返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td>3</td>
<td>*<em>static Base64.Decoder   getMimeDecoder() *</em>      返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td>4</td>
<td>*<em>static Base64.Encoder   getMimeEncoder() *</em>     返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td>5</td>
<td><strong>static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)</strong>       返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td>
</tr>
<tr>
<td>6</td>
<td><strong>static Base64.Decoder   getUrlDecoder()</strong>      返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
<tr>
<td>7</td>
<td><strong>static Base64.Encoder   getUrlEncoder()</strong>       返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
</tbody></table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用基本编码</span></span><br><span class="line">            String base64encodedString = Base64.getEncoder().encodeToString(<span class="string">"runoob?java8"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Base64 编码字符串 (基本) :"</span> + base64encodedString);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"原始字符串: "</span> + <span class="keyword">new</span> String(base64decodedBytes, <span class="string">"utf-8"</span>));</span><br><span class="line">            base64encodedString = Base64.getUrlEncoder().encodeToString(<span class="string">"runoob?java8"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Base64 编码字符串 (URL) :"</span> + base64encodedString);</span><br><span class="line"></span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] mimeBytes = stringBuilder.toString().getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">            String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">            System.out.println(<span class="string">"Base64 编码字符串 (MIME) :"</span> + mimeEncodedString);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(UnsupportedEncodingException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Error :"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">原始字符串: runoob?java8</span><br><span class="line">Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg&#x3D;</span><br><span class="line">Base64 编码字符串 (MIME) :M2Q4YmUxMTEtYWRkZi00NzBlLTgyZDgtN2MwNjgzOGY2NGFlOTQ3NDYyMWEtZDM4ZS00YWVhLTkz</span><br><span class="line">OTYtY2ZjMzZiMzFhNmZmOGJmOGI2OTYtMzkxZi00OTJiLWEyMTQtMjgwN2RjOGI0MTBmZWUwMGNk</span><br><span class="line">NTktY2ZiZS00MTMxLTgzODctNDRjMjFkYmZmNGM4Njg1NDc3OGItNzNlMC00ZWM4LTgxNzAtNjY3</span><br><span class="line">NTgyMGY3YzVhZWQyMmNiZGItOTIwZi00NGUzLTlkMjAtOTkzZTI1MjUwMDU5ZjdkYjg2M2UtZTJm</span><br><span class="line">YS00Y2Y2LWIwNDYtNWQ2MGRiOWQyZjFiMzJhMzYxOWQtNDE0ZS00MmRiLTk3NDgtNmM4NTczYjMx</span><br><span class="line">ZDIzNGRhOWU4NDAtNTBiMi00ZmE2LWE0M2ItZjU3MWFiNTI2NmQ2NTlmMTFmZjctYjg1NC00NmE1</span><br><span class="line">LWEzMWItYjk3MmEwZTYyNTdk</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Nashorn"><a href="#Nashorn" class="headerlink" title="Nashorn"></a><strong>Nashorn</strong></h2><p>这部分仅仅是科普一下。。。知道有这么个东西，具体细节等到后序用到时再记录。。。</p>
<p><strong>Nashorn一个JavaScript引擎。</strong></p>
<p>从JDK1.8开始，Nashorn取代Rhino(JDK1.6，JDK1.7)成为Java嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSP 292的新语言特性，其中包含在JDK7中引入的invokedynamic，将JavaScript编译成Java字节码。</p>
<p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p>
<h3 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h3><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。jjs可以提供交互式编程体验。</p>
<h3 id="Java中调用JavaScript"><a href="#Java中调用JavaScript" class="headerlink" title="Java中调用JavaScript"></a>Java中调用JavaScript</h3><p>使用ScriptEngineManager类，JavaScript代码可以在Java中执行。</p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>流式语法</tag>
        <tag>Java8</tag>
        <tag>日期类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/03/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="进程和线程的概念："><a href="#进程和线程的概念：" class="headerlink" title="进程和线程的概念："></a>进程和线程的概念：</h2><p>这不是一个复杂的概念，网上的解释有很多，引用百度到的一个解释。</p>
<p>转载自<a href="https://www.cnblogs.com/Jones-dd/p/8858995.html" target="_blank" rel="noopener">博客园</a>。</p>
<p><strong>进程：</strong>指在系统中正在运行的一个应用程序；程序一旦运行就是进程；或者更专业化来说：进程是指程序执行时的一个实例，即它是程序已经执行到课中程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。</p>
<p><strong>线程：</strong>系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。进程——资源分配的最小单位，线程——程序执行的最小单位。</p>
<h3 id="线程进程的区别体现在4个方面："><a href="#线程进程的区别体现在4个方面：" class="headerlink" title="线程进程的区别体现在4个方面："></a>线程进程的区别体现在4个方面：</h3><ol>
<li><p>因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p>
</li>
<li><p>体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。</p>
</li>
<li><p>体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p>
</li>
<li><p>体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p>
</li>
</ol>
<h3 id="什么情况下使用进程个线程："><a href="#什么情况下使用进程个线程：" class="headerlink" title="什么情况下使用进程个线程："></a>什么情况下使用进程个线程：</h3><ol>
<li><p>需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的</p>
</li>
<li><p>线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p>
</li>
<li><p>因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程</p>
</li>
<li><p>并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求</p>
</li>
<li><p>需要更稳定安全时，适合选择进程；需要速度时，选择线程更好</p>
<pre><code> 因为我的项目中需要对数据段的数据共享，可以被多个程序所修改，所以使用线程来完成此操作，无需加入复杂的通信机制，使用进程需要添加复杂的通信机制实现数据段的共享，增加了我的代码的繁琐，而且使用线程开销小，项目运行的速度快，效率高。

如果只用进程的话，虽然安全性高，但是对代码的简洁性不好，程序结构繁琐，开销比较大，还需要加入复杂的通信机制，会使得我的项目代码量大大增加，切换速度会变的很慢，执行效率降低不少。。。</code></pre></li>
</ol>
<h3 id="进程和线程的关系："><a href="#进程和线程的关系：" class="headerlink" title="进程和线程的关系："></a>进程和线程的关系：</h3><ol>
<li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。</p>
</li>
<li><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p>
</li>
<li><p>处理机分给线程，即真正在处理机上运行的是线程。</p>
</li>
<li><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p>
</li>
</ol>
<hr>
<h2 id="引子："><a href="#引子：" class="headerlink" title="引子："></a>引子：</h2><p>先看一段简单的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"MyThread的run方法在运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.run();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Main方法的循环"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果可想而知，当程序执行到myThread.run();时就会一直打印”MyThread的run方法在运行”，导致main方法中的”Main方法的循环”永远无法执行打印。</p>
<p>这种情况就是因为该程序是一个<strong>单线程程序</strong>，如果希望两个while循环中的打印语句都能够并发执行，就需要<strong>多线程。</strong></p>
<hr>
<h2 id="创建新线程和启动："><a href="#创建新线程和启动：" class="headerlink" title="创建新线程和启动："></a>创建新线程和启动：</h2><p>Java中可以通过继承Thread类重写run()方法实现多线程，Tread提供了一个start()方法，用于启动新线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"MyThread的run方法在运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();<span class="comment">//启动新线程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Main方法的循环"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，两个while循环中的字符串不断地交替打印。大概是下图这个样子：</p>
<p><img src="https://s2.ax1x.com/2019/09/24/uAzL6I.png" alt="uAzL6I.png"></p>
<p>虽然继承Thread类实现了多线程，但是这种方式有一定的局限性：因为Java只支持单继承(之前写的<a href="https://jerrymouse1998.github.io/post/java%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/">Java继承策略</a>中聊过)，一个类一旦继承了某个父类就无法再继承Thread类。</p>
<p>虽然可以通过内部类继承Thread类的方法解决这个问题，但是显然这不会是一个好的方法。于是，Java还提供了<strong>实现Runnable接口</strong>创建多线程的方法，Thread类提供了一个<strong>构造方法Thread(Runnable target)</strong>。其中，Runnable是一个接口，他只有一个run()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当通过Thread(Runnable target)构造方法创建线程对象时，只需为该方法传递一个实现了Runnable接口的实例对象，这样创建的线程将调用实现了Runnable接口的类中的run()方法作为运行代码，而不需要调用Thread类中的run()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"MyThread的run方法在运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Main方法的循环"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以实现和继承Thread类一样的效果，Runnable再应用时经常用匿名内部类的方式创建实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"MyThread的run方法在运行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);<span class="comment">//Lambda表达式创建Runnable的匿名内部类传参</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Main方法的循环"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还不会流式语法的朋友可以参考之前的文章：<a href="https://jerrymouse1998.github.io/post/java8特性一/">Java8特性(一)</a></p>
<hr>
<h2 id="继承Thread类和实现Runnable接口的区别："><a href="#继承Thread类和实现Runnable接口的区别：" class="headerlink" title="继承Thread类和实现Runnable接口的区别："></a>继承Thread类和实现Runnable接口的区别：</h2><p>还是先看个例子：假设售票厅有4个窗口可发售某日某次列车的票100张，这时100张车票可以看作是共享资源，四个售票窗口需要创建4个线程。</p>
<p>先用继承Thread类方式创建多线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Thread th = Thread.currentThread();</span><br><span class="line">                String th_name = th.getName();</span><br><span class="line">                System.out.println(th_name+<span class="string">"正在发售第"</span>+ tickets-- +<span class="string">"张票！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TicketWindow().start();</span><br><span class="line">        <span class="keyword">new</span> TicketWindow().start();</span><br><span class="line">        <span class="keyword">new</span> TicketWindow().start();</span><br><span class="line">        <span class="keyword">new</span> TicketWindow().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：Thread-0、Thread-1、Thread-2、Thread-3分别都卖了100张票，明显不符合场景要求。出现这种情况的原因是因为创建了4个TicketWindow就等于创建了四个程序，每个程序都有100张票，每个线程独立地处理各自的资源。</p>
<p>用实现Runnable接口方式创建多线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Thread th = Thread.currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line">                String th_name = th.getName();<span class="comment">//获取线程的名字</span></span><br><span class="line">                System.out.println(th_name+<span class="string">"正在发售第"</span>+ tickets-- +<span class="string">"张票！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TicketWindow ticketWindow = <span class="keyword">new</span> TicketWindow();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只创建了一个TicketWindow对象，然后创建了4个线程，每个线程都调用这个TicketWindow对象的run()方法，这样就可以确保4个线程访问的是同一个tickets变量，共享100张票。</p>
<p>通过上面这个例子，总结实现Runnable接口相对于继承Thread类来说，有如下优点：</p>
<ol>
<li>适合多个相同程序代码的线程去处理同一个资源的情况，把线程与程序代码、数据有效分离，很好地体现了面向对象的设计思想。</li>
<li>可以避免由于Java的单继承带来的局限性。</li>
</ol>
<p><strong><font color=red>事实上大部分的多线程应用都会采取实现Runnable接口的方法。</font></strong></p>
<hr>
<h2 id="线程的生命周期及状态转换："><a href="#线程的生命周期及状态转换：" class="headerlink" title="线程的生命周期及状态转换："></a>线程的生命周期及状态转换：</h2><p>在Java中，任何对象都有生命周期，线程也不例外。当Thread对象<strong>创建</strong>完成时，线程的声明周期便<strong>开始</strong>了。当<strong>run()方法</strong>中的代码正常执行完毕或者线程<strong>抛出一个未捕获的异常(Exception)或者错误(Error)</strong>时，线程的生命周期便会<strong>结束</strong>。线程整个生命周期分为5个阶段:<strong>新建状态(New)、就绪状态(Runnable)、运行状态(Running)、阻塞状态(Blocked)、和死亡状态(Terminated)</strong>。如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/09/24/uEebad.png" alt="uEebad.png"></p>
<h3 id="1-新建状态-New"><a href="#1-新建状态-New" class="headerlink" title="1.新建状态(New)"></a>1.新建状态(New)</h3><p>创建一个线程对象后，该线程对象就处于新建状态，此时它<strong>不能运行</strong>，和其他Java对象一样，仅仅由<strong>JVM为其分配了内存</strong>，没有表现出任何线程的动态特征。可以通过调用start方法进入就绪状态（runnable）.</p>
<p><font color=red>注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</font></p>
<h3 id="2-就绪状态-Runnable"><a href="#2-就绪状态-Runnable" class="headerlink" title="2.就绪状态(Runnable)"></a>2.就绪状态(Runnable)</h3><p>当线程对象调用了<strong>start()</strong>方法后，该线程就进入就绪状态。处于就绪状态的线程位于<strong>线程队列</strong>中，此时它只是<strong>具备了运行的条件</strong>，能否获得CPU的使用权并开始运行，还需要<strong>等待系统的调度</strong>。</p>
<p><font color=red>尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的。</font></p>
<p><font color=red>提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。</font></p>
<h3 id="3-运行状态-Running"><a href="#3-运行状态-Running" class="headerlink" title="3.运行状态(Running)"></a>3.运行状态(Running)</h3><p>如果处于就绪状态的线程<strong>获得CPU的使用权</strong>，并<strong>开始执行run()方法</strong>中的线程执行体，则该线程处于运行状态。一个线程启动后，他可能<strong>不会一直处于运行状态</strong>，当运行状态的线程<strong>使用完系统分配的时间</strong>后，系统就会<strong>剥夺</strong>该线程占用的CPU资源，让<strong>其他线程获得执行</strong>的机会。可以对在运行状态的线程调用<strong>yield()方法</strong>，它就会<strong>让出cpu资源</strong>，再次变为就绪状态。</p>
<p><font color=red>需要注意的是，只有处于就绪状态的线程才可能转换到运行状态。</font></p>
<h3 id="4-阻塞状态-Blocked"><a href="#4-阻塞状态-Blocked" class="headerlink" title="4.阻塞状态(Blocked)"></a>4.阻塞状态(Blocked)</h3><p>一个<strong>正在执行的线程</strong>在某些特殊情况下，如被<strong>人为挂起</strong>或<strong>执行耗时的输入/输出操作</strong>时，会<strong>让出CPU的使用权</strong>并<strong>暂时终止自己的执行</strong>，进入阻塞状态。线程进入<strong>阻塞状态后</strong>，就<strong>不能进入排队队列</strong>。只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。</p>
<p>下面列举一下线程由运行状态转换成阻塞状态的原因，以及如何从阻塞状态转换成就绪状态：</p>
<ul>
<li>当线程视图获取某个对象的同步锁时，如果该锁被其他线程所持有，则当前线程会进入阻塞状态。如果想从阻塞状态进入就绪状态必须获取到其他线程所持有的锁。</li>
<li>当线程调用了一个阻塞式IO方法时，也会使线程进入阻塞状态，如果想进入就绪状态就必须要等到这个阻塞的IO方法返回。</li>
<li>当线程调用了某个对象的wait()方法时，也会使线程进入阻塞状态，如果想进入就绪队列就需要使用notify()方法唤醒该线程。</li>
<li>当线程调用了Thread的sleep(long millis)方法时，也会使线程进入阻塞状态。这种情况下，只需要等到线程睡眠的时间到了以后，线程就会自动进入就绪状态。</li>
<li>当在一个线程中调用了另一个线程的join()方法时，会使当前线程进入阻塞状态。在这种情况下，需要等到新加入的线程运行结束后才会结束阻塞状态，进入就绪状态。</li>
</ul>
<p><font color=red>需要注意的是：<strong>线程从阻塞状态只能进入就绪状态，而不能直接进入运行状态</strong>，也就是说结束阻塞的线程需要重新进入可运行池，等待系统的调度。</font></p>
<h3 id="5-死亡状态-Terminated"><a href="#5-死亡状态-Terminated" class="headerlink" title="5.死亡状态(Terminated)"></a>5.死亡状态(Terminated)</h3><p>当线程调用stop()方法或run()方法正常执行完毕后，或者线程抛出一个未捕获的异常(Exception)、错误(Error)，线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能再转换到其他状态。</p>
<p><font color=red>线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</font></p>
<hr>
<h2 id="线程的调度："><a href="#线程的调度：" class="headerlink" title="线程的调度："></a>线程的调度：</h2><p>在计算机中，线程调度有两种模式，分别是<strong>分时调度模型</strong>和<strong>抢占式调度模型</strong>。所谓<strong>分时调度模型</strong>是指让所有的线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU的时间片。<strong>抢占式调度模型</strong>是指让可运行池中优先级高的线程优先占用CPU，而对于优先级相同的线程，随机选择一个线程使其占用CPU，当他失去了CPU的使用权后，再随机选择其他线程获取CPU的使用权。<strong>JVM默认采用抢占式调度模型</strong>，通常情况下程序员不需要去考虑它，但在某些特定需求下需要改变这种模式，由程序自己来控制CPU的调度。</p>
<h3 id="线程的优先级："><a href="#线程的优先级：" class="headerlink" title="线程的优先级："></a>线程的优先级：</h3><p>如果要对线程进行调度，最直接的方法就是设置线程的优先级。优先级越高的线程获得CPU执行的机会越大，反之，机会越小。线程的优先级有<strong>1~10的整数</strong>来表示，<strong>数字越大优先级越高</strong>。除了直接使用数字表示线程的优先级，还可以使用Thread中提供的<strong>三个静态常量</strong>表示线程的优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>程序运行时，处于就绪状态的每个线程都有自己的优先级，例如：main线程具有普通优先级。然而线程的优先级不是固定不变的，可以通过<strong>setPriority(int newPriority)</strong>方法进行设置，方法参数接受1~10整数或上述的静态常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在打印"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread minPriority = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(),<span class="string">"低优先级的线程"</span>);</span><br><span class="line">        Thread normPriority = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(),<span class="string">"中优先级的线程"</span>);</span><br><span class="line">        Thread maxPriority = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(),<span class="string">"高优先级的线程"</span>);</span><br><span class="line">        minPriority.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        normPriority.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        maxPriority.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        minPriority.start();</span><br><span class="line">        normPriority.start();</span><br><span class="line">        maxPriority.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有设置优先级，打印顺序和线程启动顺序一样。设置优先级之后，打印顺序按照线程优先级从高到低。<strong>getPriority()</strong>方法可以获取线程的优先级。</p>
<p><font color=red>需要注意：不同的操作系统对优先级的支持是不一样的，不会与Java中线程优先级一一对应。因此，再设计多线程应用程序时，其功能的实现一定不能依赖于线程的优先级，而只能讲优先级作为一种提高程序效率的手段。</font></p>
<h3 id="线程休眠："><a href="#线程休眠：" class="headerlink" title="线程休眠："></a>线程休眠：</h3><p>如果希望人为地控制线程，使正在执行的线程暂停，将CPU让给别的线程，可以使用<strong>静态方法sleep(long millis)</strong>，该方法可以是当前正在执行的线程暂停一顿时间，在指定时间内进入阻塞状态。</p>
<p>sleep(long millis)方法声明会抛出<strong>InterruptException</strong>异常，因此在调用该方法时应该捕获异常，或者声明抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">3</span>)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在打印"</span>+i);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task()).start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">3</span>)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在打印"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为两个线程存在休眠，每次一个线程休眠时，另一个线程就会获得执行，所以最后效果是main线程和thread-0线程交替执行打印。</p>
<p><font color=red>sleep()是静态方法，<strong>只能控制当前正在运行的线程休眠，而不能控制其他线程休眠</strong>。当休眠结束后,线程就会返回到就绪状态，而不是立即开始运行。</font></p>
<h3 id="线程让步："><a href="#线程让步：" class="headerlink" title="线程让步："></a>线程让步：</h3><p>如果希望正在执行的线程将CPU资源让给其他线程执行。可以使用<strong>yield()</strong>方法来实现，该方法和sleep()方法有点相似，都可以让当前运行的线程暂停。<strong><u>区别：yield()方法不会阻塞该线程，他只是将线程转换成就绪状态，让系统的调度器重新调度一次。</u></strong>当某个线程调用yield()之后，只有与当前线程优先级相同或者更高的线程才能获得执行的机会。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YieldThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"打印"</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程让步："</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> YieldThread(<span class="string">"线程A"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> YieldThread(<span class="string">"线程B"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1和t2线程优先级相同，开始是分别都有执行，当两个线程的循环遍历等于3时，就会线程让步，另一个线程就会获得执行。</p>
<h3 id="线程插队："><a href="#线程插队：" class="headerlink" title="线程插队："></a>线程插队：</h3><p>Thread类提供了一个<strong>join()</strong>方法来实现插队功能。当某个线程中调用其他线程的join()方法时，调用的线程将被阻塞，直到被join()方法加入的线程执行完成后他才会继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"打印:"</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> JoinThread(),<span class="string">"线程一"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"打印:"</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">2</span>)&#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main和线程一都有sleep()方法，应该交替执行。但是main线程中在i==2时执行了线程一的join()方法，main就会等待线程一死亡后再继续执行。</p>
<p>join()有三个重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span>      </span></span><br><span class="line"><span class="function">     当前线程等该加入该线程后面，等待该线程终止。    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span>  </span></span><br><span class="line"><span class="function">     当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)</span>   </span></span><br><span class="line"><span class="function">     等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度</span></span><br></pre></td></tr></table></figure>

<h3 id="后台-守护-线程："><a href="#后台-守护-线程：" class="headerlink" title="后台(守护)线程："></a>后台(守护)线程：</h3><p>守护线程使用的情况较少，但并非无用，举例来说，<strong>JVM的垃圾回收</strong>、<strong>内存管理</strong>等线程都是守护线程。还有就是在做数据库应用时候，使用的<strong>数据库连接池</strong>，连接池本身也包含着很多后台线程，<strong>监控连接个数</strong>、<strong>超时时间</strong>、<strong>状态</strong>等等。调用线程对象的方法<strong>setDaemon(true)</strong>，则可以将其设置为守护线程。守护线程的用途为：</p>
<ul>
<li><p>守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</p>
</li>
<li><p>Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</p>
</li>
</ul>
<p><strong>setDaemon方法的详细说明：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。    </span></span><br><span class="line"><span class="comment">//该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。</span></span><br><span class="line"><span class="comment">//这可能抛出 SecurityException（在当前线程中）。   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;<span class="comment">//on - 如果为 true，则将该线程标记为守护线程。    </span></span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color=red>如果该线程处于活动状态。抛出：IllegalThreadStateException 异常。</font></p>
</li>
<li><p><font color=red>如果当前线程无法修改该线程。在当前线程中抛出：SecurityException异常。</font></p>
</li>
</ul>
<p><font color=red><strong>注：</strong>JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台县城时候一定要注意这个问题。</font></p>
<h3 id="正确的结束线程："><a href="#正确的结束线程：" class="headerlink" title="正确的结束线程："></a>正确的结束线程：</h3><p><strong>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit</strong>这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！！！</p>
<p>想要安全有效的结束一个线程，可以使用下面的方法：</p>
<ul>
<li><p>正常执行完run方法，然后结束掉。</p>
</li>
<li><p>控制循环条件和判断条件的标识符来结束掉线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">boolean</span> next=<span class="keyword">true</span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">while</span> (next) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">10</span>)  </span><br><span class="line">                next=<span class="keyword">false</span>;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="线程同步："><a href="#线程同步：" class="headerlink" title="线程同步："></a>线程同步：</h2><p>多线程的并发执行可以提高程序的效率，但是，当多个线程去访问同一个资源时，也会引发一些安全问题。</p>
<p>最开始<strong>”继承Thread类和实现Runnable接口的区别“</strong>讲解部分举了一个售票窗口售票的例子，改为模拟四个窗口出售10张票，并在每次售票后要sleep()10毫秒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"买票："</span>+tickets--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TicketWindow ticketWindow = <span class="keyword">new</span> TicketWindow();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow,<span class="string">"窗口1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow,<span class="string">"窗口2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow,<span class="string">"窗口3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow,<span class="string">"窗口4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了预期的10号到1号的票，竟然出现了0号、-1号、-2号车票，这种现象是不应该的，因为售票中做了判断，只有票号大于0时才会售票。</p>
<p>之所以出现了0、-1、-2的情况是因为线程由延迟(sleep()模拟了线程延迟)，假如线程1(窗口1)出售1号票，对票号进行了判断后，进入while循环，在售票前通过sleep()方法让线程休眠，这时线程2(窗口2)会进行售票，因为此时的票号仍为1，因此线程2也会进入循环。同理，4个线程都会进入while循环，休眠结束之后，4个线程都会进行售票(tickets–)，这样就相当于将票号减了4次，导致出现了0、-1这样的票号。</p>
<h3 id="同步代码块："><a href="#同步代码块：" class="headerlink" title="同步代码块："></a>同步代码块：</h3><p>线程安全问题其实就是由<strong>多个线程同时处理共享资源所导致的</strong>。要想解决这样的线程安全问题，<strong>必须得保证处理共享资源的代码在任何时刻只能有一个线程访问。</strong></p>
<p>为了实现这种限制，Java中提供了同步机制。当多个线程使用同一个共享资源时，可以将处理共享资源的代码放在一个使用<strong>synchronized关键字来修饰的代码块中，</strong>这个代码块被称为同步代码块，语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="comment">//操作共享资源代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lock</strong>是一个锁对象，它是同步代码块的关键。当一个线程执行同步代码块时，其他线程将无法执行当前同步代码块，会发生阻塞，当前线程执行完同步代码块后，所有线程开始<strong>抢夺</strong>线程的执行权，抢到执行权的线程将进入同步代码块，执行其中的代码。循环往复，直到共享资源处理完毕。像是公用电话亭，只有前一个人打完电话出来后，其他的人才可以进入。</p>
<p>更改售票代码，Demo类不变，修改TicketWindow类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object lock=<span class="keyword">new</span> Object();<span class="comment">//定义任意一个对象，用作同步代码块的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"买票："</span>+tickets--);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将有关tickets变量的操作都放到同步代码块中，为了保证线程的持续执行，将代码块放在死循环中，直到tickets&lt;=0时跳出循环。这样就不再出现0和负数的情况了，运行结果往往并不是四个线程都执行了同步代码块，因为线程在获得锁对象时是随机的，运行期间有些线程始终未获得锁对象，所以未能执行同步代码块。</p>
<p><font color=red>同步代码块中的锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是唯一的。“任意”是指锁对象的类型。锁对象的创建不能放到run()方法中，这样每个线程都会创建不同的锁，每个锁都有自己的标志位，这样线程之间便不能产生同步的效果。</font></p>
<p><font color=red><strong>注：</strong>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</font></p>
<h3 id="同步方法："><a href="#同步方法：" class="headerlink" title="同步方法："></a>同步方法：</h3><p>除了将共享资源的操作放在synchronized定义的区域内，也可以在方法前使用synchronized关键字来修饰，被修饰的方法为同步方法，他能实现和同步代码块相同的功能，语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 返回值类型 方法名([参数<span class="number">1</span>，。。。])&#123;。。。&#125;</span><br></pre></td></tr></table></figure>

<p>被synchronized修饰的方法在某一时刻只允许一个线程访问，访问该方法的其他线程都会发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行该方法。</p>
<p><font color=red>由于java的每个对象都有一个<strong>内置锁</strong>，当用synchronized关键字修饰方法时，内置锁会保护整个方法。线程在调用该方法前，需要获得内置锁，否则该线程就会处于阻塞状态。</font></p>
<p><font color=red><strong>同步方法</strong>也有锁，它的锁就是<strong>当前调用该方法的对象</strong>，也就是<strong>this指向的对象</strong>。这样做的好处是：同步方法被所有线程所共享，方法所在的对象相对于所有线程来说是唯一的，从而保证了锁的唯一性。</font></p>
<p><font color=red>同步方法有时候是静态的，静态方法不需要创建对象就可以直接使用，这时<strong>静态同步方法</strong>的锁就不会是这个this，而是<strong>该方法所在的类的class对象</strong>，该对象在装载该类时自动创建，可以用类名.class获取。</font></p>
<p>使用同步方法改造售票程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                sendTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"买票："</span>+tickets--);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red> <strong>注： synchronized关键字也可以修饰静态方法，此时线程如果调用该静态方法，将会锁住整个类。</strong></font></p>
<h3 id="使用特殊域变量-volatile-实现线程同步："><a href="#使用特殊域变量-volatile-实现线程同步：" class="headerlink" title="使用特殊域变量(volatile)实现线程同步："></a>使用特殊域变量(volatile)实现线程同步：</h3><ul>
<li>volatile关键字为域变量的访问提供了一种<strong>免锁机制</strong>；</li>
<li>使用volatile修饰域相当于告诉JVM该域可能会被其他线程更新；</li>
<li>因此每次使用该域就要<strong>重新计算</strong>，而不是使用寄存器中的值；</li>
<li>volatile不会提供任何原子操作，它也<strong>不能用来修饰final类型</strong>的变量；</li>
</ul>
<p><font color=red><strong>注：</strong>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用<strong>final域</strong>，<strong>有锁保护的域</strong>和<strong>volatile域</strong>可以避免非同步的问题。</font></p>
<h3 id="使用重入锁-Lock-实现线程同步："><a href="#使用重入锁-Lock-实现线程同步：" class="headerlink" title="使用重入锁(Lock)实现线程同步："></a>使用重入锁(Lock)实现线程同步：</h3><p>在JDK5之后增加了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized修饰的方法和代码块具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock(); <span class="comment">//创建一个ReentrantLock实例</span></span><br><span class="line">lock();	<span class="comment">//获得锁</span></span><br><span class="line">unlock(); <span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注：</strong>ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用。</font></p>
<p>之前同步方法实现的售票程序，可以改为用重入锁实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//和同步代码块一样，锁的声明要在执行的代码外</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                sendTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">//抢到执行权的线程获得锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"买票："</span>+tickets--);</span><br><span class="line">            lock.unlock();<span class="comment">//每次售票后就释放锁</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程通信："><a href="#线程通信：" class="headerlink" title="线程通信："></a>线程通信：</h2><h3 id="Object类的wait-、notify-和notifyAll-实现通信："><a href="#Object类的wait-、notify-和notifyAll-实现通信：" class="headerlink" title="Object类的wait()、notify()和notifyAll()实现通信："></a>Object类的wait()、notify()和notifyAll()实现通信：</h3><p>线程执行wait()之后，就放弃了运行资格处于阻塞状态，JVM会把该线程放入等待池中。等待池中的线程不会像锁池中的线程一样自动唤醒，要等待其他线程的notify()或者notifyAll()唤醒该线程并将该线程放入锁池中。</p>
<p>wait()、notify()和notifyAll()，在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这三个方法都是Object类中的方法。</p>
<p><font color=red><strong>注:</strong>等待池中的线程被notify()或者notifyAll()方法唤醒进入到锁池，最后竞争到了锁并且进入了Running状态的话，会从wait现场恢复，执行wait()方法之后的代码。</font></p>
<h3 id="使用Condition控制线程通信："><a href="#使用Condition控制线程通信：" class="headerlink" title="使用Condition控制线程通信："></a>使用Condition控制线程通信：</h3><p>JDK5中，提供了很多线程的升级解决方案：</p>
<ol>
<li>将同步synchronized替换为显式的Lock操作；</li>
<li>将Object类中的wait()、notify()和notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取；</li>
<li>一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而JDK5之前一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。</li>
</ol>
<h3 id="使用阻塞队列控制线程通信："><a href="#使用阻塞队列控制线程通信：" class="headerlink" title="使用阻塞队列控制线程通信："></a>使用阻塞队列控制线程通信：</h3><p> BlockingQueue是一个接口，也是Queue的子接口。<strong>BlockingQueue具有一个特征：</strong>当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从BlockingQueue中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。</p>
<p><strong>BlockingQueue提供如下两个支持阻塞的方法：</strong></p>
<p>  <strong>（1）put(E e)：</strong>尝试把Eu元素放如BlockingQueue中，如果该队列的元素已满，则阻塞该线程。</p>
<p>  <strong>（2）take（）：</strong>尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。</p>
<p><strong>BlockingQueue继承了Queue接口，当然也可以使用Queue接口中的方法，这些方法归纳起来可以分为如下三组：</strong></p>
<p>  <strong>（1）</strong>在队列尾部插入元素，包括add（E e）、offer（E e）、put（E e）方法，当该队列已满时，这三个方法分别会抛出异常、返回false、阻塞队列。</p>
<p>  <strong>（2）</strong>在队列头部删除并返回删除的元素。包括remove（）、poll（）、和take（）方法，当该队列已空时，这三个方法分别会抛出异常、返回false、阻塞队列。</p>
<p>  <strong>（3）</strong>在队列头部取出但不删除元素。包括element（）和peek（）方法，当队列已空时，这两个方法分别抛出异常、返回false。</p>
<p><strong>BlockingQueue接口包含如下5个实现类：</strong></p>
<ul>
<li><strong>ArrayBlockingQueue</strong> ：基于数组实现的BlockingQueue队列。</li>
<li><strong>LinkedBlockingQueue</strong>：基于链表实现的BlockingQueue队列。</li>
<li><strong>PriorityBlockingQueue</strong>：它并不是保准的阻塞队列，该队列调用remove（）、poll（）、take（）等方法提取出元素时，并不是取出队列中存在时间最长的元素，而是队列中最小的元素。它判断元素的大小即可根据元素（实现Comparable接口）的本身大小来自然排序，也可使用Comparator进行定制排序。</li>
<li><strong>SynchronousQueue</strong>：同步队列。对该队列的存、取操作必须交替进行。</li>
<li><strong>DelayQueue</strong>：它是一个特殊的BlockingQueue，底层基于PriorityBlockingQueue实现，不过，DelayQueue要求集合元素都实现Delay接口（该接口里只有一个long getDelay（）方法），DelayQueue根据集合元素的getDalay（）方法的返回值进行排序。</li>
</ul>
<hr>
<h2 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h2><p>合理使用线程池能够带来三个好处：</p>
<ol>
<li><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性。</strong>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<p><u>具体的先不做总结，等遇到应用场景时再做记录</u>。大致产生线程池的方法有：<strong>使用Executors工厂类</strong>、<strong>使用Java8增强的ForkJoinPool</strong>等等。。</p>
<hr>
<h2 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h2><p>两个人A和B进行交易，A说：“我等你的钱到了，我再给你货！”，B说：“我等你的货到了，我再给你钱。”。。。如果不进行干预，结果肯定是无限的等下去。。。</p>
<p>例子中，A和B相当于不同的线程，钱和货相当于锁。两个线程运行时都在等待对方的锁，这样就造成了双方的停滞。这种现象就是死锁。</p>
<h3 id="死锁的四个条件："><a href="#死锁的四个条件：" class="headerlink" title="死锁的四个条件："></a>死锁的四个条件：</h3><ul>
<li>互斥条件：资源不能被共享，只能被同一个进程使用。</li>
<li>请求与保持条件：已经得到资源的进程可以申请新的资源。</li>
<li>非剥夺条件：已分配的资源不能从相应的进程中被强制剥夺。</li>
<li>循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源。</li>
</ul>
<h3 id="处理死锁的一般思路："><a href="#处理死锁的一般思路：" class="headerlink" title="处理死锁的一般思路："></a>处理死锁的一般思路：</h3><ul>
<li>忽略问题！即鸵鸟算法，当发生了什么问题时，不管他，直接跳过，无视它。</li>
<li>检测死锁并恢复。</li>
<li>资源进行动态分配。</li>
<li>破除上面的四种死锁条件之一。</li>
</ul>
<hr>
<p>编写时参考目录：<a href="https://blog.csdn.net/qq_22498277/article/details/82184419?utm_source=copy" target="_blank" rel="noopener">雪飘雪融</a>、<a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">snow_flower</a>、<a href="https://blog.csdn.net/zhaojunwei666/article/details/96433488" target="_blank" rel="noopener">程序员的买房梦</a></p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多继承问题</title>
    <url>/2020/03/15/Java%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>长期被诟病的多继承，不仅仅是Java语言所头疼的问题。多继承是一个较为复杂的设计问题，使用中很容易出现致命的问题。像Goto语句一样，利弊交织。<a id="more"></a></p>
<blockquote>
<p>很多技术伟人已经提供了多套解决方案例如：<strong>传统模式</strong>(深度优先，每个类以第一次出现的位置为准)，但是遇到菱形继承就bug了。<strong>new-style class</strong>曾应用于python2.2中，和Java使用的策略很相似仍然使用深度优先搜索、从左向右，但是每个类选择其最后一次出现的位置，解决了菱形继承的bug但是交叉继承依旧bug。 <strong>C3算法</strong>提供了一个基于层级计算的线性MRO算法，被称为C3，整体上比较合理了。 在2012年被加入了Dylan语言，2007年加入了Python2.3后来又被应用于更多的语言，虽然计算问题解决了，但是依然存在一些难以理解的问题：</p>
<p><img src="https://s2.ax1x.com/2019/08/21/mNbgw4.jpg" alt="mNbgw4.jpg"></p>
<p>引见： <a href="http://python-history.blogspot.jp/2010/06/method-resolution-order.html" target="_blank" rel="noopener">python-history</a>、<a href="https://www.zhihu.com/question/21476063" target="_blank" rel="noopener">知乎</a>、<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">python.org</a></p>
</blockquote>
<h1 id="Java编程中可选的解决方法"><a href="#Java编程中可选的解决方法" class="headerlink" title="Java编程中可选的解决方法"></a>Java编程中可选的解决方法</h1><p>原则上Java是不允许多继承的，但是在编程中依然存在一些方法来模拟实现多继承：</p>
<h3 id="多层继承"><a href="#多层继承" class="headerlink" title="多层继承"></a>多层继承</h3><p>ABCD四个类，B继承A，C继承B，D继承C，然后通过D的对象调用父类们的方法。</p>
<p>建议一般不要超过三次，缺点很明显，代码冗余，一点也不优雅。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>不写演示了，相对于多层继承，就是把ABC三个类的继承工作放到D类中，用A1、B1、C3三个内部类分别继承ABC三个类，然后写A1、B1、C1调用方法，直接new内部类对象调用其方法。</p>
<p>相对于多层继承，内部类继承的方式将所有的继承都放在一个类中，阅读性增加。但是缺点依然没有太好的改善：代码冗余，依然不够优雅。</p>
<h3 id="接口-推荐"><a href="#接口-推荐" class="headerlink" title="接口(推荐)"></a>接口(推荐)</h3><blockquote>
<p>Java的接口继承功能，<strong>既实现了静态语言的多重继承性，又避免了多重继承的数据构造的冲突和类层次的复杂性。</strong><br>但是，我们并不能说接口是解决问题的完美方案。<strong>接口也有不能共享实现的缺点。</strong><br><u>本来只是为了跨越继承层次来共享代码，现在却需要另外生成一个独立对象，而且每次方法调用都要委派给这个对象，这实在是不太合理，而且执行的效率也不高。</u></p>
<p>——《松本行弘的程序世界》</p>
<blockquote>
<p><em>松本行弘在Ruby中选择了Mix-in方案来解决多继承问题。</em></p>
</blockquote>
</blockquote>
<p>通过松本行弘的话大概明白了接口继承的部分优劣性，Java中也确实是这么做的，接口继承虽然将问题抛给了使用者大大增加了工作量，但是也切实有效的避免了很大一部分问题。<strong>有取必有舍</strong>。 </p>
<p>一个类只能extends一个父类，但可以implements多个接口。java通过使用接口的概念来取代C++中多继承。与此同时，一个接口则可以同时extends多个接口，却不能implements任何接口。因而，<strong>Java中的接口是支持多继承的。</strong> </p>
<p>接口实现多继承还有一个好处：<strong>这样可以把子类利用多态赋给多个父类（接口），而把主要的方法使用组合封装起来而避免多次实现接口的方法。</strong> </p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>多继承</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.Date和java.sql.Date区别</title>
    <url>/2020/03/15/java.util.Date%E5%92%8Cjava.sql.Date%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li><p>java.util.Date是在除了SQL语句的情况下面使用的。java.sql.Date是针对SQL语句使用的。<a id="more"></a></p>
</li>
<li><p>java.util.Date 类型写到数据库后存储的值可以到秒，java.sql.Date 类型的写入后只能到日期。</p>
</li>
<li><p>java.util.Date 是 java.sql.Date 的父类，前者是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他，后者之后在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date。</p>
</li>
</ol>
<p>直接上实验代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   </span><br><span class="line">      	java.util.Date nowUtil =newjava.util.Date();<span class="comment">// java.util.Date</span></span><br><span class="line">     	java.sql.Date nowSql=newjava.sql.Date(System.curretTimeMillis());<span class="comment">//java.sql.Date</span></span><br><span class="line">  	 	SimpleDateFormatformat=newSimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">       </span><br><span class="line">      	System.out.println(format.format(nowUtil));<span class="comment">//格式化 输出</span></span><br><span class="line">        System.out.println(format.format(nowSql));<span class="comment">//格式化 输出</span></span><br><span class="line">        System.out.println(nowUtil); <span class="comment">//直接 输出</span></span><br><span class="line">        System.out.println(nowSql);  <span class="comment">//直接 输出</span></span><br><span class="line">      </span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码输出结果：</p>
<p>2017-11-13 14:10:03<br>        2017-11-13 14:10:03<br>        Mon Nov 13 14:10:03 CST 2017<br>        2017-11-13</p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>日期类</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Maven(三)</title>
    <url>/2020/03/15/Maven%E5%86%8D%E4%BD%93%E9%AA%8C_CRUD/</url>
    <content><![CDATA[<p>前两篇文章已经介绍了Maven基本结构、功能和命令，并且搭建了最基本的SSM整合框架并调通。<a id="more"></a></p>
<hr>
<h3 id="简单的查："><a href="#简单的查：" class="headerlink" title="简单的查："></a>简单的查：</h3><p>初学者用烂的User实体类:Integer id;String username;String password;String address;(写得很啰嗦，且缺乏典型)。</p>
<p>controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"users.action"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAllUser</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    List&lt;User&gt; users = userService.findAllUser();</span><br><span class="line">    model.addAttribute(<span class="string">"users"</span>,users);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"usersList"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jsp页面：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--    用户信息表格--%&gt;</span><br><span class="line">    &lt;form method=<span class="string">"post"</span> action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/deleteByIds.action"</span>&gt;</span><br><span class="line">        &lt;table width=<span class="string">"400px"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"table table-hover table-striped text-center"</span>&gt;</span><br><span class="line">            &lt;thead&gt;&lt;h1 class="text-center"&gt;userList&lt;/h1&gt;&lt;/thead&gt;</span><br><span class="line">            &lt;tbody&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;&lt;input type="checkbox" id="changeAll" onclick="change(this)"&gt;全选&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;username&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;password&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;address&lt;/td&gt;</span><br><span class="line">                    &lt;td&gt;operate&lt;/td&gt;</span><br><span class="line">                &lt;/tr&gt;</span><br><span class="line">                &lt;c:forEach items=<span class="string">"$&#123;users&#125;"</span> <span class="keyword">var</span>=<span class="string">"user"</span>&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;td&gt;&lt;input type="checkbox" value="$&#123;user.id&#125;" name="ids"&gt;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;user.username&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;user.password&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;$&#123;user.address&#125;&lt;/td&gt;</span><br><span class="line">                        &lt;td&gt;</span><br><span class="line">                            &lt;input onclick=<span class="string">"find_user_byId($&#123;user.id&#125;)"</span> type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-primary"</span> data-toggle=<span class="string">"modal"</span> data-target=<span class="string">"#modifyModal"</span> value=<span class="string">"modify"</span>&gt;</span><br><span class="line">                            &lt;a onclick="delete_user($&#123;user.id&#125;)" class="btn-danger btn"&gt;delete&lt;/a&gt;</span><br><span class="line">                        &lt;/td&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/c:forEach&gt;</span><br><span class="line">            &lt;/tbody&gt;</span><br><span class="line">            &lt;tfoot&gt;</span><br><span class="line">                &lt;td colspan=<span class="string">"5"</span>&gt;</span><br><span class="line">                    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"删除所选项"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-danger"</span>&gt;</span><br><span class="line">                    &lt;input type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-success"</span> data-toggle=<span class="string">"modal"</span> data-target=<span class="string">"#addModal"</span> value=<span class="string">"添加新用户"</span>&gt;</span><br><span class="line">                &lt;/td&gt;</span><br><span class="line">            &lt;/tfoot&gt;</span><br><span class="line">        &lt;/table&gt;</span><br><span class="line">    &lt;/form&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="简单的删："><a href="#简单的删：" class="headerlink" title="简单的删："></a>简单的删：</h3><p>VoUser中 Integer id；List&lt;Integer&gt; ids；在mapper文件中进行空值的判断即可，分开处理。</p>
<p>controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"deleteByIds.action"</span>)</span><br><span class="line"><span class="comment">//根据前端传回的参数是id还是表单的ids自动对应属性赋值</span></span><br><span class="line">   <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">deleteByIds</span><span class="params">(VoUser user)</span></span>&#123;</span><br><span class="line">       Integer result = userService.deleteByIds(user);</span><br><span class="line">       <span class="keyword">if</span> (result!=<span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"FAIL"</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>@ResponseBody</strong>标签可以使方法的返回值通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML。</p>
<p><font color=red><strong>注意</strong>：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果类似于通过response对象输出指定格式的数据。</font></p>
<p>jsp：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//html同上</span></span><br><span class="line"><span class="comment">//多选</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">changeAll</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> checkIds = <span class="built_in">document</span>.getElementsByName(<span class="string">"ids"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;checkIds.length;i++)&#123;</span><br><span class="line">        checkIds[i].checked=changeAll.checked;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delete_user</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(confirm(<span class="string">"确定删除此用户么？"</span>,<span class="string">"确定"</span>,<span class="string">"取消"</span>))&#123;</span><br><span class="line">        $.post(<span class="string">"$&#123;pageContext.request.contextPath&#125;/deleteByIds.action"</span>,&#123;<span class="string">"id"</span>:id&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(data==<span class="string">"OK"</span>)&#123;</span><br><span class="line">                alert(<span class="string">"删除成功！"</span>);</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                alert(<span class="string">"删除失败！"</span>);</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>confirm函数:</strong>用于提供确认功能，它首先显示给定的message参数所包含的信息，并提供两个可选择的回答“ok”和“cancel”，然后等待用户选择其中的一个。如果用户选择“ok”则返回true；否则，如若选择“cancel”则返回false。该函数的语法格式如下：</li>
</ol>
<p>window.confirm (message, ok, cancel)</p>
<p>它有3个参数，其中参数message是欲显示的字符串形式的提示信息；参数ok也是用于显示的一个字符串信息，它可以是“OK”，也可以是其他表示OK意义的文本信息，如“I Agree”、“I Like”等等；同样，参数cancel也是用于显示的字符串信息，可以是“Cancel”文本，也可以是其他表示Cancel意义的文本信息。</p>
<ol start="2">
<li><p><strong>$.post()函数：</strong>通过 HTTP POST 请求从服务器载入数据。</p>
<p>函数基本语法：jQuery.post(url,data,success(data, textStatus, jqXHR),dataType)</p>
<ul>
<li>url：必需。规定把请求发送到哪个 URL。</li>
<li>data：可选。映射或字符串值(一般习惯用字符串和JSON对象)。规定连同请求发送到服务器的数据。</li>
<li>success(data, textStatus, jqXHR)：可选。请求成功时执行的回调函数。</li>
<li>dataType：可选。规定预期的服务器响应的数据类型。默认执行智能判断（xml、json、script 或 html）。</li>
</ul>
</li>
<li><p><strong>window.location.reload()函数：</strong></p>
<p>刷新页面。。。其他页面更新功能的函数：</p>
<p>windows.location.href=”/url”     当前页面打开URL页面<br>window.close();                            关闭窗口，不弹出系统提示，直接关闭　<br>window.parent.close();                是parent属性是当前窗口或框架的框架组</p>
</li>
</ol>
<hr>
<h3 id="简单的增："><a href="#简单的增：" class="headerlink" title="简单的增："></a>简单的增：</h3><p>这么拽的Maven居然不能自动管理BootStrap等优秀的前端框架！！</p>
<p>手动在webapp下创建static目录(在WEB-INF外，因为WEB-INF的东西只对服务端开放)，将BootStrap和Jquery下载后加入目录。</p>
<p>controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"addUser.action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">addUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = userService.addUser(user);</span><br><span class="line">    <span class="keyword">if</span> (row&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"FAIL"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>jsp：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--    添加用户模态框--%&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"modal fade"</span> id=<span class="string">"addModal"</span> tabindex=<span class="string">"-1"</span>  role=<span class="string">"dialog"</span> aria-labelledby=<span class="string">"addModalLabel"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"modal-content"</span>&gt;</span><br><span class="line">&lt;%--            模态框头--%&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"modal-header"</span>&gt;</span><br><span class="line">&lt;%--                右上角关闭模态框--%&gt;</span><br><span class="line">                &lt;button type=<span class="string">"button"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"close"</span> data-dismiss=<span class="string">"modal"</span> aria-label=<span class="string">"Close"</span>&gt;</span><br><span class="line">                    &lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line">                &lt;h4 class="modal-title"&gt;添加用户信息&lt;/h4&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">&lt;%--            模态框体--%&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"modal-body"</span>&gt;</span><br><span class="line">                &lt;form <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-horizontal"</span> id=<span class="string">"add_user_form"</span>&gt;</span><br><span class="line">                    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">                        &lt;label for="add_username" class="col-sm-2 control-label"&gt;用户名&lt;/label&gt;</span><br><span class="line">                        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-sm-10"</span>&gt;</span><br><span class="line">                            &lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> id=<span class="string">"add_username"</span> placeholder=<span class="string">"用户名"</span> name=<span class="string">"username"</span> /&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">                        &lt;label for="add_password" class="col-sm-2 control-label"&gt;密码&lt;/label&gt;</span><br><span class="line">                        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-sm-10"</span>&gt;</span><br><span class="line">                            &lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> id=<span class="string">"add_password"</span> placeholder=<span class="string">"密码"</span> name=<span class="string">"password"</span> /&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">                        &lt;label for="add_address" class="col-sm-2 control-label"&gt;地址&lt;/label&gt;</span><br><span class="line">                        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-sm-10"</span>&gt;</span><br><span class="line">                            &lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> id=<span class="string">"add_address"</span> placeholder=<span class="string">"地址"</span> name=<span class="string">"address"</span> /&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/div&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"modal-footer"</span>&gt;</span><br><span class="line">                &lt;button type="button" class="btn btn-danger" data-dismiss="modal"&gt;关闭&lt;/button&gt;</span><br><span class="line">                &lt;button type="button" class="btn btn-primary" onclick="addUser()"&gt;添加&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">// 创建用户信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.post(<span class="string">"$&#123;pageContext.request.contextPath&#125;/addUser.action"</span>,$(<span class="string">"#add_user_form"</span>).serialize(),<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data ==<span class="string">"OK"</span>)&#123;</span><br><span class="line">            alert(<span class="string">"用户添加成功！"</span>);</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            alert(<span class="string">"用户添加失败！"</span>);</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查的部分input标签通过data-toggle=“modal”和data-target=“模态框id”属性切换出模态框。</p>
<p><strong>serialize() 函数：</strong>通过序列化表单值，创建 URL 编码文本字符串。您可以选择一个或多个表单元素（比如 input 及/或 文本框），或者 form 元素本身。序列化的值可在生成 AJAX 请求时用于 URL 查询字符串中。</p>
<p>基本语法：$(“input或者form”).serialize()</p>
<hr>
<p>U   jsp_$.post()函数_$.ajax()函数          controller接受和返回数据</p>
<p>$.ajax()是简化的$.post()函数</p>
<p>$.ajax()函数基本语法：</p>
<h3 id="简单的改："><a href="#简单的改：" class="headerlink" title="简单的改："></a><strong>简单的改：</strong></h3><p>controller：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"findUserById.action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">User <span class="title">findUserById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    User user = userService.findUserById(id);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"modifyUser.action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">modifyUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    Integer result = userService.modifyUser(user);</span><br><span class="line">    <span class="keyword">if</span> (result!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"FAIL"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意：</strong>User findUserById(Integer id)方法使用了@ResponseBody标签，因为返回值是POJO对象，所以需要转换为JSON对象后放到response的body数据区中，需要额外jar包支持(json.jar、jackson-core.jar、jackson-annotations.jar、jackson-databind.jar 四个jar包)。</font></p>
<p>jsp：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    根据id查询用户信息，并填写到文本框中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find_user_byId</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type:<span class="string">"post"</span>,</span><br><span class="line">        url:<span class="string">"$&#123;pageContext.request.contextPath&#125;/findUserById.action"</span>,</span><br><span class="line">        data:&#123;<span class="string">"id"</span>:id&#125;,</span><br><span class="line">        success:<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">"#modify_id"</span>).val(data.id);</span><br><span class="line">            $(<span class="string">"#modify_username"</span>).val(data.username);</span><br><span class="line">            $(<span class="string">"#modify_password"</span>).val(data.password);</span><br><span class="line">            $(<span class="string">"#modify_address"</span>).val(data.address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//    修改用户</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modify_user</span>(<span class="params"></span>) </span>&#123;                   							</span><br><span class="line">  $.post(<span class="string">"$&#123;pageContext.request.contextPath&#125;/modifyUser.action"</span>,</span><br><span class="line">         $(<span class="string">"#modify_user_form"</span>).serialize(),<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (data==<span class="string">"OK"</span>)&#123;</span><br><span class="line">                alert(<span class="string">"修改成功！"</span>);</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                alert(<span class="string">"修改失败！"</span>);</span><br><span class="line">                <span class="built_in">window</span>.location.reload();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>修改的模态框和增加的模态框大同小异，只是一些标签的id和name不同罢了。</p>
<p>切换模态框按钮的同时，事件触发find_user_byId(id)方法查询目标属性并放到模态框的对应元素中。</p>
<p><strong>$.ajax()函数：</strong>简化后就是$.post()函数，上面的ajax()函数等价于下面的post()函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find_user_byId</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    $.post(<span class="string">"$&#123;pageContext.request.contextPath&#125;/findUserById.action"</span>,&#123;<span class="string">"id"</span>:id&#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        $(<span class="string">"#modify_id"</span>).val(data.id);</span><br><span class="line">        $(<span class="string">"#modify_username"</span>).val(data.username);</span><br><span class="line">        $(<span class="string">"#modify_password"</span>).val(data.password);</span><br><span class="line">        $(<span class="string">"#modify_address"</span>).val(data.address);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>当然了，天天写最简单的CRUD是远远不够的，但是这些基础还是要牢牢抓死。写这些只是为了熟悉IDEA和Maven，顺便温故而知新，虽然都是些简单的操作，但是依然遇到了不少新问题，通过解决新问题多多少少还是有所提升的。废话不多说了，继续完善多条件查询、分页、拦截器等等。。。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>初识Maven(一)</title>
    <url>/2020/03/15/Maven%E4%BB%8B%E7%BB%8D%E7%AF%87_%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%92%8C%E4%B8%80%E9%94%AE%E6%9E%84%E5%BB%BA%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>Maven最常见的项目构建和依赖管理工具<a id="more"></a></p>
<blockquote>
<p>Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具项目管理工具软件。</p>
<p>Maven 除了以程序构建能力为特色之外，还提供高级项目管理工具。由于 Maven 的缺省构建规则有较高的可重用性，所以常常用两三行 Maven 构建脚本就可以构建简单的项目。由于 Maven 的面向项目的方法，许多 Apache Jakarta 项目发文时使用 Maven，而且公司项目采用 Maven 的比例在持续增长。</p>
<p>Maven这个单词来自于意第绪语（犹太语），意为知识的积累，最初在Jakata Turbine项目中用来简化构建过程。当时有一些项目（有各自Ant build文件），仅有细微的差别，而JAR文件都由CVS来维护。于是希望有一种标准化的方式构建项目，一个清晰的方式定义项目的组成，一个容易的方式发布项目的信息，以及一种简单的方式在多个项目中共享JARs。</p>
<p>引用自百度—<a href="https://baike.baidu.com/item/Maven" target="_blank" rel="noopener">Maven</a></p>
</blockquote>
<h2 id="maven仓库种类和关系"><a href="#maven仓库种类和关系" class="headerlink" title="maven仓库种类和关系:"></a>maven仓库种类和关系:</h2><p>一般maven仓库分为：本地仓库、中央仓库、远程仓库</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niZPNn.png" alt="niZPNn.png"></p>
<h2 id="maven标准目录结构"><a href="#maven标准目录结构" class="headerlink" title="maven标准目录结构:"></a>maven标准目录结构:</h2><p><img src="https://s2.ax1x.com/2019/09/02/niZEcT.png" alt="niZEcT.png"></p>
<p><u>在使用IDEA开发时，创建Maven项目时选择骨架后，有些目录需要手动创建。</u></p>
<p><img src="https://s2.ax1x.com/2019/09/02/niMRVU.png" alt="niMRVU.png"></p>
<h2 id="常用的命令："><a href="#常用的命令：" class="headerlink" title="常用的命令："></a>常用的命令：</h2><p>maven中常用的命令有：clean(清除)、compile(编译)、test(测试)、package(打包)、install(安装)、deploy(部署)等。。。</p>
<p><img src="https://s2.ax1x.com/2019/09/02/nimJTH.png" alt="nimJTH.png"></p>
<p>每个命令都对应一个插件。在IDEA中可以直接点击运行命令。</p>
<h4 id="打开一个maven项目的目录："><a href="#打开一个maven项目的目录：" class="headerlink" title="打开一个maven项目的目录："></a>打开一个maven项目的目录：</h4><p><img src="https://s2.ax1x.com/2019/09/02/niZA3V.png" alt="niZA3V.png"></p>
<h4 id="执行clean命令和结果"><a href="#执行clean命令和结果" class="headerlink" title="执行clean命令和结果"></a>执行clean命令和结果</h4><p><img src="https://s2.ax1x.com/2019/09/02/niZQ41.png" alt="niZQ41.png"></p>
<p>目录中的target文件夹不见了。。。</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niZk90.png" alt="niZk90.png"></p>
<h4 id="执行compile命令和结果"><a href="#执行compile命令和结果" class="headerlink" title="执行compile命令和结果"></a>执行compile命令和结果</h4><p><img src="https://s2.ax1x.com/2019/09/02/niZ19x.png" alt="niZ19x.png"></p>
<p>目录中的target文件又出现了。。。</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niZMNR.png" alt="niZMNR.png"></p>
<h4 id="消失又出现的target文件夹是什么"><a href="#消失又出现的target文件夹是什么" class="headerlink" title="消失又出现的target文件夹是什么"></a>消失又出现的target文件夹是什么</h4><p>打开target目录发现classes文件夹，存放着项目源代码的字节码文件等等。</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niZeuF.png" alt="niZeuF.png"></p>
<h4 id="执行test命令和结果"><a href="#执行test命令和结果" class="headerlink" title="执行test命令和结果"></a>执行test命令和结果</h4><p><img src="https://s2.ax1x.com/2019/09/02/niZGjO.png" alt="niZGjO.png"></p>
<p>结果应该不难想象，和compile一样生成了target文件夹，但是比compile生成的target多了测试代码的字节码文件和配置。。。</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niZnHJ.png" alt="niZnHJ.png"></p>
<p>结果包含了compile生成的文件。</p>
<h4 id="执行package命令和结果"><a href="#执行package命令和结果" class="headerlink" title="执行package命令和结果"></a>执行package命令和结果</h4><p><img src="https://s2.ax1x.com/2019/09/02/niZ8gK.png" alt="niZ8gK.png"></p>
<p>顾名思义将项目打包也放在了target目录下。。。</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niZVjU.png" alt="niZVjU.png"></p>
<p>package命令包含了compile和test命令生成的文件。</p>
<p>target目录中为什么生成了war包？——因为在pom.xml中指定了</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niZKE9.png" alt="niZKE9.png"></p>
<h4 id="执行install命令和结果"><a href="#执行install命令和结果" class="headerlink" title="执行install命令和结果"></a>执行install命令和结果</h4><p><img src="https://s2.ax1x.com/2019/09/02/niZ336.png" alt="niZ336.png"></p>
<p>生成了target目录并且package命令生成的目录内容也都存在，同时将war包等文件安装到了本地仓库。。。</p>
<p><img src="https://s2.ax1x.com/2019/09/02/niKilt.png" alt="niKilt.png"></p>
<p>那么为什么有些命令会包含了其他命令的事情呢？——那就要了解一下maven的声明周期了。</p>
<h2 id="maven声明周期："><a href="#maven声明周期：" class="headerlink" title="maven声明周期："></a>maven声明周期：</h2><p>主要有、默认生命周期、clean声明周期、site声明周期，这三个生命周期之间是互相独立的，调用一个不会影响另一个。但是生命周期内部各个阶段之间却是有前后依赖关系：必须先执行前面的阶段，才可以执行下一阶段。</p>
<p>最常用的就是默认生命周期：编译→测试→打包→安装→发布（这是一个简化的便于理解的介绍）</p>
<p>当进行到后面的步骤时候，前面的步骤一定已经经历过了，例如执行打包（package）时自动会执行以下编译（compile）和测试（test）。。</p>
<h2 id="maven概念模型图："><a href="#maven概念模型图：" class="headerlink" title="maven概念模型图："></a>maven概念模型图：</h2><p><img src="https://s2.ax1x.com/2019/09/02/niZihq.png" alt="niZihq.png"></p>
<p>maven最重要的两大功能<strong>依赖管理</strong>、<strong>一键构建</strong>。</p>
<p>最重要的项目<strong>对象模型（POM）</strong>工程中的<strong>pom.xml文件</strong>，文件中主要放置的是：<strong>项目自身信息</strong>、<strong>项目运行所依赖的jar包信息</strong>，<strong>项目运行环境信息</strong>（JDK、tomcat等等）。<u>其中以来的jar包信息又独立出依赖管理模型。</u></p>
<p>任何一个jar包的坐标的基本元素：</p>
<p>&lt;dependency&gt;</p>
<pre><code>\&lt;groupId&gt;\&lt;/groupId&gt;         //公司组织的名称

\&lt;artifactId&gt;\&lt;/artifactId&gt;    //需要的jar包项目名

\&lt;version&gt;\&lt;/version&gt;          //版本号</code></pre><p>&lt;/dependency&gt;</p>
<p>任何一个环境插件的坐标的基本元素</p>
<p>&lt;plugin&gt;<br>                &lt;artifactId&gt;&lt;/artifactId&gt;</p>
<pre><code>\&lt;version\&gt;&lt;/version\&gt;</code></pre><p>&lt;/plugin&gt;</p>
<hr>
<p>当项目需要插件时可以在<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com</a>maven的中央仓库中搜索后，配置到pom.xml中去，maven会自动将配置的jar包下载到本地仓库中供项目使用。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>初识Maven(一)——调通SSM整合</title>
    <url>/2020/03/15/Maven%E5%88%9D%E4%BD%93%E9%AA%8C_%E8%B0%83%E9%80%9A%E5%9F%BA%E6%9C%AC%E7%9A%84SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>从MyEclipse转到IDEA的同时学习Maven构建项目着实令人抓狂，今天用IDEA+Maven简单地搭建一个我最熟悉的SSM框架并整体调通。中间遇到了不少问题再次记录一下。<a id="more"></a></p>
<p>搭建的过程简单记录一下：</p>
<ol>
<li>利用Maven的webapp骨架创建项目，手动补齐缺少的目录(三层架构)。</li>
<li>在pom.xml中引入项目所需依赖(JSTL、Log4j、mybatis、mysql、C3P0、Spring MVC、SpringCore、SpringContext、SpringBean等等)、还有一些maven配置(具体见第三条异常解决)。</li>
<li>加入并编写配置文件:db.properties、log4j.xml、SpringMVC.xml、mybatis-config.xml、applicationContext-dao/service.xml、web.xml。</li>
<li>简单的controller处理器用来测试。</li>
</ol>
<hr>
<h3 id="接下来进入正题："><a href="#接下来进入正题：" class="headerlink" title="接下来进入正题："></a>接下来进入正题：</h3><h3 id="一、缺少JSTLjar包报错："><a href="#一、缺少JSTLjar包报错：" class="headerlink" title="一、缺少JSTLjar包报错："></a>一、缺少JSTLjar包报错：</h3><p>这是个很简单的问题。。。报错信息：org.apache.jasper.JasperException: The absolute uri: [<a href="http://java.sun.com/jsp/jstl/core]" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core]</a> cannot be resolved in either web.xml or the jar files deployed with this application</p>
<p>报错信息很直接。。很明了。。就是因为缺少JSTLjar包，导入后解决问题。</p>
<p><font color=red>但是依然记录的一点是：jstl-1.2.jar之前的jar包需要同时引入standard.jar jar包才能使用。</font></p>
<h3 id="二、同时导入jstl1-2-jar和standard的jar包之后："><a href="#二、同时导入jstl1-2-jar和standard的jar包之后：" class="headerlink" title="二、同时导入jstl1.2.jar和standard的jar包之后："></a>二、同时导入jstl1.2.jar和standard的jar包之后：</h3><p>报错信息：javax.servlet.ServletException:java.lang.NoClassDefFoundError:javax/servlet/jsp/jstl/core/LoopTag</p>
<p>更换了jstl的jar包版本之后问题解决。（应该是两个jar包版本不匹配吧，应该是。。）<br>百度上也有说增加另外两个jar包可以解决问题（没有尝试）</p>
<h3 id="三、Invalid-bound-statement（not-found）："><a href="#三、Invalid-bound-statement（not-found）：" class="headerlink" title="三、Invalid bound statement（not found）："></a>三、Invalid bound statement（not found）：</h3><p>这是一个初学SSM框架时基本都遇到过的错误，因为粗心大意或者不熟练而导致的错误的原因有：</p>
<ol>
<li>mapper文件中的namespace没写或者写错。</li>
<li>dao接口中的方法在mapper文件中没有或者接口名和mapper文件中标签的name属性不一致。</li>
<li>spring容器配置时没有配置映射扫描或者映射扫描器的basepackage属性没有写对接口所在的包。</li>
<li>等等。。。</li>
</ol>
<p>这次Maven构建项目时遇到了语句绑定无效的错误：org.apache.ibatis.binding.BindingException: Invalid bound statement (not found):nynu.li.dao.UserDao.findAllUser</p>
<p>首先检查了上面所说的问题，排除了粗心大意不熟练所导致的错误之后，经过好一段时间的摸索和搜索。。。发现target目录的classes文件夹下没有dao包中的mapper配置文件，应该是maven项目没有扫描到dao包下的xml文件，在pom.xml中加入一下配置代码可以解决：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">      <span class="comment">&lt;!-- maven项目中src源代码下的xml等资源文件编译进classes文件夹，</span></span><br><span class="line"><span class="comment">        注意：如果没有这个，它会自动搜索resources下是否有mapper.xml文件，</span></span><br><span class="line"><span class="comment">        如果没有就会报org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.pet.mapper.PetMapper.selectByPrimaryKey--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">includes</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--将resources目录下的配置文件编译进classes文件  --&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="四、因为java和数据库时区不一致报错："><a href="#四、因为java和数据库时区不一致报错：" class="headerlink" title="四、因为java和数据库时区不一致报错："></a>四、因为java和数据库时区不一致报错：</h3><p>第一次遇到这个问题，以前没考虑过。。。</p>
<p>报错信息：Request processing failed; nested exception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.exceptions.PersistenceException:</p>
<p>​                                                               错误细节。。。吧啦吧啦。。。        </p>
<p>com.mysql.cj.exceptions.InvalidConnectionAttributeException: The server time zone value ‘    ‘ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.</p>
<p>​                                                               错误细节。。。吧啦吧啦。。。                </p>
<p><strong>在jdbc的url参数后加上serverTimezone=Asia/Shanghai</strong> 可以解决时区错误的问题。</p>
<p>也可以选择修改数据库的配置文件解决问题。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>NULL可以被转换为任意类型？</title>
    <url>/2020/03/15/NULL%E5%8F%AF%E4%BB%A5%E8%A2%AB%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BB%BB%E6%84%8F%E7%B1%BB%E5%9E%8B%EF%BC%9F/</url>
    <content><![CDATA[<p>先看一段代码<a id="more"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"testMethod()"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		((Demo1)<span class="keyword">null</span>).testMethod();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>上述代码的执行结果是</u></strong>：testMethod（）</p>
<p>原因：1.null可以被强转为任意类型。2.静态方法与类绑定，不依赖于任何实例。</p>
<hr>
<h6 id="经过上述结果，引出一些疑问和原理。。。"><a href="#经过上述结果，引出一些疑问和原理。。。" class="headerlink" title="经过上述结果，引出一些疑问和原理。。。"></a>经过上述结果，引出一些疑问和原理。。。</h6><p>先看两段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object obj=<span class="keyword">null</span>;</span><br><span class="line">		Integer temp=(Integer) obj;</span><br><span class="line">		System.out.println(temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>上述代码的执行结果是</u></strong>：null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object obj=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> temp=(Integer) obj;</span><br><span class="line">		<span class="comment">//int temp=(int) obj;	结果相同</span></span><br><span class="line">		System.out.println(temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>上述代码编译时并不报错，但是运行时报空指针异常。</u></strong></p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>对null得强转编译器并不会报错。如果把null强转给对象，运行时不会抛异常，因为对象本身可以为null；但是如果把null强转给基本类型，例如上述的int temp=（Integer）obj，会自动调用intValue()方法去赋值给基本类型，所以这时候会报错。</p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Postman接口调试工具</title>
    <url>/2020/03/15/Postman%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>Postman可以直接作为浏览器插件安装使用，也可以下载独立的应用程序。介于Postman插件版在2017年已经停止维护了，我还是果断选择学习使用app版的。<a id="more"></a></p>
<p>Postman是一个据说非常好用的接口测试和http请求的工具。</p>
<p>Postman的优点有很多：</p>
<ul>
<li>学习成本较低，易上手，有用例管理。</li>
<li>请求类型多：get、post、delete、put、patch等等。。。</li>
<li>很方便的支持请求 header 和请求参数的设置。</li>
<li>支持不同的认证机制，包括 Basic Auth，Digest Auth，OAuth 1.0，OAuth 2.0 等。</li>
<li>响应数据是自动按照语法格式高亮的，包括 HTML，JSON 和 XML。</li>
<li>支持抓包、保存历史记录、多终端同步用例。</li>
<li>支持批量运行、定时运行。</li>
<li>自带各种代码模块，支持用例的导出、导入。</li>
<li>对 web 接口测试支持友好（通过简单配置即可完成断言、上下文依赖、测试报表等）。</li>
</ul>
<p>等等。。。</p>
<hr>
<h2 id="接口请求流程"><a href="#接口请求流程" class="headerlink" title="接口请求流程"></a>接口请求流程</h2><p>先从界面开始学习，可以在设置的主题选项里设置主题，主要是白色和黑色（下图为白色，图片来自<a href="https://blog.csdn.net/fxbin123" target="_blank" rel="noopener">痴乙</a>）：</p>
<p><a href="https://imgchr.com/i/urywLT" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/05/urywLT.md.png" alt="urywLT.md.png"></a></p>
<p>当你初次使用Postman时很多模块都有醒目的Show me how的按钮、最下方也有Bootcamp，总而言之Postman为用户提供了学步式的手把手的教程(业界良心！！)。</p>
<h3 id="举例演示发起请求的流程："><a href="#举例演示发起请求的流程：" class="headerlink" title="举例演示发起请求的流程："></a><font color=red><strong>举例演示发起请求的流程：</strong></font></h3><h4 id="Get请求："><a href="#Get请求：" class="headerlink" title="Get请求："></a>Get请求：</h4><ol>
<li>本地启动一个之前的SpringBoot小Demo，选择post请求，输入URL：localhost:8080/selectUserById。</li>
<li>可以在Params选项卡中输入键值对参数，参数会自动拼接到URL后。</li>
<li>点击Send，就可以查看响应状态码、响应时间、响应大小，响应体的格式可以有多种，一般自定义接口是json格式的响应体。</li>
</ol>
<p><a href="https://imgchr.com/i/uc6n9e" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/06/uc6n9e.md.png" alt="uc6n9e.md.png"></a></p>
<h4 id="Post请求："><a href="#Post请求：" class="headerlink" title="Post请求："></a>Post请求：</h4><p>Get请求中没有介绍请求头，到了Post这里就需要特别介绍一下请求头中的Content-type与请求参数的格式之间的关联关系：</p>
<p><img src="https://s2.ax1x.com/2019/10/06/ucgio6.png" alt="ucgio6.png"></p>
<h5 id="第一种：表单提交"><a href="#第一种：表单提交" class="headerlink" title="第一种：表单提交"></a><strong>第一种：表单提交</strong></h5><p><a href="https://imgchr.com/i/uc2xbR" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/06/uc2xbR.md.png" alt="uc2xbR.md.png"></a></p>
<p><a href="https://imgchr.com/i/uc2vr9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/06/uc2vr9.md.png" alt="uc2vr9.md.png"></a></p>
<h5 id="第二种：JSON提交"><a href="#第二种：JSON提交" class="headerlink" title="第二种：JSON提交"></a><strong>第二种：JSON提交</strong></h5><p><a href="https://imgchr.com/i/ucRBzF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/06/ucRBzF.png" alt="ucRBzF.png"></a></p>
<p><a href="https://imgchr.com/i/ucR0RU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/06/ucR0RU.png" alt="ucR0RU.png"></a></p>
<h5 id="第三种：XML提交"><a href="#第三种：XML提交" class="headerlink" title="第三种：XML提交"></a><strong>第三种：XML提交</strong></h5><p>和第二种JSON提交差不多</p>
<h5 id="第四种：二进制文件提交"><a href="#第四种：二进制文件提交" class="headerlink" title="第四种：二进制文件提交"></a><strong>第四种：二进制文件提交</strong></h5><p><img src="https://s2.ax1x.com/2019/10/06/ucRbdI.png" alt="ucRbdI.png"></p>
<h5 id="其他请求PUT、DELETE等等和GET、POST差不多，就不一一举例了"><a href="#其他请求PUT、DELETE等等和GET、POST差不多，就不一一举例了" class="headerlink" title="其他请求PUT、DELETE等等和GET、POST差不多，就不一一举例了"></a>其他请求PUT、DELETE等等和GET、POST差不多，就不一一举例了</h5><hr>
<h2 id="管理用例-Collections"><a href="#管理用例-Collections" class="headerlink" title="管理用例-Collections"></a>管理用例-Collections</h2><p>接口集合，可以根据不同的项目来自定义保存接口请求集合，方便日后的测试记录。也就是将多个接口请求可以放在一起，并管理起来。一般来说：一个工程一个Collection，这样方便查找和统一处理数据。</p>
<p>之前举例时发起的请求，就被记录在了History标签栏中，并以请求发起的时间分类：</p>
<p><img src="https://s2.ax1x.com/2019/10/06/uch8MD.png" alt="uch8MD.png"></p>
<p>这样并不便于查找和管理，所以我们可以创建一个Collections：</p>
<p><img src="https://s2.ax1x.com/2019/10/06/uchTL4.png" alt="uchTL4.png"></p>
<p>创建好的Collections还可以右键添加子目录，进一步细化管理。可以创建好请求之后，点击Save保存至创建好的Collections中。</p>
<hr>
<h2 id="身份验证-Authentication"><a href="#身份验证-Authentication" class="headerlink" title="身份验证-Authentication"></a>身份验证-Authentication</h2><p>1、Basic Auth</p>
<p>是基础的验证，所以会比较简单<br>会直接把用户名、密码的信息放在请求的 Header 中</p>
<p>2、Digest Auth</p>
<p>要比Basic Auth复杂的多。使用当前填写的值生成authorization header。所以在生成header之前要确保设置的正确性。如果当前的header已经存在，postman会移除之前的header。</p>
<p>3、OAuth 1.0</p>
<p>postman的OAuth helper让你签署支持OAuth</p>
<p>1.0基于身份验证的请求。OAuth不用获取access token,你需要去API提供者获取的。OAuth 1.0可以在header或者查询参数中设置value。</p>
<p>4、OAuth 2.0</p>
<p>postman支持获得OAuth 2.0 token并添加到requests中。</p>
<hr>
<p>上述是Postman最基本最简单的部分操作，仅仅是皮毛，更多的高级操作还要自日后的学习中不断完善学习。</p>
]]></content>
      <categories>
        <category>工具环境</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ怎样保证消息不丢失？</title>
    <url>/2020/03/15/RabbitMQ%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1/</url>
    <content><![CDATA[<p>RabbitMQ的一大特色就是其自身保证消息的可靠性，那么RabbitMQ是如何保证消息的可靠性呢？<a id="more"></a></p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p>RabbitMQ的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的，如果节点重启或者意外crash掉，消息就会丢失。</p>
<p>所以就要对消息进行持久化处理，持久化的条件（缺一不可）：</p>
<ol>
<li>Exchange设置持久化：autoDelete属性表示当所有绑定队列都不在使用时，是否自动删除交换器，true删除，false不删除；durable属性（关键）表示当服务重启时交换器能否存活，true能，false不能。</li>
<li>Queue设置持久化：和Exchange设置持久化一样。</li>
<li>消息持久化发送：发送消息设置发送模式deliveryMode=2，代表消息持久化。</li>
</ol>
<hr>
<h2 id="ACK确认机制（重点）"><a href="#ACK确认机制（重点）" class="headerlink" title="ACK确认机制（重点）"></a>ACK确认机制（重点）</h2><p><font color=red>完成了上述操作，当服务重启时可以保证交换器、队列、队列中的消息被还原至重启之前的状态。但是这样并不能保障服务运行时消息不丢失，<strong>例如：autoAck=true消费者接受消息之后还没正确完成处理就抛出异常或者消费者的服务器者直接crash了，这样也算数据丢失；即使正确消息已经被正确处理，但是后序代码抛出异常，使用Spring进行管理的话消费端业务逻辑会进行回滚，这也造成了实际意义上的消息丢失</strong>。为了确保这种情况下的数据不丢失，RabbitMQ支持消息确认——ACK。</font></p>
<p><font color=###00CC00><strong>什么是ACK消息确认机制？</strong></font></p>
<p>ACK确认机制就是消费者收到消息并处理完成后要通知服务端，服务端才把消息从队列中删除：</p>
<ol>
<li>如果一个消费者在处理消息时出现了网络不稳定、服务器异常等情况，那么就不会有ACK反馈，RabbitMQ会认为这个消息没有正常消费，会将消息重新放入队列中。</li>
<li>如果在集群情况下，RabbitMQ会立刻将这个消息推送给在线的其他消费者。这种机制保证了在消费者服务端故障的时候，不丢失任何消息和任务。</li>
<li>只有当消费者正确发送ACK反馈，RabbitMQ确认收到后，消息才会从RabbitMQ服务器的数据中删除，否则消息永远不会从RabbitMQ中删除。</li>
<li>消息的ACK确认机制默认是打开的。</li>
</ol>
<p><font color=###00CC00><strong>消费者如何通知RabbitMQ消息成功消费？</strong></font></p>
<ol>
<li>消息确认模式有：<ul>
<li>AcknowledgeMode.NONE：自动确认（<strong>默认</strong>）</li>
<li>AcknowledgeMode.AUTO：根据情况确</li>
<li>AcknowledgeMode.MANUAL：手动确认</li>
</ul>
</li>
<li>消息<strong>通过ACK确认是否被正确接收</strong>，每个Message都要被确认（acknowledged），可以手动去ACK或自动ACK。</li>
<li>自动确认会在消息发送给消费者之后立刻确认，如果手动确认则当消费者调用ack，nack（否认/拒绝消息，消息重新放回队列），reject（否认/拒绝消息，消息不放回队列）几种方法进行确认，手动确认可以在业务失败后进行一些操作，如果消息未被ACK则会发送到下一个消费者。</li>
<li><strong>如果某个服务忘记ACK了，则RabbitMQ不会再发送数据给它，因为RabbitMQ认为该服务的处理能力有限。</strong></li>
<li>ACK机制还可以起到限流作用，比如在接收到某条消息时休眠几秒钟。</li>
</ol>
<p><font color=###00CC00><strong>如何进行手动消息确认？</strong></font></p>
<ol>
<li><p>在全局配置文件中设置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="string">manual</span></span><br></pre></td></tr></table></figure>

<p>或者在配置类中设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RabbitListenerContainerFactory&lt;?&gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory)&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory =<span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    factory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);             <span class="comment">//开启手动 ack</span></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后运行一个Springboot应用，service方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"nynu.news"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgAndHeader</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    System.out.println(msg.getBody());</span><br><span class="line">    System.out.println(msg.getMessageProperties());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行一个测试方法，发送一条消息到nynu.news队列中去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    点对点单播测试</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">directDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">"exchange.direct"</span>,<span class="string">"nynu.news"</span>,<span class="keyword">new</span> Shoes(<span class="number">2</span>,<span class="string">"李宁"</span>,<span class="string">"全城7"</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>运行测试方法之后，service方法接收到消息并在控制台打印出来，但是由于没有手动确认方法：</p>
<p><a href="https://imgchr.com/i/KBUI4H" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/26/KBUI4H.md.png" alt="KBUI4H.md.png"></a></p>
<p>可以看到，队列中没有准备好的可以被接收的消息，但是有一个未确认的消息。这时候停止应用来模拟抛出异常或者消费者服务器crash：</p>
<p><a href="https://imgchr.com/i/KBU5Ue" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/26/KBU5Ue.md.png" alt="KBU5Ue.md.png"></a></p>
<p>没有被确认的消息重新放回了消息队列中。</p>
</li>
<li><p>在service方法中添加确认消息语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"nynu.news"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgAndHeader</span><span class="params">(Message msg, Shoes shoes, @Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> tag, Channel channel)</span>&#123;</span><br><span class="line">        System.out.println(shoes);</span><br><span class="line">        System.out.println(msg.getBody());</span><br><span class="line">        System.out.println(msg.getMessageProperties());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.basicAck(tag,<span class="keyword">false</span>); <span class="comment">//确认消息</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的 <strong>basicAck</strong> 方法需要传递两个参数：</p>
<ul>
<li><strong>deliveryTag（唯一标识 ID）</strong>：当一个消费者向 RabbitMQ 注册后，会建立起一个 Channel ，RabbitMQ 会用 basic.deliver 方法向消费者推送消息，这个方法携带了一个 delivery tag， <strong>它代表了 RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID</strong>，是一个单调递增的正整数，delivery tag 的范围仅限于 Channel</li>
<li><strong>multiple</strong>：为了减少网络流量，手动确认可以被批处理，<strong>当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的所有消息</strong></li>
</ul>
<p>Channel类会提供了很多方法：</p>
<ol>
<li>将上述方法中确认消息换为<strong>channel.basicNack(tag,false,true);</strong>语句，运行程序消息不断地重复接受。因为Nack拒绝消息之后，消息又回到了消息队列重新被方法接受。。。第三个参数false拒绝后消息不放回消息队列，true消息放回消息队列。</li>
<li>同样的还有<strong>channel.basicReject(tag,false);</strong>语句来拒绝消息，第二个参数false拒绝后消息不放回消息队列，true消息放回消息队列。</li>
<li><strong>basicRecover(boolean requeue);</strong>方法：重新投递并没有所谓的像basicReject中的deliveryTag参数，所以重新投递好像是将消费者还没有处理的所有的消息都重新放入到队列中，而不是将某一条消息放入到队列中，与basicReject不同的是，重新投递可以指定投递的消息是否允许当前消费者消费，false：表示重新递送的消息还会被当前消费者消费，true则不会。</li>
</ol>
</li>
</ol>
<p><font color=red><strong>注意：如果忘记了ACK，那么后果很严重。当Consumer退出时，Message会一直重新分发。然后RabbitMQ会占用越来越多的内存，由于RabbitMQ会长时间运行，因此这个“内存泄漏“是致命的。</strong></font></p>
<p><font color=red><strong>解决方法:</strong></font></p>
<ol>
<li><p>使用try-catch块捕获消费者中的异常。</p>
</li>
<li><p>设置重试次数（在全局配置文件添加如下配置）：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启重试</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.enabled</span>=<span class="string">true </span></span><br><span class="line"><span class="comment">#最大重试次数</span></span><br><span class="line"><span class="meta">spring.rabbitmq.listener.simple.retry.</span> <span class="string">max-attempts=5</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><p>上述的应答方式主要都是消费者告诉消息队列已获取到消息并处理完毕。其实当生产者发布消息到RabbitMQ中，生产者需要知道是否真的已经发送到RabbitMQ中，需要RabbitMQ告诉生产者消息队列已收到消息：</p>
<ul>
<li><p><font color=red><strong>Confirm机制</strong>：</font>生产者将信道设置为confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到所匹配的队列之后，RabbitMQ就会发送一个确认给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，RabbitMQr回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号，此外RabbitMQ也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。</p>
<p><font color=red>Confirm模式最大的好处就在于它是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条basic.nack来代替basic.ack的消息，在这个情形下，basic.nack中各域值的含义与basic.ack中相应各域含义是相同的，同时requeue域的值应该被忽略。通过nack一条或多条消息， Broker表明自身无法对相应消息完成处理，并拒绝为这些消息的处理负责。在这种情况下，client可以选择将消息re-publish。</font></p>
<p><strong>channel.confirmSelect()</strong>：将当前Channel设置为Confirm模式。</p>
<p><strong>channel.waitForConfirms()</strong>：发一个或一批消息，等待确认返回一个boolean值（true发送成功，false发送失败），如果出错了会返回本次发送的所有消息。</p>
<p>客户端实现生产者confirm有三种编程方式：</p>
<ol>
<li><p>普通Confirm模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  channel.confirmSelect();</span><br><span class="line">String message = <span class="string">"Hello RabbitMQ:"</span>;</span><br><span class="line">  channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, (message + i).getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">  <span class="keyword">boolean</span> isPublished = channel.waitForConfirms();</span><br></pre></td></tr></table></figure>

<p>每发送一条消息后，调用waitForConfirms()方法，等待服务器端Confirm。实际上是一种串行Confirm了，每publish一条消息之后就等待服务端Confirm，如果服务端返回false或者超时时间内未返回，客户端进行消息重传。</p>
</li>
<li><p>批量Confirm模式，：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line">String message = <span class="string">"Hello RabbitMQ:"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, (message + i).getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">boolean</span> isAllPublished = channel.waitForConfirms();</span><br></pre></td></tr></table></figure>

<p>发送一批消息之后，调用waitForConfirms()方法，等待服务端Confirm，<font color=red>但是服务器并不是对每一条消息都进行ack，而是批量处理，如果使用wireshark等软件抓包之后可以发现在某些basic.ack数据报文中multiple的值为true，这与前面我们讲解的一致，为true时将确定所有比指定的delivery-tag参数都小的消息都得到了确认。</font>这种批量确认的模式极大的提高了Confirm效率，但是如果一旦出现Confirm返回false或者超时的情况，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息，如果这种情况频繁发生的话，效率也会不升反降。</p>
</li>
<li><p>异步Confirm模式：提供一个回调方法，服务端Confirm了一条或者多条消息后Client端会回调这个方法。</p>
<p>先看一下waitForConfirms方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">waitForConfirms</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.nextPublishSeqNo == <span class="number">0L</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Confirms not selected"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.unconfirmedSet) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">this</span>.getCloseReason() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.unconfirmedSet.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">boolean</span> aux = <span class="keyword">this</span>.onlyAcksReceived;</span><br><span class="line">                    <span class="keyword">this</span>.onlyAcksReceived = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> aux;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="number">0L</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.unconfirmedSet.wait();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">long</span> elapsed = System.currentTimeMillis() - startTime;</span><br><span class="line">                    <span class="keyword">if</span> (timeout &lt;= elapsed) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.unconfirmedSet.wait(timeout - elapsed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> (ShutdownSignalException)Utility.fixStackTrace(<span class="keyword">this</span>.getCloseReason());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在waitForConfirms()方法内部维护了一个同步块代码，而unconfirmedSet就是存储delivery-tag标识的。该方法为每一个Channel维护一个unconfirmedSet的消息序号集合，每publish一条数据，集合中元素加1，每回调一次ack方法，unconfirmedSet就删掉相应的一条（multiple=false）或多条（multiple=true）记录。从程序运行效率上看，这个unconfirmedSet集合最好采用有序集合SortedSet存储结构。而且waitForConfirmsOrDie()方法内部其实就是调用了waitForConfirms()方法。</p>
</li>
</ol>
</li>
<li><p><font color=red><strong>事务机制：</strong></font>通过AMQP事务机制实现，这也是AMQP协议层面提供的解决方案。<br><strong>channel.txSelect()</strong>：用于将当前Channel设置为Transaction模式。</p>
<p><strong>channel.txCommit()</strong>：用于提交事务。</p>
<p><strong>channel.txRollback()</strong>：用于回滚事务。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String message = <span class="string">"Hello RabbitMQ:"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.txSelect();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, ROUTING_KEY, <span class="keyword">null</span>, (message + i).getBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>注意：事务机制是非常非常非常消耗性能的，最好使用Confirm机制，Confirm机制相比事务机制性能上要好很多。</font></p>
<p><font color=red><strong>每个队列只能设置为一种模式confirm或者transaction，不能混用否则会抛异常。</strong></font></p>
<hr>
<h2 id="设置集群镜像模式"><a href="#设置集群镜像模式" class="headerlink" title="设置集群镜像模式"></a>设置集群镜像模式</h2><p>RabbitMQ常用的三种部署模式：</p>
<ol>
<li>单节点模式：最简单的情况，非集群模式，节点挂了，消息就不能用了。业务可能瘫痪，只能等待。</li>
<li>普通模式：默认的集群模式，某个节点挂了，该节点上的消息不能用，有影响的业务瘫痪，只能等待节点恢复重启可用（前提是持久化消息情况下）。</li>
<li>镜像模式：把需要的队列做成镜像队列，存在于多个节点，属于RabbitMQ的HA方案。</li>
</ol>
<p>为什么设置镜像模式集群，因为队列的内容仅仅存在某一个节点上面，不会存在所有节点上面，所有节点仅仅存放消息结构和元数据。下面自己画了一张图介绍普通集群丢失消息情况：</p>
<p><img src="https://s2.ax1x.com/2019/10/24/KUJvEq.png" alt="KUJvEq.png"></p>
<p>如果想解决上面途中问题，保证消息不丢失，需要采用HA 镜像模式队列。</p>
<p><strong>下面介绍下三种HA策略模式：</strong></p>
<ol>
<li>同步至所有的</li>
<li>同步最多N个机器</li>
<li>只同步至符合指定名称的nodes</li>
</ol>
<p><em>命令处理HA策略模版：rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]</em></p>
<ol>
<li>为每个以“rock.wechat”开头的队列设置所有节点的镜像，并且设置为自动同步模式<br>rabbitmqctl set_policy ha-all “^rock.wechat” ‘{“ha-mode”:”all”,”ha-sync-mode”:”automatic”}’<br>rabbitmqctl set_policy -p rock ha-all “^rock.wechat” ‘{“ha-mode”:”all”,”ha-sync-mode”:”automatic”}’</li>
<li>为每个以“rock.wechat.”开头的队列设置两个节点的镜像，并且设置为自动同步模式<br>rabbitmqctl set_policy -p rock ha-exacly “^rock.wechat” <br>‘{“ha-mode”:”exactly”,”ha-params”:2,”ha-sync-mode”:”automatic”}’</li>
<li>为每个以“node.”开头的队列分配指定的节点做镜像<br>rabbitmqctl set_policy ha-nodes “^nodes.“ <br>‘{“ha-mode”:”nodes”,”ha-params”:[“rabbit@nodeA”, “rabbit@nodeB”]}’</li>
</ol>
<p>但是：HA 镜像队列有一个很大的缺点就是：   <strong>系统的吞吐量会有所下降</strong></p>
<hr>
<h2 id="消息补偿机制"><a href="#消息补偿机制" class="headerlink" title="消息补偿机制"></a>消息补偿机制</h2><p>为什么还要消息补偿机制呢？难道消息还会丢失，没错，系统是在一个复杂的环境，不要想的太简单了，虽然以上的三种方案，基本可以保证消息的高可用不丢失的问题，</p>
<p>但是作为有追求的程序员来讲，要绝对保证我的系统的稳定性，有一种危机意识。</p>
<p>比如：持久化的消息，保存到硬盘过程中，当前队列节点挂了，存储节点硬盘又坏了，消息丢了，怎么办？</p>
<p>产线网络环境太复杂，所以不知数太多，消息补偿机制需要建立在消息要写入DB日志，发送日志，接受日志，两者的状态必须记录。</p>
<p>然后根据DB日志记录check 消息发送消费是否成功，不成功，进行消息补偿措施，重新发送消息处理。</p>
<p><img src="https://s2.ax1x.com/2019/10/24/KUYbi6.png" alt="KUYbi6.png"></p>
<hr>
<p>菜鸟博主只是主要学习了前两种方法。后两种作为拔高，待羽翼丰满之后在做深入学习，先搬运<a href="https://www.cnblogs.com/flyrock/>" target="_blank" rel="noopener">flyrock</a>的博客中的内容作为记录了解混个“耳熟”。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Redis</title>
    <url>/2020/03/15/Redis%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h1 id="NoSQL的诞生"><a href="#NoSQL的诞生" class="headerlink" title="NoSQL的诞生"></a>NoSQL的诞生</h1><p>在90年代，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。在那个时候，更多的都是静态网页，动态交互类型的网站不多。<a id="more"></a></p>
<p><img src="https://s2.ax1x.com/2019/10/07/u2fDEj.png" alt="u2fDEj.png"></p>
<p>上述这种架构下，数据库存在哪些瓶颈呢？</p>
<p>DAL : Data Access Layer（数据访问层 – Hibernate，MyBatis）</p>
<ol>
<li>数据量的总大小一个机器放不下时。</li>
<li>数据的索引（B+ Tree）一个机器的内存放不下时。</li>
<li>访问量(读写混合)一个实例不能承受。</li>
<li>如果满足了上述1 or 3个时，只能对数据库的整体架构进行重构。</li>
</ol>
<p>随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，出现了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。经过了一段时间技术进步NoSQL的概念被提出了。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
<p>NoSQL最常见的解释是“non-relational”， “Not Only SQL”也被很多人接受。NoSQL仅仅是一个<strong>概念</strong>，泛指非关系型的数据库，区别于关系数据库，<u><strong>它们不保证关系数据的ACID特性</strong></u>。NoSQL是一项全新的数据库革命性运动，其拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。</p>
<p>NoSQL有如下优点：<strong><u>易扩展</u></strong>，NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。无形之间也在架构的层面上带来了可扩展的能力。<strong><u>大数据量，高性能</u></strong>，NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。</p>
<p>NoSQL主要分为：<strong>键值数据库</strong>、<strong>列族数据库</strong>、<strong>文档数据库</strong>、<strong>图数据库</strong>，其部分代表作及简介如下所示：</p>
<p><img src="https://s2.ax1x.com/2019/10/07/u2fYCt.png" alt="u2fYCt.png"></p>
<hr>
<h1 id="正文-Redis初体验"><a href="#正文-Redis初体验" class="headerlink" title="正文-Redis初体验"></a>正文-Redis初体验</h1><p>Redis（全称：Remote Dictionary Server 远程字典服务）是一个高性能的key-value数据库。是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、键值数据库，并提供多种语言的API。</p>
<p>Redis是一个简单的，高效的，分布式的，基于内存的缓存工具。架设好服务器后，通过网络连接（类似数据库），提供Key－Value式缓存服务。简单，是Redis突出的特色。  简单可以保证核心功能的稳定和优异。</p>
<h2 id="Redis-与其他-key-value-缓存产品相比有以下三个特点："><a href="#Redis-与其他-key-value-缓存产品相比有以下三个特点：" class="headerlink" title="Redis 与其他 key - value 缓存产品相比有以下三个特点："></a>Redis 与其他 key - value 缓存产品相比有以下三个特点：</h2><ul>
<li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>
<li>Redis支持数据的备份，集群等高可用功能。</li>
</ul>
<p>特点:</p>
<ul>
<li>性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。</li>
<li>丰富的数据类型 – Redis支持的类型 String, List, Hash, Set 及 Ordered Set 数据类型操作。</li>
<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>
<li>丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li>
</ul>
<h2 id="Redis总结："><a href="#Redis总结：" class="headerlink" title="Redis总结："></a>Redis总结：</h2><ul>
<li><strong>Redis单个key 存入512M大小。</strong></li>
<li><strong>Redis支持多种类型的数据结构(string,list,hash.set.zset)。</strong></li>
<li><strong>Redis 是单线程   原子性。</strong></li>
<li><strong>Redis可以持久化  因为使用了 RDB和AOF机制。</strong></li>
<li><strong>Redis支持集群   而且redis 支持库(0-15) 16个库。</strong></li>
<li><strong>Redis 还可以做消息队列。</strong></li>
</ul>
<p>企业级开发中:Redis可以用作数据库、缓存(热点数据，经常会被查询，但是不经常被修改或者删除的数据)和消息中间件等大部分功能。</p>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>持久化，Redis直接将数据存储到内存中，要将数据保存到磁盘上，Redis可以使用<u><strong>两种方式实现持久化</strong></u>过程。<strong>定时快照（snapshot）</strong>：每隔一段时间将整个数据库写到磁盘上，每次均是写全部数据，代价非常高。第二种方式基于<strong>语句追加（aof）</strong>：只追踪变化的数据，但是追加的log可能过大，同时所有的操作均重新执行一遍，回复速度慢。  </li>
<li>耗内存，占用内存过高。 </li>
</ul>
<h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p><a href="https://blog.csdn.net/java_peak_zlf/article/details/84062584" target="_blank" rel="noopener">Windows下解压版Redis</a></p>
<p><a href="https://www.runoob.com/note/36178" target="_blank" rel="noopener">Windows下安装版Redis</a></p>
<p>可以安装一个图形管理软件，我用的是RedisDesktopManager9.3</p>
<h2 id="redis-conf配置文件参数："><a href="#redis-conf配置文件参数：" class="headerlink" title="redis.conf配置文件参数："></a>redis.conf配置文件参数：</h2><p>redis.conf 配置项说明如下：</p>
<ol>
<li><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</p>
<p> <strong>daemonize no</strong></p>
</li>
<li><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</p>
<p> <strong>pidfile /var/run/redis.pid</strong></p>
</li>
<li><p><strong>指定Redis监听端口，默认端口为6379，</strong>为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p>
<p> <strong>port 6379</strong></p>
</li>
<li><p>绑定的主机地址</p>
<p> <strong>bind 127.0.0.1</strong></p>
</li>
<li><p>当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能</p>
<p> <strong>timeout 300</strong></p>
</li>
<li><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>
<p> <strong>loglevel verbose</strong></p>
</li>
<li><p>日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p>
<p> <strong>logfile stdout</strong></p>
</li>
<li><p>设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id</p>
<p> <strong>databases 16</strong></p>
</li>
<li><p>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</p>
<p> <strong>save &lt;seconds&gt; &lt;changes&gt;</strong></p>
<p> <strong>Redis默认配置文件中提供了三个条件：</strong></p>
<p> <strong>save 900 1</strong></p>
<p> <strong>save 300 10</strong></p>
<p> <strong>save 60 10000</strong></p>
<p> 分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。</p>
</li>
<li><p>指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p>
<p><strong>rdbcompression yes</strong></p>
</li>
<li><p>指定本地数据库文件名，默认值为dump.rdb</p>
<p><strong>dbfilename dump.rdb</strong></p>
</li>
<li><p>指定本地数据库存放目录</p>
<p><strong>dir ./</strong></p>
</li>
<li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>
<p><strong>slaveof &lt;masterip&gt; &lt;masterport&gt;</strong></p>
</li>
<li><p>当master服务设置了密码保护时，slav服务连接master的密码</p>
<p><strong>masterauth &lt;master-password&gt;</strong></p>
</li>
<li><p>设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，默认关闭</p>
<p><strong>requirepass foobared</strong></p>
</li>
<li><p>设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p>
<p><strong>maxclients 128</strong></p>
</li>
<li><p>指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p>
<p><strong>maxmemory &lt;bytes&gt;</strong></p>
</li>
<li><p>指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p>
<p><strong>appendonly no</strong></p>
</li>
<li><p>指定更新日志文件名，默认为appendonly.aof</p>
<p> <strong>appendfilename appendonly.aof</strong></p>
</li>
<li><p>指定更新日志条件，共有3个可选值：     </p>
<p> <strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）      </p>
<p><strong>always</strong>：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）     </p>
<p> <strong>everysec</strong>：表示每秒同步一次（折中，默认值）</p>
<p><strong>appendfsync everysec</strong></p>
</li>
<li><p>指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）</p>
<p> <strong>vm-enabled no</strong></p>
</li>
<li><p>虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享</p>
<p> <strong>vm-swap-file /tmp/redis.swap</strong></p>
</li>
<li><p>将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p>
<p> <strong>vm-max-memory 0</strong></p>
</li>
<li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>
<p> <strong>vm-page-size 32</strong></p>
</li>
<li><p>设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p>
<p> <strong>vm-pages 134217728</strong></p>
</li>
<li><p>设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p>
<p> <strong>vm-max-threads 4</strong></p>
</li>
<li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>
<p><strong>glueoutputbuf yes</strong></p>
</li>
<li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>
<p><strong>hash-max-zipmap-entries 64</strong></p>
<p><strong>hash-max-zipmap-value 512</strong></p>
</li>
<li><p>指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p>
<p><strong>activerehashing yes</strong></p>
</li>
<li><p>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p>
<p><strong>include /path/to/local.conf</strong></p>
</li>
</ol>
<h2 id="Java连接Redis"><a href="#Java连接Redis" class="headerlink" title="Java连接Redis:"></a>Java连接Redis:</h2><p>就像是Java连接MySQL数据库一样，需要在pom文件中加入jedis依赖，创建jedis对象进行读写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        1.获取连接对象</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//        2.获得数据</span></span><br><span class="line">        String zqc = jedis.get(<span class="string">"zqc"</span>);</span><br><span class="line">        System.out.println(zqc);</span><br><span class="line"><span class="comment">//        3.设置数据</span></span><br><span class="line">        String rt=jedis.set(<span class="string">"username"</span>,<span class="string">"jerrymouse1998"</span>);</span><br><span class="line">        System.out.println(rt);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">"username"</span>));</span><br><span class="line"><span class="comment">//        4.释放资源</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="comment">//OK</span></span><br><span class="line"><span class="comment">//jerrymouse1998</span></span><br></pre></td></tr></table></figure>

<p>运行上面的代码之后：</p>
<p><a href="https://imgchr.com/i/uRcxu4" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/07/uRcxu4.md.png" alt="uRcxu4.md.png"></a></p>
<p>还有一种常用的方法是创建连接池对象，从连接池获取连接资源，再进行读写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//        1.连接池配置对象</span></span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"><span class="comment">//        1.1设置最大空闲连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//        1.2设置最大连接数</span></span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//        2.获得连接池</span></span><br><span class="line">        JedisPool jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig,<span class="string">"127.0.0.1"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//        3.获得连接资源</span></span><br><span class="line">        Jedis jedis=jedisPool.getResource();</span><br><span class="line"><span class="comment">//        4.设置数据</span></span><br><span class="line">        jedis.set(<span class="string">"username2"</span>,<span class="string">"zqc"</span>);</span><br><span class="line">        System.out.println(jedis.get(<span class="string">"username2"</span>));</span><br><span class="line"><span class="comment">//        5.释放资源</span></span><br><span class="line">        jedis.close();</span><br><span class="line">        jedisPool.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redis的数据结构："><a href="#Redis的数据结构：" class="headerlink" title="Redis的数据结构："></a>Redis的数据结构：</h3><p>redis一共有五种数据结构：字符串(String)、哈希(hash)、字符串列表(list)、字符串集合(set)和有序字符串集合(sorted set)。</p>
<p>key的要求：key不要太长，超过1024个字节，也不要使用太短的key。</p>
<h4 id="字符串-String-："><a href="#字符串-String-：" class="headerlink" title="字符串(String)："></a>字符串(String)：</h4><p>redis中最基础也是最重要的数据类型。在redis里是二进制安全的，意味着该数据存入和获取的数据相同。字符串类型的value值最大长度是512M。</p>
<p>字符串类型实际上可以是简单的字符串、复杂的字符串（xml、json）、数字（整数、浮点数）、二进制（图片、音频、视频）。</p>
<p>其中存用<strong>set</strong>，取用<strong>get</strong>，删用<strong>del</strong>，先取再改用<strong>getset</strong>，数值增减(增用<strong>incr</strong>，减用<strong>decr</strong>)还有关于原子性增减<strong>incrby</strong>和<strong>decrby</strong>，以及追加字符串。</p>
<p>incr key 可以将指定的key的value原子性的递增1，如果该key不存在，期初值为0，在incr之后其值为1。如果value的值不能转成整形，该操作会执行失败并返回错误信息。(decr同理)</p>
<h4 id="哈希-hash-："><a href="#哈希-hash-：" class="headerlink" title="哈希(hash)："></a>哈希(hash)：</h4><p>Hash类型类似于Java中的map容器，用于存储值对象的信息。如果Hash包含很少的字段，该类型也会占用很少的磁盘空间。每个Hash可以存储4294967295个键值对。结构如下图：</p>
<p><img src="https://s2.ax1x.com/2019/10/08/uWqkLR.png" alt="uWqkLR.png"></p>
<p>该类型存用<strong>hset</strong>，取用<strong>hget</strong>，存多个用<strong>hmset</strong>，取多个用<strong>hmget</strong>，取所有用<strong>hgetall</strong>，<strong>hdel</strong>可以删除一个或多个字段(返回值是被删除的字段个数)，<strong>del</strong>可以删除整个key，<strong>hincrby</strong>可以设置key中的filed的值增加量。</p>
<h4 id="字符串列表-list-："><a href="#字符串列表-list-：" class="headerlink" title="字符串列表(list)："></a>字符串列表(list)：</h4><p>在Redis中，它的底层实际上是一个<strong>双向链表</strong>。List类型是<strong><u>按插入顺序排序</u></strong>的字符串链表。和数据结构中普通的链表一样，我们可以在其头部(Left)和尾部(right)添加新的元素。在插入时，如果该key并不存在，Redis将为该key创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该key也将会被从数据库中删除。list中可以包含的最大元素数量是4294967295。</p>
<p>从元素插入和删除的效率视角来看，如果我们是在链表的两头插入或删除元素，这是非常高效的操作，即使链表中已经存储了百万条记录，该操作也可以在常量时间内完成。但是随着元素增多，访问中间数据的速度会变慢。</p>
<p><img src="https://s2.ax1x.com/2019/10/08/ufc1BQ.png" alt="ufc1BQ.png"></p>
<p><strong>lpush key value1 value2。。。</strong>在指定的key所关联的头部插入所有values，如果key不存在，该命令在插入之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。</p>
<p><strong>rpush key value1 value2。。。</strong>在该list的尾部添加元素</p>
<p><strong>lrange key start end</strong>    获取链表中从start到end的元素的值，<u>start和end可以为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，以此类推。。。</u></p>
<p><strong>lpushx key value</strong>    仅当参数中指定的key存在时（如果key管理的list中没有值时，则该key是不存在的）在指定的key所关联的list的头部插入value。</p>
<p><strong>rpushx key value</strong>    仅当指定的key存在时，在尾部插入元素。</p>
<p><strong>lpop key</strong>    返回并弹出指定的key关联的链表中的第一个元素（头部元素）。</p>
<p><strong>rpop key</strong>    从尾部弹出元素。</p>
<p><strong>rpoplpush resource destination</strong>    将链表中尾部的元素弹出并添加到头部。</p>
<p><strong>llen key</strong>    返回指定的key关联的链表中的元素的数量。</p>
<p><strong>lset key index value</strong>    设置链表中的index下标的元素值，0代表链表头元素，-1代表链表的尾元素。</p>
<p><strong>lrem key count value</strong>    删除count个值为value的元素，如果count大于0，从头向尾遍历并删除count个值为value的元素，如果count小于0，则从尾向头遍历并删除。如果count等于0，则删除链表中所有等于value的元素。</p>
<p><strong>linsert key before|after pivot value</strong>    在pivot元素前或者后插入value这个元素。</p>
<p><font color=red><strong>rpoplpush的使用场景：</strong></font></p>
<p>Redis<strong>链表</strong>经常会被用于<strong>消息队列</strong>的服务，已完成多程序之间的消息交换。假设一个应用程序正在执行<strong>LPUSH</strong>操作向链表中添加新的元素，我们通常将这样的程序称之为<strong>“生产者(Producer)”</strong>，而另外一个应用程序正在执行<strong>RPOP</strong>操作从链表中取出元素，我们称这样的程序为<strong>“消费者(Consumer)”</strong>。如果此时，消费者程序在取出消息元素后立刻崩溃，由于该消息已经被取出且没有被正常处理，那么我们就可以认为该<strong>消息已经丢失</strong>，由此可能会导致业务数据丢失，或业务状态的不一致等现象的发生。然而通过使用<strong>RPOPLPUSH</strong>命令，消费者程序在从<strong>主消息队列</strong>中取出消息之后再将其插入到<strong>备份队列</strong>中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。同时我们还可以提供一个<strong>守护线程</strong>，当发现备份队列中的<strong>消息过期</strong>时，可以重新将其再放回到<strong>主消息队列</strong>中，以便其它的消费者程序继续处理。</p>
<p><img src="https://s2.ax1x.com/2019/10/08/uhlFMT.png" alt="uhlFMT.png"></p>
<h4 id="字符串集合-set-："><a href="#字符串集合-set-：" class="headerlink" title="字符串集合(set)："></a>字符串集合(set)：</h4><p>在Redis中，我们可以将Set类型看作为<strong>无序</strong>的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间是常量时间。Set可包含的最大元素数是4294967295。</p>
<p>和List类型不同的是：<font color=red>Set集合中不允许出现重复的元素。</font>和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Set之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销。</p>
<p><img src="https://s2.ax1x.com/2019/10/08/uh3yPs.png" alt="uh3yPs.png"></p>
<p><strong>sadd key value1 value2。。。</strong>    向set中添加数据，如果该key的值已有则不会重复添加。</p>
<p><strong>smembers key</strong>    获取set中所有的成员。</p>
<p><strong>scard key</strong>    获取set中成员的数量。</p>
<p><strong>sismember key member</strong>    判断member是否在该set中，1表示存在、0表示不存在或者key本身就不存在。</p>
<p><strong>srem key member1 member2</strong>    删除set中指定的成员。</p>
<p><strong>srandmember key</strong>    随机返回set中的一个成员。</p>
<p><strong>sdiff key1 key2</strong>    返回key1和key2中相差的成员，而且与key的顺序有关。即返回差集（key1- key2）。</p>
<p><strong>sdiffstore destination key1 key2</strong>    将key1和key2相差的成员存储在destination上。</p>
<p><strong>sinter key1 key2</strong>    返回key1和key2的交集。</p>
<p><strong>sinterstore destination key1 key2</strong>    将返回的交集存储在destination上。</p>
<p><strong>sunion key1 key2</strong>     返回key1和key2的并集。</p>
<p><strong>sunionstore destination key1 key2</strong>    将返回的并集存储在destination上。</p>
<h4 id="有序字符串集合-sorted-set-："><a href="#有序字符串集合-sorted-set-：" class="headerlink" title="有序字符串集合(sorted set)："></a>有序字符串集合(sorted set)：</h4><p>sorted-set和set类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个set中。它们之间的主要差别是sorted-set中的每一个成员都会有一个分数(score)与之关联，Redis正是<strong><u>通过分数来为集合中的成员进行从小到大排序</u></strong>。然而需要额外指出的是：尽管sorted-set中的成员必须是唯一的，但是分数(score)却是可以重复的。</p>
<p><strong><u>有序集合使用散列表实现</u></strong>，相较于列表类型来说有序集合更耗内存，但是在sorted-set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于sorted-set中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。</p>
<p>例如：游戏排名、微博热点话题等使用场景。</p>
<p><strong>zadd key score1 member1 score2 member2。。。</strong>    将所有成员以及该成员的分数存放到sorted-set中。</p>
<p><strong>zcard key</strong>    获取集合中的成员数量。</p>
<p><strong>zcount key min max</strong>    获取分数在[min，max]之间的成员数量。</p>
<p><strong>zincrby key increment member</strong>    增加指定成员的分数。</p>
<p><strong>zrange key start end [withscores]</strong>    获取集合中下标为start至end的成员，[withscores]参数表明返回的成员包含其分数。</p>
<p><strong>zrangebyscore key min max [withscores] [limit offset count]</strong>    返回分数在[min，max]的成员并按照分数从低到高排序。[withscores]显示分数，[limit offset count]offset表示从下标为offset的元素开始并返回count个成员。</p>
<p><strong>zrank key member</strong>    返回成员在集合中的位置。</p>
<p><strong>zrem key member1 member2 。。。</strong>    移除集合中指定的成员。</p>
<p><strong>zscores key meber</strong>    返回指定成员的分数。</p>
<h4 id="键（key）的相关操作："><a href="#键（key）的相关操作：" class="headerlink" title="键（key）的相关操作："></a>键（key）的相关操作：</h4><p><strong>keys *</strong>    获取所有key。</p>
<p><strong>exists key</strong>    判断key是否存在，1表示存在，0表示不存在。</p>
<p><strong>move key db</strong>    将当前数据库key移动到给定数据库中。</p>
<p><strong>expire key 秒钟</strong>    为给定的key设置过期时间。</p>
<p><strong>ttl key</strong>    查看还有多少秒过期，-1表示永不过期，-2表示已过期，即已被删除。</p>
<p><strong>type key</strong>    查看key是什么类型的。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>初识SpringBoot</title>
    <url>/2020/03/15/SpringBoot%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Spring是一个轻量级的框架，但是它的配置还不够轻量化等新问题，为了解决一系列的问题可以使用SpringBoot！！<a id="more"></a></p>
<p>学习SpringBoot前需要会用一个java集成开发工具(Eclipse、MyEclipse、IDEA),对Spring框架有一定了解和使用经验，会使用Maven进行项目构建和依赖管理。</p>
<blockquote>
<p>Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。</p>
<p>来自——[百度百科](<a href="https://baike.baidu.com/item/Spring" target="_blank" rel="noopener">https://baike.baidu.com/item/Spring</a> Boot/20249767?fr=aladdin)</p>
</blockquote>
<p>SpringBoot并不算是一个严格意义上的新框架，它是对Spring框架的二次整合。摒弃了大量Spring框架的冗杂的配置信息，并且内置了Tomcat使得部署也更加方便。虽然二次整合也带来了bug调试变得更加复杂和依赖版本冲突等问题，但是依然不能掩盖SpringBoot的强大和便捷性！</p>
<p><strong>SpringBoot所具备的特征有</strong>：</p>
<p>（1）可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；</p>
<p>（2）内嵌Tomcat或Jetty等Servlet容器；</p>
<p>（3）提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置；</p>
<p>（4）尽可能自动配置Spring容器；</p>
<p>（5）提供准备好的特性，如指标、健康检查和外部化配置；</p>
<p>（6）绝对没有代码生成，不需要XML配置。</p>
<hr>
<h3 id="启动一个最简单的SpringBoot——HolleWorld！"><a href="#启动一个最简单的SpringBoot——HolleWorld！" class="headerlink" title="启动一个最简单的SpringBoot——HolleWorld！"></a>启动一个最简单的SpringBoot——HolleWorld！</h3><p>开发环境：JDK1.8(SpringBoot官方推荐使用JDK1.7以上版本，最好使用JDK1.8尤其是Spring5版本)</p>
<p>MySQL+IDEA2019+SpringBoot+Maven(SpringBoot1.4.4版本需要Maven3.2+版本)</p>
<h4 id="1-pom-xml导入项目依赖"><a href="#1-pom-xml导入项目依赖" class="headerlink" title="1.pom.xml导入项目依赖"></a>1.pom.xml导入项目依赖</h4>   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-web --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-编写一个主程序"><a href="#2-编写一个主程序" class="headerlink" title="2.编写一个主程序"></a>2.编写一个主程序</h4>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//来标注一个主程序类，标识这是一个SpringBoot应用</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(ApplicationMain<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@SrpingBootApplication是SpringBoot的核心注解，它是一个复合注解，来看源码：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">   。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   除了几个JDK提供的注解，最重要的是：@SpringBootConfiguration@EnableAutoConfiguration</p>
<p>   @ComponentScan这三个注解，可以使用这三个注解替换@SpringBootApplication，但显然一个注解更加优雅！解释一下这三个直接：</p>
<p>   <strong>@SpringBootConfiguration</strong>：和@Configuration作用相同，标识被注解的类是一个IoC容器的配置类。</p>
<p>   <strong>@EnableAutoConfiguration</strong>：用于将所有符合自动配置的Bean加载到当前SpringBoot创建并使用的IoC容器中。</p>
<p>   <strong>@ComponentScan</strong>：用于自动扫描和加载符合条件的组件或Bean，并将Bean加载到IoC容器中。</p>
<h4 id="3-编写Controller"><a href="#3-编写Controller" class="headerlink" title="3.编写Controller"></a>3.编写Controller</h4><p>SpringBoot中提供了一个@RestController注解，相当于@Controller+@ResponseBody，但是使用此注解之后视图解析器就会失效，返回的是return的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HellowordController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/HelloWorld.action"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-直接启动main方法"><a href="#4-直接启动main方法" class="headerlink" title="4.直接启动main方法"></a>4.直接启动main方法</h4><p>   一个大大的Spring的logo，日志信息里发现：2019-09-08 17:11:50.096  INFO 13320 — [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ‘’</p>
<p>   表示tomcat在8080端口已经启动了！！在浏览器请求一下localhost:8080\HelloWorld.action和预期结果一致。</p>
<h4 id="5-打包部署项目"><a href="#5-打包部署项目" class="headerlink" title="5.打包部署项目"></a>5.打包部署项目</h4><p>   引入一个插件</p>
   <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            这个插件，可以将项目打包成可执行的jar包，这样目标服务器部署时不需要配置tomcat服务器即可运行--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>   点击Maven构建插件package，生成了一个项目的jar包，直接使用java -jar jar包名的命令即可启动项目。部署的目标服务器不需要配置tomcat，因为jar包中已经嵌入了tomcat！！！</p>
<hr>
<h3 id="SpringBoot整合Mybatis："><a href="#SpringBoot整合Mybatis：" class="headerlink" title="SpringBoot整合Mybatis："></a>SpringBoot整合Mybatis：</h3><h4 id="1-pom-xml添加依赖"><a href="#1-pom-xml添加依赖" class="headerlink" title="1.pom.xml添加依赖"></a>1.pom.xml添加依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在之前的基础上加上mysql和mybatis启动器依赖 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-application-properties"><a href="#2-application-properties" class="headerlink" title="2.application.properties"></a>2.application.properties</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据库四大参数</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123</span></span><br><span class="line"><span class="comment">#Mybatis配置</span></span><br><span class="line"><span class="comment">#给pojo类起别名(不需要写全路径)，写Mapper.xml时方便使用</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.example.demo.li.pojo</span></span><br><span class="line"><span class="comment">#logging。。。</span></span><br></pre></td></tr></table></figure>

<p>这里可以使用YAML配置文件代替properties文件，YAML是JSON的一个超集，可以将外部配置以层次结构形式存储起来，当项目的类路径中有SnakeYAML库(spring-boot-starter中已经被包含)时，SpringApplication类将自动支持YAML作为properties的替代。<strong>细节：</strong>properties文件中是以“.”进行分割的，在yml中是用<strong>“:”</strong>进行分割的；yml的数据格式和json的格式很像，都是<strong>K-V格式</strong>，通过<strong>“:”进行赋值</strong>；yml的冒号后面一定要<strong>加一个空格</strong>，否则文件会报错。</p>
<p>springboot会自动加载spring.datasource.*相关配置，数据源就会自动注入到sqlSessionFactory中，sqlSessionFactory会自动注入到Mapper中，你一切都不用管了，直接拿起来使用就行了！！！mybatis.mapper-locations属性可以在启动类上加@MapperScan(“xxx.xxx.xx”)代替，或者在每个Mapper接口上加@Mapper注解替代！！！</p>
<h4 id="3-编写pojo类User"><a href="#3-编写pojo类User" class="headerlink" title="3.编写pojo类User"></a>3.编写pojo类User</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String usernme;</span><br><span class="line">    <span class="keyword">private</span> String passowrd;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    getter/setter。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-UserController"><a href="#4-UserController" class="headerlink" title="4.UserController"></a>4.UserController</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"users"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userService.getAllUser();</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"delete/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUserById</span><span class="params">(@PathVariable Integer id)</span></span>&#123;</span><br><span class="line">        userService.deleteUserById(id);</span><br><span class="line">        <span class="keyword">return</span> id+<span class="string">"被删了"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-UserService-amp-UserServiceImpl"><a href="#5-UserService-amp-UserServiceImpl" class="headerlink" title="5.UserService&amp;UserServiceImpl"></a>5.UserService&amp;UserServiceImpl</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.getAllUser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">deleteUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.deleteUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里遇到一个很奇怪的问题，这里的@Autowired注解总是说不能自动注入，但是不影响编译和运行。。</p>
<p><img src="https://s2.ax1x.com/2019/09/10/naCcND.png" alt="naCcND.png"></p>
<p>既然不影响。。。可以直接将这个错误的等级降到警告：</p>
<p><a href="https://imgchr.com/i/naC6AO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/10/naC6AO.md.png" alt="naC6AO.md.png"></a></p>
<h4 id="6-UserDao"><a href="#6-UserDao" class="headerlink" title="6.UserDao"></a>6.UserDao</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意@Mapper注解是在Mybatis3.4.0版本才引入的</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAllUser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from user where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">Integer <span class="title">deleteUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用@select()、@delete()、@update()、@insert()去写动态sql语句，如果pojo类属性和数据库表列名不一致可以使用@Result 修饰返回的结果集，关联实体类属性和数据库字段一一对应。</p>
<p>如果用是mapper.xml编写sql语句的话，需要在启动类上加@MapperScan(“….dao包路径”)去掉@Mapper。</p>
<p>这些都准备好之后就可以直接运行了，请求的数据操作也都能正确的持久化到数据库中。。。这算是基本调通了。。。其他的东西再慢慢学习补充吧。。。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot和三种常见任务任务</title>
    <url>/2020/03/15/SpringBoot%E5%92%8C%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p>异步任务、定时任务、邮件任务<a id="more"></a></p>
<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>先模拟一个场景，现在我有一个AsyncService和一个AsyncController：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);<span class="comment">//让方法阻塞三秒</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"处理数据中。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AsyncService asyncService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        asyncService.hello();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该应用并发起请求，在阻塞了三秒之后，控制台打印了“处理数据中。。。”与此同时收到success响应。</p>
<p>上面是个“同步调用”的例子，由于Controller中的hello方法和Service中的hello方法没有必须的依赖关系，所以我们不想让success响应去等待被阻塞的hello方法，那么我们就要让其“异步调用”。在SpringBoot应用中进行异步处理是相对简单的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span><span class="comment">//在启动类上开启异步注解功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTestApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TaskTestApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//@Async标注的方法，称之为异步方法，在执行的时候，spring将会为其开辟独立的线程执行，</span></span><br><span class="line">    <span class="comment">//调用者无需等待它的完成，即可继续其他的操作。</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"处理数据中。。。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新启动应用并请求，此时success立刻就响应了，经过短暂等待之后控制台上才打印出”处理数据中。。。”，说明现在已经成功进行了”异步调用”了。</p>
<p><font color=red>*<em>注： *</em></font></p>
<ol>
<li><font color=red><strong>@Async所修饰的函数不要定义为static类型，这样异步调用不会生效。</strong></font></li>
<li><font color=red><strong>此注解可以用在方法上，也可以用在类上（如果用在类上，这个类中的所有的方法就是异步的）。</strong></font></li>
<li><font color=red><strong>如果需要“异步回调”，可以使用“Future&lt;T&gt;”来返回异步调用的结果。</strong></font></li>
</ol>
<h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p>项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring为我们提供了异步执行任务调度的方式，提供TaskExecutor、TaskScheduler接口。</p>
<p>定时任务和上文的异步任务一样便于使用只需要在：启动类上标注@EnableScheduling开启定时任务注解，在需要定时的方方法上标注@Scheduled并写上cron表达式即可。</p>
<p><strong>cron表达式</strong>的规则并不复杂，该表达式一共需要六位，每位之间用“空格”隔开，从前往后分别表示“秒，分，小时，日，月，星期”，具体可填写的值见下表：</p>
<p><img src="https://s2.ax1x.com/2019/11/24/MOVsFP.png" alt="MOVsFP.png"></p>
<p>举几个例子：</p>
<ul>
<li>“0 0 12 * * ?” 每天中午12点触发 </li>
<li>“0 15 10 ? * *” 每天上午10:15触发 </li>
<li>“0 15 10 * * ?” 每天上午10:15触发 </li>
<li>“0 15 10 * * ? *” 每天上午10:15触发 </li>
<li>“0 15 10 * * ? 2005” 2005年的每天上午10:15触发 </li>
<li>“0 * 14 * * ?” 在每天下午2点到下午2:59期间的每1分钟触发 </li>
<li>“0 0/5 14 * * ?” 在每天下午2点到下午2:55期间的每5分钟触发 </li>
<li>“0 0/5 14,18 * * ?” 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </li>
<li>“0 0-5 14 * * ?” 在每天下午2点到下午2:05期间的每1分钟触发 </li>
<li>“0 10,44 14 ? 3 WED” 每年三月的星期三的下午2:10和2:44触发 </li>
<li>“0 15 10 ? * MON-FRI” 周一至周五的上午10:15触发 </li>
<li>“0 15 10 15 * ?” 每月15日上午10:15触发 </li>
<li>“0 15 10 L * ?” 每月最后一日的上午10:15触发 </li>
<li>“0 15 10 ? * 6L” 每月的最后一个星期五上午10:15触发 </li>
<li>“0 15 10 ? * 6L 2002-2005” 2002年至2005年的每月的最后一个星期五上午10:15触发 </li>
<li>“0 15 10 ? * 6#3” 每月的第三个星期五上午10:15触发 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableScheduling</span><span class="comment">//开启定时任务</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTestApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(TaskTestApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduleService</span> </span>&#123;</span><br><span class="line"><span class="comment">//    每天每分钟1至30秒每秒执行</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"1-30 * * * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"demo...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Scheduled注解有多个属性：</p>
<ul>
<li><code>@Scheduled(fixedRate = 5000)</code> ：上一次开始执行时间点之后5秒再执行</li>
<li><code>@Scheduled(fixedDelay = 5000)</code> ：上一次执行完毕时间点之后5秒再执行</li>
<li><code>@Scheduled(initialDelay=1000, fixedRate=5000)</code> ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次</li>
<li><code>@Scheduled(cron=&quot;*/5 * * * * *&quot;)</code> ：通过cron表达式定义规则</li>
</ul>
<h2 id="邮件任务"><a href="#邮件任务" class="headerlink" title="邮件任务"></a>邮件任务</h2><p>既然是邮件任务，那么必须要引入邮件发送的依赖和相关配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!--</span> <span class="string">https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-mail --&gt;</span></span><br><span class="line"><span class="attr">&lt;dependency&gt;</span></span><br><span class="line">    <span class="attr">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span></span><br><span class="line">    <span class="attr">&lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;</span></span><br><span class="line">    <span class="attr">&lt;version&gt;2.2.0.RELEASE&lt;/version&gt;</span></span><br><span class="line"><span class="attr">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#邮箱账户</span></span><br><span class="line"><span class="meta">spring.mail.username</span>=<span class="string">577373789@qq.com</span></span><br><span class="line"><span class="comment">#在邮箱设置界面开启SMTP服务并生成授权码</span></span><br><span class="line"><span class="meta">spring.mail.password</span>=<span class="string">xzodfhcfmzaebbfi</span></span><br><span class="line"><span class="comment">#在邮箱设置界面查看发送邮件的服务器</span></span><br><span class="line"><span class="meta">spring.mail.host</span>=<span class="string">smtp.qq.com</span></span><br><span class="line"><span class="comment">#QQ邮箱需要开启SSL，来保证安全</span></span><br><span class="line"><span class="meta">spring.mail.properties.mail.smtp.ssl.enable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>测试一下是否可以发送简单邮件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">JavaMailSenderImpl mailSender;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//        创建一个简单邮件信息</span></span><br><span class="line">    SimpleMailMessage simpleMailMessage=<span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">    <span class="comment">//        设置邮件标题</span></span><br><span class="line">    simpleMailMessage.setSubject(<span class="string">"lmh"</span>);</span><br><span class="line">    <span class="comment">//        设置邮件内容</span></span><br><span class="line">    simpleMailMessage.setText(<span class="string">"111111111"</span>);</span><br><span class="line">    <span class="comment">//        设置邮件目标</span></span><br><span class="line">    simpleMailMessage.setTo(<span class="string">"2818553826@qq.com"</span>);</span><br><span class="line">    <span class="comment">//        设置邮件来源</span></span><br><span class="line">    simpleMailMessage.setFrom(<span class="string">"577373789@qq.com"</span>);</span><br><span class="line">    <span class="comment">//        发送邮件</span></span><br><span class="line">    mailSender.send(simpleMailMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后发现目标邮箱中收到了该邮件，接下来测试发送一个稍微复杂的邮件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">JavaMailSenderImpl mailSender;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//        创建一个复杂邮件信息</span></span><br><span class="line">    MimeMessage message = mailSender.createMimeMessage();</span><br><span class="line">    <span class="comment">//        如果需要上传文件，就将第二个multiple参数设为true</span></span><br><span class="line">    MimeMessageHelper helper=<span class="keyword">new</span> MimeMessageHelper(message,<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//        邮件设置</span></span><br><span class="line">    helper.setSubject(<span class="string">"lmh"</span>);</span><br><span class="line">    <span class="comment">//        如果需要将内容当做HTML，则需要将第二个参数设置为true</span></span><br><span class="line">    helper.setText(<span class="string">"&lt;font color=red&gt;111111111&lt;/font&gt;"</span>,<span class="keyword">true</span>);</span><br><span class="line">    helper.setTo(<span class="string">"2818553826@qq.com"</span>);</span><br><span class="line">    helper.setFrom(<span class="string">"577373789@qq.com"</span>);</span><br><span class="line">    <span class="comment">//        上传文件</span></span><br><span class="line">    helper.addAttachment(<span class="string">"图片1"</span>,<span class="keyword">new</span> File(<span class="string">"E:\\images\\83394.jpg"</span>));</span><br><span class="line">    helper.addAttachment(<span class="string">"图片2"</span>,<span class="keyword">new</span> File(<span class="string">"E:\\images\\83395.jpg"</span>));</span><br><span class="line">    <span class="comment">//        最后别忘了发送</span></span><br><span class="line">    mailSender.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也没什么问题成功接收到邮件，邮件内容为红色字体，并且有两个附件。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot和日志框架</title>
    <url>/2020/03/15/SpringBoot%E5%92%8C%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>学习Java时间也不短了，最近忽然发现（顿悟）我好想没怎么学习使用过“日志”这个东西啊。。。之前学校的教学中简单的使用了log4j，但是配置文件也是老师给的，自己也没有细究其内容，就浑浑噩噩的过去了。现在想想确实不该，这不是一个好的现象。既然发现缺漏，那就花点时间将其慢慢弥补。<a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>SpringBoot基于Spring，Spring使用Apache的<strong>JCL（Jkarta Commons Logging）</strong>作为<strong>Spring框架内部的日志框架</strong>，<u>其仅仅是一个日志接口</u>，<u>在实际应用中需要为该接口来指定相应的日志实现。</u>SpringBoot默认的<strong>日志实现</strong>是<strong>JUL（Java Util Logging）</strong>，<u>是JDK自带的日志包</u>。</p>
<p>此外SpringBoot外部当然也支持<strong>SLF4j（Simple Logging Facade for java）日志接口、Log4j日志实现、Logback日志实现</strong>这类很流行的日志框架。而且<strong>spring-boot-starter-logging</strong>采用了<strong>SLF4j+logback</strong>的形式，SpringBoot也能自动适配很多其他流行日志框架并简化配置。</p>
<p>统一将上面这些<strong>日志实现</strong>统称为<strong>日志框架</strong>。</p>
<p>Java应用中，日志一般分为以下5个级别：</p>
<ul>
<li>ERROR错误信息</li>
<li>WARN警告信息</li>
<li>INFO一般信息</li>
<li>DEBUG调试信息</li>
<li>TRACE跟踪信息</li>
</ul>
<h3 id="SLF4j"><a href="#SLF4j" class="headerlink" title="SLF4j"></a>SLF4j</h3><p>SLF4j是一个存取日志的标准接口，一张图展示SLF4j对多种日志框架极好的兼容性：</p>
<p><img src="https://s2.ax1x.com/2019/11/17/MrrFAO.png" alt="MrrFAO.png"></p>
<p>使用的时候，日志记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层里的方法。</p>
<p>每一个日志的实现框架都有自己的配置文件。使用SLF4j以后，配置文件依然是日志实现框架自己本身的配置文件。</p>
<h4 id="一个思考"><a href="#一个思考" class="headerlink" title="一个思考"></a>一个思考</h4><p>现在有一个a项目使用SLF4j+logback日志框架，但是a项目依赖了Spring、Hibernate、Mybatis等等框架，这些依赖的框架内部使用的不是SLF4j+logback日志框架：</p>
<p>a系统（SLF4j+logback）：Spring（commons-logging）、Hibernate（jboss-logging）。。。</p>
<p>能否统一日志记录，使a系统及其依赖项目框架都使用SLF4j进行输出？</p>
<p>在<a href="http://www.slf4j.org/legacy.html" target="_blank" rel="noopener">SLF4j官方文档</a>中已经给出了解决方案，这个方案就是：<strong>Replace</strong>！</p>
<p><a href="https://imgchr.com/i/MrcwQJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/17/MrcwQJ.md.png" alt="MrcwQJ.md.png"></a></p>
<p>这个解决方案大概以下三步：</p>
<ol>
<li>将系统中其他的日志框架先排除出去，但是被排除日志框架的项目很可能会在运行时报错！</li>
<li>为了避免第一步的问题，SLF4j提供了一系列的<strong>中间包</strong>用来替换原有的日志框架。</li>
<li>最后导入我们需要的SLF4j实现即可。</li>
</ol>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>SpringBoot应用都依赖于spring-boot-starter，spring-boot-starter又依赖spring-boot-autoconfigure(自动配置)、snakeyaml(yaml文件解析)、spring-boot-starter-logging，其中spring-boot-starter-logging依赖关系如下：</p>
<p><img src="https://s2.ax1x.com/2019/11/17/MrgWNV.png" alt="MrgWNV.png"></p>
<ol>
<li>SpringBoot底层使用SLF4j+logback进行日志记录。</li>
<li>SpringBoot也把其他的日志都替换成了SLF4j。一系列的替换包项目，内部的包名和被替换的包保持一致，但是内部都是调用的SLF4j的方法实现的。</li>
<li>如果我们要引入其他的框架，一定要把这个框架的默认日志依赖exclusion掉，移除之后SpringBoot就可以自动适配。事实上SpringBoot本身也是这么干的。</li>
</ol>
<h4 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h4><p>在运行SpringBoot应用时，我们没有进行日志配置，但是依然有日志输出，说明SpringBoot有默认设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过记录工厂获取记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//日志级别由低到高：trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line">    <span class="comment">//可以调整输出的日志级别，日志就只会设置级别及其更高的级别生效</span></span><br><span class="line">    logger.trace(<span class="string">"trace..."</span>);</span><br><span class="line">    logger.debug(<span class="string">"debug..."</span>);</span><br><span class="line">    logger.info(<span class="string">"info..."</span>);</span><br><span class="line">    logger.warn(<span class="string">"warn..."</span>);</span><br><span class="line">    logger.error(<span class="string">"error..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：2019-11-17 20:43:34.396  INFO 175256 --- [           main] c.e.testslf4j.TestSlf4jApplicationTests  : info...</span></span><br><span class="line"><span class="comment">//2019-11-17 20:43:34.397  WARN 175256 --- [           main] c.e.testslf4j.TestSlf4jApplicationTests  : warn...</span></span><br><span class="line"><span class="comment">//2019-11-17 20:43:34.397 ERROR 175256 --- [           main] c.e.testslf4j.TestSlf4jApplicationTests  : error...</span></span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，SpringBoot默认配置的日志级别是：info，如果希望所有级别的日志，需要在配置文件中加入：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#logging.level.被设置的包路径=级别</span></span><br><span class="line"><span class="meta">logging.level.com.example.testslf4j</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure>

<p>如果希望不仅仅是在控制台输出日志，而是希望可以以文件的形式保存日志信息，可以进行如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#logging.file=springboot.log 不指定路径，springboot.log文件就会保存在项目下</span></span><br><span class="line"><span class="comment">#logging.file=E:/springboot.log   指定路径后，会在指定路径下保存日志文件</span></span><br><span class="line"><span class="comment">#logging.path=/spring/log 	在当前次品的根目录下创建/spring/log，使用spring.log作为默认文件</span></span><br></pre></td></tr></table></figure>

<p>但是上述配置方式在springboot2.0之后有所变化：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#logging.file改为logging.file.name=E:/springboot.log </span></span><br><span class="line"><span class="comment">#logging.path改为logging.file.path=/spring/log</span></span><br></pre></td></tr></table></figure>

<p>上述方法两条配置如果一起使用，只有logging.file.name起效。（老版本配置一样）还可以配置日志的格式：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#日志输出格式:</span></span><br><span class="line"><span class="comment">#%d表示日期时间，</span></span><br><span class="line"><span class="comment">#%thread表示线程名</span></span><br><span class="line"><span class="comment">#%-5level:级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">#%logger&#123;50&#125;表示1ogger名字最长50个字符,否则按照句点分割。</span></span><br><span class="line"><span class="comment">#%msg:日志消息，</span></span><br><span class="line"><span class="comment">#%n是换行符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#控制台输出日志的格式</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125;****[%thread]****%-5level****%logger&#123;50&#125;****%msg%n</span></span><br><span class="line"><span class="comment">#文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125;****[%thread]****%-5level****%logger&#123;50&#125;****%msg%n</span></span><br></pre></td></tr></table></figure>

<p>上述配置都是在application.properties中进行的，只能进行部分配置。如果想要进行更加详细完备的日志配置，需要添加xml日志配置文件。在springboot包中的logging包中有对logback进行默认配置的xml文件，如果想要定义自己的日志配置文件，直接在类路径下创建每个日志框架自己的配置文件即可，SpringBoot就不使用默认配置了。自定义日志配置文件的文件名必须使用官方文档中说的这些：</p>
<p><a href="https://imgchr.com/i/MsKptO" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/17/MsKptO.md.png" alt="MsKptO.md.png"></a></p>
<p>并且SpringBoot官方建议使用带有spring的文件名，如果使用logback.xml，配置文件就会被日志框架直接识别（相当于绕过了SpringBoot）。</p>
<p>反之，如果使用logback-spring.xml，日志框架就不直接加载日志的配置项，而是由SpringBoot来解析日志配置，而且可以使用SpringBoot的springProfile功能：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--可以指定某段配置，只在某个环境下生效(该功能只能SpringBoot解析时才能生效，如果直接日志框架识别则会报错)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span><span class="comment">&lt;!--dev 开发环境下生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd&#125;****[%thread]****%-5level****%logger&#123;50&#125;****%msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span><span class="comment">&lt;!--!dev 非开发环境下生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd&#125;----[%thread]----%-5level----%logger&#123;50&#125;----%msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="日志框架的切换"><a href="#日志框架的切换" class="headerlink" title="日志框架的切换"></a>日志框架的切换</h4><p>以SLF4j替换为LOG4j为例，先看官方文档：</p>
<p><img src="https://s2.ax1x.com/2019/11/17/Ms1eMQ.png" alt="Ms1eMQ.png"></p>
<p>看明白了这个，切换这件事就变得简单了，简单粗暴直接排除原先的spring-boot-starter-logging依赖，引入spring-boot-starter-log4j2依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SpringBoot会自动适配log4j，并且也有其对应的默认配置。如果需要log4j的自定义配置文件，按照前文logback自定义配置文件的方式创建对应的xml文件即可。</p>
<hr>
<p>关于每个日志框架的配置文件中还有哪些可配置项，后续学习中再去日志框架对应的官方文档或者大佬的博文中了解。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot与RabbitMQ集成</title>
    <url>/2020/03/15/SpringBoot%E4%B8%8ERabbitMQ%E9%9B%86%E6%88%90%E7%AF%87/</url>
    <content><![CDATA[<p>学习SpringBoot整合各种框架、中间件都要从自动配置开始看起，整合RabbitMQ也不例外。<a id="more"></a></p>
<p>打开<strong>RabbitAutoConfiguration</strong>，发现配置类中给容器注册了一个<strong>ConnectionFactory</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/10/20/KKl176.png" alt="KKl176.png"></p>
<p>该类需要传入<strong>RabbitProperties</strong>类对象，<strong>RabbitProperties</strong>类中封装了中间件的配置。</p>
<p>配置类还会给容器注册一个<strong>RabbitTemplate</strong>和一个<strong>AmqpAdmin</strong>，<strong>RabbitTemplate</strong><u>就是用来给RabbitMQ发送和接收消息的</u>，<strong>AmqpAdmin</strong><u>就是RabbitMQ系统管理功能组件主要用来创建队列、交换器。。。</u></p>
<p><strong>RabbitTemplate</strong>有两个常用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Message需要自己构造一个；可以定义Message消息体内容和消息头</span><br><span class="line">rabbitTemplate.send(exchange,routingkey,message);</span><br><span class="line"></span><br><span class="line">不用定义消息头信息，只需要传入要发送的数据对象，object默认当成消息体，自动序列化发给RabbitMQ</span><br><span class="line">rabbitTemplate.convertAndSend(exchange,routingkey,object);</span><br></pre></td></tr></table></figure>

<p>手动去RabbitMQ创建好exchange并绑定好queue，写个测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//    点对点单播测试</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String,Object&gt; map =<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"msg"</span>,<span class="string">"这是第一个消息"</span>);</span><br><span class="line">    map.put(<span class="string">"data"</span>, Arrays.asList(<span class="string">"这是data的数据"</span>,<span class="number">123</span>,<span class="keyword">true</span>));</span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">"exchange.direct"</span>,<span class="string">"nynu.news"</span>,map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成功发送消息到nynu.news：<img src="https://s2.ax1x.com/2019/10/20/KKUQuF.png" alt="KKUQuF.png"></p>
<p>再测试一下接收消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiveDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//rabbitTemplate提供了返回值为Message对象、返回值为object对象等等的接收方法</span></span><br><span class="line">    Object o = rabbitTemplate.receiveAndConvert(<span class="string">"nynu.news"</span>);<span class="comment">//获取消息之后，队列中相应的消息也被移出</span></span><br><span class="line">    System.out.println(o.getClass());</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//class java.util.HashMap</span></span><br><span class="line"><span class="comment">//&#123;msg=这是第一个消息, data=[这是data的数据, 123, true]&#125;</span></span><br></pre></td></tr></table></figure>

<p><font color=red><strong>发送消息时，可以不使用默认的java序列化策略，而是使用json格式的序列化策略来处理消息：</strong></font></p>
<p>在RabbitTemplate中有一个消息转换器，默认值SimpleMessageConverter使用的是java的序列化策略：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> MessageConverter messageConverter = <span class="keyword">new</span> SimpleMessageConverter();</span><br></pre></td></tr></table></figure>

<p>如果希望使用json格式的序列化策略，可以自定义配置类，给容器注册一个我们需要的MessageConverter，MessageConverter接口的众多实现：</p>
<p><img src="https://s2.ax1x.com/2019/10/20/KKrFxI.png" alt="KKrFxI.png"></p>
<p>选择使用Jackson2JsonMessageConverter实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AMQPConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义配置类如果有设置好的MessageConverter，RabbitAutoConfiguration会自动将其配置进来。完成上述操作就可以在发送消息时序列化为json格式了。</p>
<p><font color=red>获取消息时，反序列化转换的java对象必须包含无参构造方法，不然会抛MessageConversionException。receiveAndConvert()方法返回值虽然是Object类型对象，但是该对象用getClass()方法获取其类型时返回结果为定义的java对象，所以可以放心的将返回的Object对象强转为定义的的java对象。</font></p>
<p>上面只演示了单播，广播和可选择播报和上述方式一样，区别只是参数中Exchange是什么类型的。</p>
<hr>
<p>在SpringBoot开发中可以使用注解的方式来使用RabbitMQ：</p>
<p>在service方法上加上@RabbitListener注解，此注解需要一个数组属性queue来指定方法监听的队列，然后还需要在启动类上@EnableRabbit启动对注解式RabbitMQ的支持：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"nynu.news"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Shoes shoes)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"有鞋子订单"</span>+shoes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述操作启动SpringBoot应用后，执行一个向nynu.news队列发送Shoes类型消息的方法，SpringBoot应用的控制台即可打印出数据，说明service方法执行。<font color=red>但是，上述方法只要指定的队列有消息，就会被获取，如果队列中消息的数据类型和接收方法需要获取的类型不一致，就会导致获取到的数据和预期有出入。</font></p>
<p>如果需要接收到消息的头信息，只需要使用Message类型对象来接受消息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = <span class="string">"nynu.news"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">msgAndHeader</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    System.out.println(msg.getBody());</span><br><span class="line">    System.out.println(msg.getMessageProperties());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>有一个问题，上述所有操作都是建立在交换器和队列都创建并绑定好的情况下进行的，那么怎样在SpringBoot应用中创建和绑定这些组件呢？</p>
<p>可以用AmqpAdmin系统管理组件完成Exchange、Queue、Binding的创建和删除，AmqpAdmin会由配置类自动注册到容器中去，AmqpAdmin提供了很多declearXXX()、deleteXXX()、removeXXX()等等方法用来创建或者删除组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Exchange接口有五个实现类FanoutExchange、DirectExchange、TopicExchange、HeadersExchange、CustomerEXchange</span></span><br><span class="line"><span class="comment">//创建Exchange实现类对象时，可以指定名字、是否持久化、是否自动删除、参数头arguments</span></span><br><span class="line">    amqpAdmin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">"amqpAdmin.directExchange"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Queue创建时可以指定：String name, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">    amqpAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">"amqpAdmin.queue"</span>));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Binding创建时必须指定：String destination, Binding.DestinationType destinationType, String exchange, String routingKey, Map&lt;String, Object&gt; arguments</span></span><br><span class="line">    amqpAdmin.declareBinding(<span class="keyword">new</span> Binding(<span class="string">"amqpAdmin.queue"</span>,Binding.DestinationType.QUEUE,<span class="string">"amqpAdmin.directExchange"</span>,<span class="string">"amqpAdmin.q"</span>,<span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除组件方法指定被删除组件的名字即可，不再赘述。</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot与Redis集成</title>
    <url>/2020/03/15/SpringBoot%E4%B8%8ERedis%E9%9B%86%E6%88%90%E7%AF%87/</url>
    <content><![CDATA[<p>这次就记录一下在SpringBoot应用中如何集成并使用Redis。其他介绍就不再赘述了。<a id="more"></a></p>
<h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h2><p>当引入并使用redsi依赖之后，就不再是默认的SimpleCacheConfiguration起效了，而是RedisAutoConfiguration在起作用了，RedisAutoConfiguration中向容器中引入了RedisTemplate组件,方便操作缓存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(</span><br><span class="line">    name = &#123;<span class="string">"redisTemplate"</span>&#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RedisTemplate和StringRedisTemplate就像是之前学习的JDBCTemplate一个意思，可以使用这两个redisTemplate组件对Redis进行操作。<font color=red>因为String类型的操作比较多，所以将StringRedisTemplate单独抽取出来作为一个类，这个类就是继承了RedisTemplate&lt;String,String&gt;。</font></p>
<p>使用这两个组件时让Spring进行自动注入即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br></pre></td></tr></table></figure>

<p>RedisTemplate和StringRedisTemplate中提供了一系列数据存取操作，例如常用的五种数据结构的操作：</p>
<ul>
<li>redisTemplate.opsForValue();//操作字符串</li>
<li>redisTemplate.opsForHash();//操作hash</li>
<li>redisTemplate.opsForList();//操作list</li>
<li>redisTemplate.opsForSet();//操作set</li>
<li>redisTemplate.opsForZSet();//操作有序set</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().append(<span class="string">"msg"</span>,<span class="string">"world"</span>);</span><br><span class="line">    Object msg = stringRedisTemplate.opsForValue().get(<span class="string">"msg"</span>);</span><br><span class="line">    System.out.println(msg.toString());</span><br><span class="line">    stringRedisTemplate.opsForList().leftPush(<span class="string">"mylist"</span>,<span class="string">"1"</span>);</span><br><span class="line">    stringRedisTemplate.opsForList().leftPush(<span class="string">"mylist"</span>,<span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用StringRedisTemplate存储string类型比较简单，一般不会出现什么问题。redis自身提供的所有数据操作命令，在coding时基本上都可以可以“.”出来。</p>
<p><font color=red><strong>需要注意的是保存java对象(对象定义时需要实现序列化接口，否则抛运行时异常)：</strong></font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = userDao.selectUserById(<span class="number">133</span>);</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">"user01"</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>运行之后，redis缓存中确实存入了对应的键值，但是键值都是序列化后的值，不方便查看和维护使用，我还是更习惯json格式。将数据以json的方式保存有以下方法：</strong></font></p>
<ol>
<li><p>自己手动转换json然后去缓存。直接使用一些json工具转换就行，较为简单。</p>
</li>
<li><p>RedisTemplate默认的序列化器，就是jdk的序列化器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultSerializer == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.defaultSerializer = <span class="keyword">new</span> JdkSerializationRedisSerializer(<span class="keyword">this</span>.classLoader != <span class="keyword">null</span> ? <span class="keyword">this</span>.classLoader : <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以自己写一个配置类，并给组件设置我们需要的序列化器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, User&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, User&gt; template = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        Jackson2JsonRedisSerializer serializer=<span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;User&gt;(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        template.setDefaultSerializer(serializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成上述的工作，就可以在之前的测试类中自动注解RedisTemplate&lt;Object, User&gt;用来完成json字符串存储。</p>
</li>
</ol>
<h2 id="整合实例："><a href="#整合实例：" class="headerlink" title="整合实例："></a>整合实例：</h2><ol>
<li><p>第一步当然是添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实体类，实体类一定要进行序列化，因为Redis保存对象的时候要求对象是序列化的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    setter/getter/tostring...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就和之前使用默认SimpleCache类似了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>,key = <span class="string">"#id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userDao.selectUserById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>连续发起请求，从控制台看到第一次查询数据库，第二次没有查询数据库，说明缓存起效了，redis缓存中也存入了数据，<font color=red><strong>但是key是user::133,value是序列化后的值</strong></font>，这是为什么呢？</p>
<p><font color=red><strong>答：</strong></font>用默认的SimpleCache时，配置类会自动给容器注册一个CacheManager[ConcurrentMapCacheManager]，这个CacheManager创建对应的Cahce组件进行实际的CRUD操作。</p>
<p>现在使用<strong>Redis</strong>也不例外，RedisCacheConfiguration也会自动注册一个<strong>默认的</strong>CacheManager。RedisCacheManager帮我们创建RedisCahce来作为缓存组件，RedisCacheManager中设置了操作缓存数据的各种规则，这就是问题的原因。</p>
<p>那么如果要将缓存数据序列化为JSON格式后保存，就需要<strong>自定义CacheManager</strong>：</p>
<p><font color=red><strong>需要注意：springboot1.0和2.0创建RedisCacheManager 的方法是不同的：</strong></font></p>
<ul>
<li><p><strong>springboot 1.0</strong>：</p>
<p><font color=red>1.0默认创建的RedisCacheManager操作redis时，是使用RedisTemplate&lt;object,object&gt;。而RedisTemplate&lt;object,object&gt;默认使用的序列化机制是JDK的序列化器。</font></p>
<p>自定义的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">userCacheManager</span><span class="params">(RedisTemplate&lt;Object, User&gt; redisTemplate)</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入自定义的RedisTemplate，给这个自定义的RedisTemplate设置一个需要的json序列化器</span></span><br><span class="line">    RedisCacheManager redisCacheManager = <span class="keyword">new</span> RedisCacheManager(redisTemplate);</span><br><span class="line">    <span class="comment">//true使用cacheName作为key的前缀，再将指定的key拼接上</span></span><br><span class="line">    redisCacheManager.setUsePrefix(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringBoot 1.0默认的redisCacheManager方法最后会调用CacheManagerCustomizers对象，这个对象可以定制缓存的一些规则。（不常用）</p>
</li>
<li><p><strong>springboot 2.0</strong>中默认的cacheManager方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">    RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(<span class="keyword">this</span>.determineConfiguration(resourceLoader.getClassLoader()));</span><br><span class="line">    List&lt;String&gt; cacheNames = <span class="keyword">this</span>.cacheProperties.getCacheNames();</span><br><span class="line">    <span class="keyword">if</span> (!cacheNames.isEmpty()) &#123;</span><br><span class="line">        builder.initialCacheNames(<span class="keyword">new</span> LinkedHashSet(cacheNames));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (RedisCacheManager)<span class="keyword">this</span>.customizerInvoker.customize(builder.build());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看RedisCacheManager源码+参考百度，摸索着自定义了一个CacheManager：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">userRedisCacheManager</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">            <span class="comment">//.entryTtl(Duration.ofDays(1))    //设置缓存过期时间为一天</span></span><br><span class="line">            <span class="comment">//.disableCachingNullValues()      //禁用缓存空值，不缓存null校验</span></span><br><span class="line">            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer()));     <span class="comment">// 设置CacheManager的值序列化方式为json序列化，可加入@Class属性</span></span><br><span class="line">        <span class="keyword">return</span> RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(cacheConfiguration).build();     <span class="comment">// 设置默认的cache组件</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>经过我的测试，都可以正确的将查询到数据正确的转换成json格式并缓存。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="SpringBoot-1-0整合注意事项"><a href="#SpringBoot-1-0整合注意事项" class="headerlink" title="SpringBoot 1.0整合注意事项"></a>SpringBoot 1.0整合注意事项</h2><p>在上文中SpringBoot 1.0中自定义CacheManager，已经可以实现需求。但是当有多个表和实体时(除了例子中的User、又添加一个Dept表和对应实体)，直接对新添加的表进行查询并使用注解缓存，则会抛出运行时异常。</p>
<p>因为在userCacheManager中指定了对User进行json格式序列化，所以<strong><u>如果需要对新添加的表进行查询时需要添加新的自定义缓存管理器(deptCacheManager),并给UserServiceImpl和DeptServiceImpl中的缓存注解的CacheManager属性设置各自所用的自定义缓存器</u></strong>。而且，需要注意的是如果<strong><u>存在两个及两个以上的自定义缓存管理器时，需要用@Primary注解来标注一个默认使用的缓存管理器（一般是将源码中默认的缓存管理器复制到自定义配置类中用@Primary标注）。</u></strong></p>
<hr>
<p>在很多场景下，可能需要我们再方法中手动对缓存中的数据进行操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userRedisCacheManager"</span>)<span class="comment">//用id指定注入的bean</span></span><br><span class="line">    <span class="keyword">private</span> RedisCacheManager userRedisCacheManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">        User user = userDao.selectUserById(id);</span><br><span class="line"><span class="comment">//        获取某个缓存组件</span></span><br><span class="line">        Cache userCache = userRedisCacheManager.getCache(<span class="string">"user"</span>);</span><br><span class="line"><span class="comment">//		  使用缓存组件对缓存数据操作        </span></span><br><span class="line">        userCache.put(id,user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>至于整合redis时踩的坑、尚未解决的细节和数据库查询结果为空时缓存和controller具体如何处理等等问题，择日再起新篇。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot与消息服务</title>
    <url>/2020/03/15/SpringBoot%E4%B8%8E%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<p>消息（Message）是指软件对象之间进行交互作用和通讯利用的一种方式。中间件（Middleware）是处于操作系统和应用程序之间的软件，也有人认为它应该属于操作系统中的一部分。消息中间件则是将软件与软件之间的交互消息、交互方式进行存储和管理的一种技术,也可以看做是一种容器。消息中间件关注于数据的发送和接收，利用高效可靠的异步消息传递机制集成分布式系统。<a id="more"></a></p>
<p>消息服务的应用场景有很多很多：系统解耦、异步、扩展、流量销峰、日志处理、消息通信等等。。。通过几个简单例子了解一下消息服务的作用和好处：</p>
<h3 id="例子1（异步通信）："><a href="#例子1（异步通信）：" class="headerlink" title="例子1（异步通信）："></a>例子1（异步通信）：</h3><p>用户注册成功，将注册信息写入数据库然后给用户发送注册邮件和发送注册短信，串行方式：</p>
<p><img src="https://s2.ax1x.com/2019/10/17/KAbLlQ.png" alt="KAbLlQ.png"></p>
<p>注册信息持久化之后的发送注册邮件和注册短信可以使用多线程并发操作，并行方式：</p>
<p><img src="https://s2.ax1x.com/2019/10/17/KAbOyj.png" alt="KAbOyj.png"></p>
<p><u>但是，当注册信息写入数据库、发送短信和邮件之前就应该让用户完成注册了</u>。我们可以引入消息队列，只要将后序要用的数据写入消息队列就算注册流程完毕了。发送邮件和发送短信可以通过<strong>异步读取</strong>的方式从消息队列中取出数据，然后完成相应的服务。</p>
<p><img src="https://s2.ax1x.com/2019/10/17/KAbXOs.png" alt="KAbXOs.png"></p>
<p>传统方式的系统性能（并发量，吞吐量，响应时间）会有瓶颈。通过引入消息队列，将不是必须的业务逻辑，异步处理，从而达到提高系统性能的目的。</p>
<h3 id="例子2（应用解耦）："><a href="#例子2（应用解耦）：" class="headerlink" title="例子2（应用解耦）："></a>例子2（应用解耦）：</h3><p>一个应用写有订单系统和库存系统，我们下单然后去调用库存系统的方法来检索库存，传统做法：订单系统去调用库存系统对外提供的接口。但是传统的做法存在缺点：</p>
<ol>
<li>假如库存系统无法访问，则订单减库存将失败，从而导致订单失败。</li>
<li>订单系统与库存系统耦合。</li>
</ol>
<p>为了解决以上缺点，我们可以引入消息队列，并将订单系统和库存系统抽取出来作为两个独立的服务：</p>
<ul>
<li>订单系统：用户下单后，订单系统完成持久化处理，将消息写入消息队列，返回用户订单下单成功。</li>
<li>库存系统：订阅下单的消息，采用拉/推的方式，获取下单信息，库存系统根据下单信息，进行库存操作。</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/10/17/KALubn.png" alt="KALubn.png"></p>
<p>假如：在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦。至于怎么保证两个服务之间库存量等数据一致，暂时先不讨论。。。</p>
<h3 id="例子3（流量销峰）："><a href="#例子3（流量销峰）：" class="headerlink" title="例子3（流量销峰）："></a>例子3（流量销峰）：</h3><p>流量削锋也是消息队列中的常用场景，一般在秒杀或团抢活动中使用广泛。</p>
<p>应用场景：秒杀活动，一般会因为流量过大，导致流量暴增，应用挂掉。为解决这个问题，一般需要加入消息队列来控制用户数量和缓解高流量的压力。</p>
<p><img src="https://s2.ax1x.com/2019/10/17/KALnDs.png" alt="KALnDs.png"></p>
<p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求并做出一定的响应操作。秒杀业务根据消息队列中的请求信息，再做后续处理。这只是很笼统很模糊的说了一下，具体细节还有很多很多。。</p>
<hr>
<h2 id="消息服务规范"><a href="#消息服务规范" class="headerlink" title="消息服务规范"></a>消息服务规范</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>消息服务中有两个重要的概念：<font color=red><strong>消息代理（MassageBroker）、目的地（destination）</strong></font></p>
<p>当消息发送者发送消息以后，将由<strong>消息代理</strong>接管，消息代理保证消息传递到指定<strong>目的地</strong>。</p>
<p>消息队列主要有两种形式的目的地：</p>
<ol>
<li><font color=red><strong>队列（queue）</strong></font>：点对点式消息通信（point-to-point），消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列，<font color=red>消息只有唯一的发送者和接受者，但并不是说只有一个接收者,也就是说A、B、C等等接收者都有资格去接受消息，但是一个消息最终只能被一个接收者所接受。</font>有点拗口，但是很好理解。。。</li>
<li><font color=red><strong>主题（topic）</strong></font>：发布（publish）/订阅（subscribe）式消息通信，发布者发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，<font color=red>那么当消息到达主题的时候这个主题所有的接收者（订阅者）都会受到消息</font>。</li>
</ol>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p><strong>Java消息服务</strong>(Java Message Service)即JMS，是一个Java平台中关于面向消息中间件的api，用于在两个应用程序之间或分布式系统中发送消息，进行异步通信。</p>
<p>基于JVM消息代理的规范，ActiveMQ、HornetMQ是JMS实现。</p>
<h3 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h3><p><strong>高级消息队列协议</strong>(advanced message queuing protocol)即AMQP，是一个提供统一消息服务的应用层标准协议，基于此协议的客户端与消息中间件可传递消息，并且不受客户端/中间件不同的产品、不同的开发语言等条件的限制。</p>
<p>也是一个消息代理的规范，兼容JMS，RabbitMQ是AMQP的实现。</p>
<p>再偷一张JMS和AMQP对比图：</p>
<p><img src="https://s2.ax1x.com/2019/10/19/KmAEM4.png" alt="KmAEM4.png"></p>
<h3 id="Spring支持"><a href="#Spring支持" class="headerlink" title="Spring支持"></a>Spring支持</h3><ul>
<li>spring-jms提供了对JMS的支持。</li>
<li>spring-rabbit提供了对AMQP的支持。</li>
<li>需要ConnectionFactory的实现来连接消息代理。</li>
<li>提供JmsTemplate、RabbitTemplate来发送消息。</li>
<li>@JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息。</li>
<li>@EnableJms、@EnableRabbit开启支持。</li>
</ul>
<p>SpringBoot自动配置：</p>
<ul>
<li>JmsAutoConfiguration</li>
<li>RabbitAutoConfiguration</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>RabbitMQ是一个基于AMQP使用erlang开发的开源实现。</p>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><img src="https://s2.ax1x.com/2019/10/19/Kmmbin.png" alt="Kmmbin.png"></p>
<p><strong>Message：</strong>消息，消息是不具名的，他有消息头和消息体组成，消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括<strong>routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）</strong>等等。。</p>
<p><strong>Publisher：</strong>消息的生产者，也是一个向<strong>交换器</strong>发布消息的客户端应用程序。</p>
<p><strong>Exchange：</strong>交换器，用来接收<strong>生产者</strong>发送的消息并将这些消息路由给容器中的<strong>队列</strong>，<strong>交换器</strong>有点像是网络中的交换机，而容器中的队列像是连接在交换机上的主机。Exchange有四种类型：<strong>direct（默认）、fanout、topic和headers</strong>，不同类型的Exchange转发消息的策略有所区别。</p>
<p><strong>Queue：</strong>消息队列，用来保存消息直到发送给<strong>消费者</strong>。它是消息的容器，也是消息的终点。一个消息可投入一个或者多个队列。消息一直在队列里面，等待<strong>消费者</strong>连接到这个队列将其取走。</p>
<p><strong>Binding：</strong>绑定，用于<strong>消息队列</strong>和<strong>交换器</strong>之间的关联。一个绑定就是基于<strong>路由键</strong>将<strong>交换器</strong>和<strong>消息队列</strong>连接起来的路由规则，所以可以将其理解成一个由<strong>绑定</strong>构成的路由表。<strong>Exchange</strong>和<strong>Queue</strong>的绑定可以是<strong>多对多</strong>的关系。</p>
<p><strong>Connection：</strong>网络连接，比如一个TCP连接。</p>
<p><strong>Channel：</strong>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内的虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP连接。</p>
<p><strong>Consumer：</strong>消息的消费者，表示一个从消息队列中取得信息的客户端应用程序。</p>
<p><strong>Virtual Host：</strong>虚拟主机，表示一批<strong>交换器</strong>、<strong>消息队列</strong>和<strong>相关对象</strong>。<u>虚拟主机是共享相同的身份认证和加密环境的独立服务器域</u>。每个<strong>虚拟主机</strong>本质上就是一个mini版的RabbitMQ服务器，拥有自己的<strong>队列</strong>、<strong>交换器</strong>、<strong>绑定</strong>和<strong>权限机制</strong>。<strong>虚拟主机</strong>是AMQP概念的基础，必须在连接时指定，RabbitMQ<strong>默认的虚拟主机是/</strong>。</p>
<p><strong>Broker：</strong>表示消息队列服务器实体。</p>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>AMQP中的消息路由过程和Java开发者熟悉的JMS存在一些差别，AMQP中增加了<font color=red><strong>Exchange</strong></font>和<font color=red><strong>Binding</strong></font>的角色，<strong>生产者</strong>把<strong>消息</strong>发布到<strong>Exchange</strong>上，<strong>消息</strong>最终到达<strong>队列</strong>并被<strong>消费者</strong>接收，而<strong>Binding</strong>决定<strong>交换器</strong>的<strong>消息</strong>应该发送到哪个<strong>队列</strong>。</p>
<p><a href="https://imgchr.com/i/Kmn2TJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/10/19/Kmn2TJ.png" alt="Kmn2TJ.png"></a></p>
<h4 id="Exchange："><a href="#Exchange：" class="headerlink" title="Exchange："></a><font color=red>Exchange：</font></h4><p>分发消息时根据<strong>交换器类型</strong>的不同分发策略有区别，之前说过共有四种交换器类型：<font color=red><strong>direct、fanout、topic、headers（很少用）。</strong></font>header匹配AMQP消息的<strong>header</strong>而不是<strong>路由键</strong>，headers交换器和direct交换器完全一致，但性能差很多，目前几乎用不到了，所以着重学习另外三种类型：</p>
<h5 id="DirectExchange"><a href="#DirectExchange" class="headerlink" title="DirectExchange"></a>DirectExchange</h5><p><img src="https://s2.ax1x.com/2019/10/19/KmMDSI.png" alt="KmMDSI.png"></p>
<p>消息中<strong>路由键(routing key)</strong>如果和<strong>Binding</strong>中的<strong>binding key</strong>一致，<strong>交换器</strong>就将<strong>消息</strong>发送到对应的<strong>队列</strong>中。<font color=red><strong>路由键</strong>与<strong>队列名</strong>必须完全匹配</font>，如果一个<strong>队列</strong>绑定到<strong>交换器</strong>要求<strong>路由键</strong>为“dog”，则其转发<strong>routing key</strong>标记为“dog”的消息，不会转发“dog.puppy”，也不转发”dog.guard”等等。<font color=red>它是完全匹配、单播的模式</font>，典型的点对点通信模型。</p>
<h5 id="FanoutExchange"><a href="#FanoutExchange" class="headerlink" title="FanoutExchange"></a>FanoutExchange</h5><p><img src="https://s2.ax1x.com/2019/10/19/KmGXtO.png" alt="KmGXtO.png"></p>
<p>每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。fanout交换器不处理路由键，只是简单的将队列绑定到交换器上，<font color=red>每个发送到<strong>交换器</strong>的消息都会被转发到与该交换器绑定的<strong>所有队列</strong>上</font>。很像<font color=red>子网广播，每台子网内的主机都获得了一份赋值的消息</font>。fanout类型转发消息是最快的。这也是JMS里面发布/订阅模型一个参考实现。</p>
<h5 id="TopicExchange"><a href="#TopicExchange" class="headerlink" title="TopicExchange"></a>TopicExchange</h5><p><img src="https://s2.ax1x.com/2019/10/19/KmGjhD.png" alt="KmGjhD.png"></p>
<p>topic交换器<font color=red>通过<strong>模式匹配</strong>分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。</font>它将路由键和绑定建的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符“#”和“<em>”，#匹配0个或多个任意单词，\</em>匹配一个任意单词。</p>
<hr>
<p>RabbitMq的安装和测试就不记录了，网上教程很多很详细，各种问题大多也都有解决方案。</p>
<p>接下来另起新篇，记录简单的SpringBoot整合RabbitMQ！</p>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot与缓存</title>
    <url>/2020/03/15/SpringBoot%E4%B8%8E%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>为Redis整合做好准备<a id="more"></a></p>
<h2 id="JSR107缓存规范"><a href="#JSR107缓存规范" class="headerlink" title="JSR107缓存规范"></a>JSR107缓存规范</h2><p>Java Caching定义了5个核心接口，分别是<strong>CachingProvider</strong>, <strong>CacheManager</strong>, <strong>Cache</strong>, <strong>Entry</strong> 和 <strong>Expiry</strong>。</p>
<ul>
<li><strong>CachingProvider</strong>定义了创建、配置、获取、管理和控制多个<strong>CacheManager</strong>。一个应用可以在运行期访问多个CachingProvider。</li>
<li><strong>CacheManager</strong>定义了创建、配置、获取、管理和控制多个唯一命名的<strong>Cache</strong>，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。</li>
<li><strong>Cache</strong>是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。</li>
<li><strong>Entry</strong>是一个存储在Cache中的key-value对。</li>
<li><strong>Expiry</strong> 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/10/12/uOY5zq.png" alt="uOY5zq.png"></p>
<p><font color=red><strong>CacheManager</strong>管理多个Cache组件的，真正对缓存的CRUD操作在Cache组件中，每一个缓存组件有自己唯一一个名字。</font></p>
<h2 id="Spring缓存抽象"><a href="#Spring缓存抽象" class="headerlink" title="Spring缓存抽象"></a>Spring缓存抽象</h2><p>Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术，并支持使用JCache（JSR-107）注解简化我们开发。</p>
<ul>
<li><font color=red><strong>Cache</strong>接口是缓存组件的规范定义，包含缓存的各种操作集合，Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache , ConcurrentMapCache等等。。。</font></li>
<li>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/10/12/uOYoQ0.png" alt="uOYoQ0.png"></p>
<p>使用Spring缓存抽象时我们需要关注以下两点：</p>
<ol>
<li><u>确定方法需要被缓存以及他们的缓存策略。</u></li>
<li><u>从缓存中读取之前缓存存储的数据。</u></li>
</ol>
<h2 id="SpringBoot缓存工作原理"><a href="#SpringBoot缓存工作原理" class="headerlink" title="SpringBoot缓存工作原理"></a>SpringBoot缓存工作原理</h2><h3 id="浅读源码："><a href="#浅读源码：" class="headerlink" title="浅读源码："></a>浅读源码：</h3><ol>
<li><p>首先肯定是从自动配置入手，如果还不了解SpringBoot自动配置原理的同学可以参考之前的博文<a href="https://jerrymouse1998.github.io/post/springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/">《SpringBoot自动配置》</a>，按照自动配置的原理来说，应该有一个CacheAutoConfiguration的类：</p>
<p><img src="https://s2.ax1x.com/2019/10/10/u7wshR.png" alt="u7wshR.png"></p>
</li>
<li><p>这个类上有一个注解@Import导入了一个CacheConfigurationImportSelector内部类，这个内部类有一个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">    CacheType[] types = CacheType.values();</span><br><span class="line">    String[] imports = <span class="keyword">new</span> String[types.length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; types.length; ++i) &#123;</span><br><span class="line">        imports[i] = CacheConfigurations.getConfigurationClass(types[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> imports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>return前打上断点，debug一下发现：</p>
<p><img src="https://s2.ax1x.com/2019/10/10/u7w074.png" alt="u7w074.png"></p>
<p>不少名字都很眼熟JCache(JSR-107)、EhCache、Redis。。。</p>
</li>
<li><p>这么多的配置类，要用哪个呢？例如GenericCacheConfiguration配置类上：</p>
<p><img src="https://s2.ax1x.com/2019/10/10/u7wDAJ.png" alt="u7wDAJ.png"></p>
<p>配置类上都注解了各种条件，条件满足时才会匹配该配置类。</p>
<p>可以在配置文件中加入<font color=red>debug=true</font>，启动时就会加载自动配置报告：</p>
<p><img src="https://s2.ax1x.com/2019/10/10/u7wUXT.png" alt="u7wUXT.png"></p>
<p>这里就是默认情况：SimpleCacheConfiguration配置类会匹配并生效。<u>（如果引入Redis依赖并使用了，这里应该匹配的就是RedisCacheConfiguration。）</u></p>
</li>
<li><p>SimpleCacheConfiguration配置类会给容器注册一个CacheManager[ConcurrentMapCacheManager]:</p>
<p><img src="https://s2.ax1x.com/2019/10/10/u7wrN9.png" alt="u7wrN9.png"></p>
</li>
<li><p>ConcurrentMapCacheManager可以获取和创建ConcurrentMapCache类型的缓存组件，缓存组件会将数据保存在ConcurrentMap中。</p>
</li>
</ol>
<h3 id="Cacheable运行流程"><a href="#Cacheable运行流程" class="headerlink" title="@Cacheable运行流程:"></a><font color=red>@Cacheable运行流程:</font></h3><hr>
<p>本篇仅以@Cacheable为例，简述其注解的运行流程：</p>
<ol>
<li>方法运行之前，先查询Cache（缓存组件），按照cacheNames属性指定的名字获取。CacheManager先获取相应的缓存，第一次获取缓存如果没有，Cache组件会自动创建。</li>
<li>使用一个key去Cache中查找缓存的内容，这个key默认就是方法的参数，使用keyGenerator生成的。上例中，默认使用SimpleKeyGenerator生成key，SimpleKeyGenerator生成key的默认策略：<ul>
<li>如果没有参数：key=new SimpleKey()；</li>
<li>如果有一个参数：key=参数的值</li>
<li>如果有多个参数：key=new SimpleKey(params)；</li>
</ul>
</li>
<li>没有查到缓存就调用目标方法。</li>
<li>将目标方法返回的结果，放进缓存中。</li>
</ol>
<p><font color=red>@Cacheable标注的方法执行之前，首先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，如果没有数据就运行方法并将结果放入缓存，以后再来调用就可以直接使用缓存中的数据。</font></p>
<p><strong>总结：</strong></p>
<ol>
<li>使用CacheManager[ConcurrentMapCacheManager]按照名字得到Cache[ConcurrentMapCache]组件。</li>
<li>用keyGenerator生成key，默认是SimpleKeyGenerator。</li>
</ol>
<h3 id="常用的注解："><a href="#常用的注解：" class="headerlink" title="常用的注解："></a>常用的注解：</h3><p><img src="https://s2.ax1x.com/2019/10/10/u7wdnU.png" alt="u7wdnU.png"></p>
<h4 id="Cacheable："><a href="#Cacheable：" class="headerlink" title="@Cacheable："></a>@Cacheable：</h4><p><font color=red>使用注解时，至少要指定一个cacheNames属性，不然抛异常。</font></p>
<p><font color=red><strong>@Cacheable注解是在目标方法执行之前生效。</strong></font></p>
<ul>
<li><strong>cacheNames/value</strong>:指定缓存组件的名字;将方法的返回值放在哪个缓存中，是数组的方式，可以指定多个缓存。</li>
<li><strong>key</strong>:缓存数据使用的key;可以用它来指定。默认是使用方法参数的值。这里可以使用SpEL。</li>
<li><strong>keyGenerator</strong>: key的生 成器;可以自己指定key的生成器的组件id，但是key/keyGenerator:二选一使用。</li>
<li><strong>cacheManager</strong>:指定缓存管理器:或者cacheResolver指定获取解析器</li>
<li><strong>condition</strong>:指定符合条件的情况下才缓存:</li>
<li><strong>unless</strong>:否定缓存;当unless指定的条件为true,方法的返回值就不会被缓存，可以获取到结果进行判断unless=”#result == null”。</li>
<li><strong>sync</strong>:是否使用异步模式</li>
</ul>
<h4 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h4><p>既调用方法，又更新缓存数据，同步更新缓存。<font color=red><strong>@CachePut注解是在目标方法执行之后起作用的。</strong></font></p>
<p><strong>看一个例子并思考：</strong></p>
<p>controller、dao层代码省略，主要是看service代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userDao.selectUserById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@CachePut</span>(value = <span class="string">"user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    userDao.updateUser(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先根据id=133查询请求，因为是第一次查询该数据，所以请求数据库获取结果，并将结果存入缓存，再次发起同一个请求，控制台显示没有访问数据库，而是直接从缓存中取出数据。</li>
<li>发起根据id=133更新请求，查看数据库数据更新成功，因为有@CachePut注解，所以更新后的数据，应该也同步更新到了缓存中。</li>
<li>为了验证缓存中数据是否同步更新了，再次发起根据id=133查询请求，从控制台看出依然没有访问数据库而是从缓存中获取了数据，但是，数据仍然是没更新前的！！！</li>
</ol>
<p><font color=red><strong>难道@CachePut注解没有同步更新缓存么？</strong></font></p>
<p>原因：查询方法和更新方法的缓存操作注解中都<strong>没有指定key</strong>，所以是使用默认的key生成策略(方法参数列表作为key)，因此查询操作时缓存中存入的是：key是id(133)，value是方法返回的User对象。更新操作时缓存了：key是参数user对象，value是方法返回的User对象。这就是为什么查询id=133的数据时发现“缓存没有同步更新”的假象。</p>
<p><font color=red><strong>解决方法：</strong></font></p>
<p>可以在注解中用SpEl指定key，使两次缓存的数据的key保持一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>,key = <span class="string">"#id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userDao.selectUserById(id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CachePut</span>(value = <span class="string">"user"</span>,key = <span class="string">"#user.id"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    userDao.updateUser(user);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新进行上述中的验证步骤，发现缓存中同步更新了。</p>
<h4 id="CacheEvict："><a href="#CacheEvict：" class="headerlink" title="@CacheEvict："></a>@CacheEvict：</h4><p>清除缓存，依然可以需要用value指定缓存组件名和key指定要清除的数据。</p>
<p><strong>allEntries：</strong>该属性默认是false，如果该属性设置为true，会清除指定缓存组件中的所有数据，就不需要指定key了。</p>
<p><strong>beforeInvocation：</strong>该属性默认是false，代表缓存的清除工作在方法执行之后进行，如果方法出现异常，则缓存就不会清除。如果将该属性设置为true，缓存的清除工作在方法执行之前进行，即使方法出现异常，缓存依然会清除。</p>
<h4 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Caching &#123;</span><br><span class="line">    Cacheable[] cacheable() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    CachePut[] put() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    CacheEvict[] evict() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该注解是@Cacheable、@CachePut和@CacheEvict三个注解的合体，当一些缓存的规则比较复杂时可以使用此注解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Caching</span>(</span><br><span class="line">        cacheable = &#123;</span><br><span class="line">                <span class="meta">@Cacheable</span>(value = <span class="string">"user"</span>,key = <span class="string">"#username"</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        put = &#123;</span><br><span class="line">                <span class="meta">@CachePut</span>(value = <span class="string">"user"</span>,key = <span class="string">"#result.id"</span>),</span><br><span class="line">                <span class="meta">@CachePut</span>(value = <span class="string">"user"</span>,key = <span class="string">"#result.address"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">selectUserByUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userDao.selectUserByUsername(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当该方法执行之后，方法返回值会分别以id、address、username作为key进行缓存，当其他带有缓存操作的方法以id或者addresss再次查询该条数据时，就不需要再访问数据库了。<font color=red><strong>但是,</strong>如果再次调用该方法以username进行查询时，依然会访问数据库，<strong>因为</strong>存在@CachePut注解，无论缓存中有无数据都会执行方法。</font></p>
<h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a>@CacheConfig</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheConfig &#123;</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前使用缓存注解时每次都要分别指定value、keyGenerator、cacheManager、cacheResolver,这样是很麻烦而且不科学的。于是@CacheConfig就可以排上用场了。</p>
<p>在类上加@CacheConfig并设置上述四个属性，则方法中就不需要再进行指定了。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot中使用JSP</title>
    <url>/2020/03/15/SpringBoot%E4%BD%BF%E7%94%A8JSP/</url>
    <content><![CDATA[<p>SpringBoot内部对jsp的支持并不是很理想，而SpringBoot推荐的视图是Thymeleaf、FreeMarker。但是我更加喜欢使用jsp(因为我不会用Thymeleaf)，所以学习一下SpringBoot中使用JSP视图。<a id="more"></a></p>
<h3 id="创建项目："><a href="#创建项目：" class="headerlink" title="创建项目："></a>创建项目：</h3><p>创建项目没有太多特别的地方，要注意的是打包方式要选择打成war包</p>
<p><img src="https://s2.ax1x.com/2019/09/11/nd7tER.png" alt="nd7tER.png"></p>
<p>然后可以根据自己的需求选择预先加入工程的依赖，我这里选择了web、mysql、mybatis。</p>
<p>创建出来的项目目录：</p>
<p><img src="https://s2.ax1x.com/2019/09/11/nd7NU1.png" alt="nd7NU1.png"></p>
<p>可以发现和上一篇文章<a href="https://jerrymouse1998.github.io/post/springboot入门/">《SpringBoot入门》</a>创建的目录相比多了一个ServletInitializer类，打开这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletInitializer</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SpringApplicationBuilder <span class="title">configure</span><span class="params">(SpringApplicationBuilder application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> application.sources(SpringbootJspApplication<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现它继承了<strong>SpringBootServletInitializer</strong>这个父类，而<strong>SpringBootServletInitializer</strong>这个类是<strong>springboot</strong>提供的<strong>web</strong>程序初始化的入口，当我们使用外部容器运行web项目时会自动加载并且装配（不使用SpringBoot内置的tomcat时也需要这个）。这是一个类似于web.xml配置的方式启动spring应用。</p>
<p>实现了<strong>SpringBootServletInitializer</strong>的子类需要重写一个<strong>configure</strong>方法，方法内自动根据<strong>SpringbootJspApplication.class</strong>的类型创建一个<strong>SpringApplicationBuilder</strong>交付给<strong>springboot</strong>框架来完成初始化运行配置。</p>
<h4 id="完善项目目录："><a href="#完善项目目录：" class="headerlink" title="完善项目目录："></a>完善项目目录：</h4><p>之前MVC的时候jsp页面一般都放在/webapp/WEB-INF/jsp目录下，现在我依然沿用这种习惯的方式。</p>
<p>在main目录下创建/webapp/WEB-INF/jsp目录，springboot会自动的将webapp设置到Models中,webapp文件夹如果没有那个小蓝点的话，需要手动进行Models的设置哦。完善之后的目录：</p>
<p><img src="https://s2.ax1x.com/2019/09/11/ndvYhd.png" alt="ndvYhd.png"></p>
<hr>
<h3 id="添加依赖："><a href="#添加依赖：" class="headerlink" title="添加依赖："></a>添加依赖：</h3><p>添加jsp的maven依赖、jsp对servlet容器的支持、jsp中要用的jstl标签依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.tomcat.embed/tomcat-embed-jasper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="编写application-properties："><a href="#编写application-properties：" class="headerlink" title="编写application.properties："></a>编写application.properties：</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DB连接四大参数</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123</span></span><br><span class="line"><span class="comment">#Mybatis配置</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">nynu.li.springboot_jsp.pojo</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">nynu/lis/pringboot_jsp/dao/*dao.xml</span></span><br><span class="line"><span class="comment">#MVC的视图解析器，这两个属性很熟悉了</span></span><br><span class="line"><span class="meta">spring.mvc.view.prefix</span>=<span class="string">/WEB-INF/jsp</span></span><br><span class="line"><span class="meta">spring.mvc.view.suffix</span>=<span class="string">.jsp</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="编写后端代码："><a href="#编写后端代码：" class="headerlink" title="编写后端代码："></a>编写后端代码：</h3><p>Pojo、Controller、Service、Dao。。。和之前MVC时一样，进行简单的编写查询数据库中全部用户的信息，然后在jsp页面表格中展示。具体的代码就不在赘述了，不会的话，可以参考之前的文章。</p>
<p>直接点击启动类运行，两三秒就启动成功了！！！发起请求，一切正常！！！SpringBoot真的太简洁了！！！其他的框架Mybatis等等，只要整合了SpringBoot之后一切都变得明朗了！！！</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot使用转换器和拦截器</title>
    <url>/2020/03/15/SpringBoot%E4%BD%BF%E7%94%A8%E8%BD%AC%E6%8D%A2%E5%99%A8%E5%92%8C%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<p>上一次主要介绍了转换器和拦截器的一般实现方法和在<strong>SSM套装中的配置方法</strong>。这次记录一下在<strong>SpringBoot</strong>中使用二者的方法和一些问题。<a id="more"></a></p>
<h3 id="拦截器："><a href="#拦截器：" class="headerlink" title="拦截器："></a>拦截器：</h3><p>首先实现一个登录校验拦截器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"><span class="comment">//  在controller之前调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (request.getSession().getAttribute(<span class="string">"loginUser"</span>)==<span class="keyword">null</span>)&#123;</span><br><span class="line">            request.getSession().setAttribute(<span class="string">"message"</span>,<span class="string">"请登录"</span>);</span><br><span class="line">            request.getRequestDispatcher(<span class="string">"WEB-INF/jsp/login.jsp"</span>).forward(request,response);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    此方法在controller调用之后，跳转视图之前</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    整个请求结束之后调用此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个配置类去继承WebMvcConfigurationSupport，并且重写父类的addInterceptors(InterceptorRegistry registry)方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> UserInterceptor()).addPathPatterns(<span class="string">"/**"</span>).excludePathPatterns(<span class="string">"/login"</span>,<span class="string">"/toLogin"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动！拦截器就会生效了！</p>
<p><font color=red>但是,这里有一个很讨厌的情况就出现了！之前好好的视图都解析失败了(之前properties中配置的视图解析器失效了)！原因应该是：手动创建了配置类后WebMvcConfigurationSupport创建了新的ViewResolver！</font></p>
<p><font color=red>那就尝试在配置类中加入下列代码，自定义一个ViewResolver：</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewResolver <span class="title">getViewResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">    InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">    resolver.setPrefix(<span class="string">"/WEB-INF/jsp/"</span>);</span><br><span class="line">    resolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">    <span class="keyword">return</span> resolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题得到了解决！但是值得吐槽！</p>
<hr>
<h3 id="转换器："><a href="#转换器：" class="headerlink" title="转换器："></a>转换器：</h3><p>最基础的、也很常用的时间转换器作为例子。</p>
<p>常见的几种日期格式化的情况：</p>
<ol>
<li><p>jsp中使用JSTL的format标签库在<strong>前端进行日期格式化</strong>：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;fmt:formatDate value=<span class="string">"$&#123;user.creattime&#125;"</span> pattern=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>application.properties中对请求处理器的JSON返回值的日期的格式化配置，前端拿到后不需要处理就获的已格式化的日期：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#格式化时间</span></span><br><span class="line"><span class="meta">spring.jackson.date-format</span>=<span class="string">yyyy/MM/dd hh:mm:ss</span></span><br><span class="line"><span class="meta">spring.jackson.time-zone</span>=<span class="string">GMT+8</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用转换器：后端处理器接收到的前端传参来的日期<strong>一般是String类型</strong>的，<strong>不能</strong>直接自动赋值给后端的<strong>Date格式</strong>的变量，这时就要用到自定义Converter了！SpringBoot和SpringMVC使用转换器的区别：</p>
<p>区别很明显！SpringBoot<strong>不需要</strong>进行xml配置！！直接在实现的dateConverter上加上<strong>@Component</strong>注解，SpringBoot默认的自动配置就会将实现的dateConverter扫描并加载到容器中以备使用！当前端传回来Sring类型的日期时，自动会进到dateConverter中调用convert()方法进行解析格式化！</p>
<p>转换器的介绍和实现方法在开头链接博文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Component</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">           SimpleDateFormat sdf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd hh:mm:ss"</span>);</span><br><span class="line">           Date date = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               date = sdf.parse(s);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> date;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行时通过Debug发现，dateConverter已经自动被扫描和加载了：</p>
</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/09/16/nfTzZ9.png" alt="nfTzZ9.png"></p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot配置方法总结</title>
    <url>/2020/03/15/SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>SpringBoot的一大好处就是：大大简化了Spring和其他框架和Spring整合时的配置，传统的SSM套装虽然很大程度地简化了Web开发，但是其的配置文件却较为繁琐，为了简化配置文件使开发者更专注于业务编码(懒)可以使用SpringBoot来进行web开发，其精简的配置和庞大繁茂的生态圈绝对令人惊叹！<a id="more"></a></p>
<p>SpringBoot之所以可以达到如此精简的配置，主要原因就是SpringBoot大量的<strong>自动配置</strong>！！！</p>
<h2 id="自动配置原理："><a href="#自动配置原理：" class="headerlink" title="自动配置原理："></a>自动配置原理：</h2><ol>
<li><p>SpringBoot应用从启动类的main方法中启动，加载SpringBoot<strong>主配置类</strong>(依赖@Sprin<strong>gBootApplication</strong>注解)，主配置类(@SpringBootApplication)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br><span class="line">	。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启<strong>自动配置</strong>功能(依赖<strong>@EnableAutoConfiguration</strong>注解):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line">	。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用<strong>选择器</strong>(<strong>@Import(AutoConfigurationImportSelector.class</strong>))获取候选配置，给容器导入一些组件：</p>
<p>查看<strong>AutoConfigurationImportSelector类</strong>的<strong>public String[] selectImports(AnnotationMetadata annotationMetadata)</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">      <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">   &#125;</span><br><span class="line">   AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">   AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,annotationMetadata);</span><br><span class="line">   <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<strong>selectImports</strong>方法间接调用<strong>getCandidateConfigurations(annotationMetadata, attributes)</strong>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">   List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">         getBeanClassLoader());</span><br><span class="line">   Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">         + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">   <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再调用<strong>SpringFactoriesLoader类</strong>的**loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</p>
<pre><code>getBeanClassLoader())**方法去扫描所有jar包类路径下的:</code></pre><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF /spring.factories"</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2019/09/18/n7ASED.png" alt="n7ASED.png"></p>
<p><a href="https://imgchr.com/i/n7AwG9" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/09/18/n7AwG9.md.png" alt="n7AwG9.md.png"></a></p>
<p>把扫描到的properties文件的内容包装成properties对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">        MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line">                LinkedMultiValueMap result = <span class="keyword">new</span> LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(urls.hasMoreElements()) &#123;</span><br><span class="line">                    URL url = (URL)urls.nextElement();</span><br><span class="line">                    UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">                    Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                    Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                        Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">                        String factoryClassName = ((String)entry.getKey()).trim();</span><br><span class="line">                        String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                        <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                            String factoryName = var9[var11];</span><br><span class="line">                            result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cache.put(classLoader, result);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load factories from location [META-INF/spring.factories]"</span>, var13);</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从包装好的properties中获取到<strong>EnableAutoConfiguration.class类(类名)对应的值</strong>，然后把它们添加到容器中去。</p>
</li>
</ol>
<p><font color=red><strong>☆上面这五个步骤大致讲述了SpringBoot自动配置的原理，可能还是比较抽象不易理解，接下来用一个例子再次具体分析理解☆</strong></font></p>
<p>spring.factories中每一个XXXAutoConfiguration类都是容器中的一个组件，都加入到容器中，用他们来做自动配置。每一个XXX自动配置类都可以进行自动配置功能，举个简单的例子(HttpEncodingAutoConfiguration):</p>
<p>首先找到HttpEncodingAutoConfiguration类：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//表明这是一个配置类，像编写配置文件一样，也可以向容器中添加组件</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//启动指定类的ConfigurationProperties功能，</span></span><br><span class="line"><span class="comment">//将配置文件中对应的值和HttpProperties绑定起来，并将HttpProperties加入Ioc容器</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//<span class="title">Spring</span>底层的@<span class="title">Conditional</span>注解，根据不同的条件，如果满足指定的条件</span></span><br><span class="line"><span class="class">//整个配置类里面的配置就会生效；判断当前应用是否是<span class="title">web</span>应用，如果是，则配置类生效</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span>(<span class="title">type</span> </span>= ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="comment">//判断当前项目有没有CharacterEncodingFilter这个类</span></span><br><span class="line"><span class="comment">//SpringMvc中CharacterEncodingFilter这个类一般是配置Web.xml中解决乱码的过滤器</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//判断配置文件中是否存在某个配置<span class="title">spring</span>.<span class="title">http</span>.<span class="title">encoding</span>.<span class="title">enabled</span></span></span><br><span class="line"><span class="class">//<span class="title">matchIfMissing</span> </span>= <span class="keyword">true</span>如果不存在，判断也成立，</span><br><span class="line"><span class="comment">//即使配置文件中不配置spring.http.encoding.enabled=true，也是默认生效的</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">//他的值已经和配置文件映射了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpProperties.Encoding properties;</span><br><span class="line">	<span class="comment">//只有一个有参构构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpProperties properties)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.properties = properties.getEncoding();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">//给容器添加一个组件，这些组件的某些值需要从Properties中获取</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">		filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">		filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">								filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br><span class="line">    等等方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   根据当前不同的条件判断，决定这个配置类是否生效：一旦这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，properties类里面的每一个属性又是和配置文件绑定的。</p>
<p>   来看一看HttpProperties类：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http"</span>)<span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> logRequestDetails;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Encoding encoding = <span class="keyword">new</span> Encoding();</span><br><span class="line">	<span class="comment">//getter/setter/is等等方法。。。 </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Encoding</span> </span>&#123;<span class="comment">//这里有一个Encoding静态内部类</span></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;</span><br><span class="line">		<span class="keyword">private</span> Charset charset = DEFAULT_CHARSET;</span><br><span class="line">		<span class="keyword">private</span> Boolean force;</span><br><span class="line">		<span class="keyword">private</span> Boolean forceRequest;</span><br><span class="line">		<span class="keyword">private</span> Boolean forceResponse;</span><br><span class="line">		<span class="keyword">private</span> Map&lt;Locale, Charset&gt; mapping;</span><br><span class="line">        <span class="comment">//getter/setter/is等等方法。。。 </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时在我们的application.properties文件中加一条配置：</p>
   <figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.http.encoding.charset</span>=<span class="string">utf-8</span></span><br></pre></td></tr></table></figure>

<p>ctrl左键这个Key，发现居然跳到了上面HttpProperties类的Encoding静态内部类的setCharset(Charset charset)方法！！这下子恍然大悟了！当然这只是大量组件中较为简单的一个，但是每个组件的自动配置逻辑大同小异，只有掌握了SpringBoot的这一精髓，才能更好对其他的细节进行深入理解！</p>
<hr>
<h2 id="自定义配置方法"><a href="#自定义配置方法" class="headerlink" title="自定义配置方法"></a>自定义配置方法</h2><p>用户很多时候不可避免的进行自定义配置，SpringBoot除了自动配置，理所当然的支持用户的自定义配置！</p>
<p>SpringBoot的自定义配置主要有两种：1.使用配置文件进行外部属性配置。2.用配置类进行配置。</p>
<p>接下来对两种配制方法展开说明：</p>
<h3 id="1-使用配置文件进行外部属性配置："><a href="#1-使用配置文件进行外部属性配置：" class="headerlink" title="1.使用配置文件进行外部属性配置："></a>1.使用配置文件进行外部属性配置：</h3><p>SpringBoot中比较常见且推荐的是<strong>.properties</strong>和<strong>.yml</strong>两种配置文件。</p>
<blockquote>
<p>想知道配置文件中所有可配属性，可以在SpringBoot官方说明文档中找到<a href="https://docs.spring.io/spring-boot/docs/2.1.8.RELEASE/reference/html/common-application-properties.html" target="_blank" rel="noopener"> Common application properties</a>——SpringBoot2.1.8</p>
</blockquote>
<p>YAML是JSON的一个超集，可以将外部配置以层次结构形式存储起来。当项目的类路径中用SnakeYAML库(spring-boot-starter中已经被包含)时，SpringApplication类将自动支持YAML作为properties的替代。所以在优先级上<strong>YAML&gt;properties</strong>。</p>
<p>YAML的数据格式和JSON很像，都是树状结构都是K-V格式，并通过“：”进行赋值。</p>
<p>properties文件中以”.”进行分割的，在yml文件中用”:”进行分割的。yml文件的每个”:”后面一定都要加一个空格，否则文件会报错。</p>
<h4 id="Value和-ConfigurationProperties："><a href="#Value和-ConfigurationProperties：" class="headerlink" title="@Value和@ConfigurationProperties："></a>@Value和@ConfigurationProperties：</h4><p>可以在编写代码时在属性上使用@Value($(key))来取值并对被注解的属性赋值，也可以在类上使用@ConfigurationProperties(prefix=”xxx”)注解取出所有以xxx为前缀的key所对应的值来对被注解类的属性进行匹配并赋值。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>
<tbody><tr>
<td>松散绑定(松散语法)</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>无论是yml文件还是properties文件，这两个注解都能获取到值。</p>
<p>如果只是某个业务逻辑中需要获取一下配置文件中的某个值，建议使用@Value。</p>
<p>如果是编写一个JavaBean和配置文件进行映射，建议直接用@ConfigurationProperties。</p>
<h4 id="PropertySesource和-ImportResource："><a href="#PropertySesource和-ImportResource：" class="headerlink" title="@PropertySesource和@ImportResource："></a>@PropertySesource和@ImportResource：</h4><p>上面介绍的两个注解都是默认从<strong>默认全局配置文件</strong>(application.properties或application.yml)中读取值，如果需要加载指定配置文件中的值，则需要使用<strong>@PropertySesource(value = {“classpath：xxx.propertiex”},…..)</strong>来指定需要加载的一个或多个配置文件。</p>
<p>在使用springboot的时候一般是极少需要添加配置文件的(application.properties除外)，但是在实际应用中也会存在不得不添加配置文件的情况，例如集成其他框架或者需要配置一些中间件等，在这种情况下，我们就需要引入我们自定义的xml配置文件了。在SpringBoot中<strong>依然支持xml文件</strong>的配置方式。但是需要在<strong>启动类</strong>上加<strong>@ImportResource(locations = {“classpath:xxx.xml”},…..)</strong>注解来指定一个或多个xml文件的位置从而对框架或中间件进行配置。</p>
<hr>
<h3 id="2-用配置类进行配置："><a href="#2-用配置类进行配置：" class="headerlink" title="2.用配置类进行配置："></a>2.用配置类进行配置：</h3><h4 id="WebMvcConfigurationSupport"><a href="#WebMvcConfigurationSupport" class="headerlink" title="WebMvcConfigurationSupport"></a>WebMvcConfigurationSupport</h4><p>SpringBoot2.0之后建议自定义配置类继承<strong>WebMvcConfigurationSupport</strong>，在自定义配置类上加上<strong>@Component</strong>注解就可以自动扫描到配置类并加载了。</p>
<p><strong>WebMvcConfigurationSupport</strong>这个类中提供了很多很多方法大多数方法都是顾名思义：处理器异常解析器、添加拦截器等等。。。很多很便利的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加自定义拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> UserInterceptor()).addPathPatterns(<span class="string">"/**"</span>).excludePathPatterns(<span class="string">"/login"</span>,<span class="string">"/toLogin"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自定义视图解析器，使用这个配置类之后properties文件中配置的视图解析器就失效了</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">getViewResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InternalResourceViewResolver resolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">        resolver.setPrefix(<span class="string">"/WEB-INF/jsp/"</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h4><p>可以对配置类中的方法进行注解，将方法的返回值添加到容器中，容器中这个组件默认的id就是方法名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserService <span class="title">userService01</span><span class="params">()</span></span>&#123;<span class="comment">//容器中就会加入一个UserService类型的组件，id是userService01</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC中的非集合参数绑定</title>
    <url>/2020/03/15/SpringMVC%E4%B8%AD%E7%9A%84%E9%9D%9E%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>默认支持、Model/ModelMap、绑定简单类型、pojo、自定义类型<a id="more"></a></p>
<h2 id="1-绑定默认支持的参数类型"><a href="#1-绑定默认支持的参数类型" class="headerlink" title="1.绑定默认支持的参数类型"></a>1.绑定默认支持的参数类型</h2><p><font color="red">处理器形参中添加如下类型的参数<strong>处理适配器</strong>会<strong>默认识别</strong>并<strong>进行赋值</strong>。</font></p>
<h3 id="1-1-HttpServletRequest"><a href="#1-1-HttpServletRequest" class="headerlink" title="1-1 HttpServletRequest"></a>1-1 HttpServletRequest</h3><p>通过request对象获取请求信息。（例如：如果需要从请求中把参数取出来，只需要在Controller方法的形参中添加一个参数即可，Springmvc框架会自动把Request对象传递给方法。）</p>
<h3 id="1-2-HttpServletResponse"><a href="#1-2-HttpServletResponse" class="headerlink" title="1-2 HttpServletResponse"></a>1-2 HttpServletResponse</h3><p>通过response处理响应信息。</p>
<h3 id="1-3-HttpSession"><a href="#1-3-HttpSession" class="headerlink" title="1-3 HttpSession"></a>1-3 HttpSession</h3><p>通过session对象得到session中存放的对象。</p>
<hr>
<h2 id="2-Model-ModelMap"><a href="#2-Model-ModelMap" class="headerlink" title="2. Model/ModelMap"></a>2. Model/ModelMap</h2><h3 id="2-1-Model"><a href="#2-1-Model" class="headerlink" title="2-1 Model"></a>2-1 Model</h3><p>除了ModelAndView以外，还可以使用Model来向页面传递数据，Model是一个接口，在参数里直接声明model即可。</p>
<p><font color="red"><u><strong>如果使用Model则可以不使用ModelAndView对象</strong></u>，<u><strong>Model对象可以向页面传递数据</strong></u>，<u><strong>View对象则可以使用String返回值替代</strong></u>。</font></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id查询商品,使用Model</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/itemEdit.action"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryItemById</span><span class="params">(HttpServletRequest request, Model model)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从request中获取请求参数</span></span><br><span class="line">	String strId = request.getParameter(<span class="string">"id"</span>);</span><br><span class="line">	Integer id = Integer.valueOf(strId);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据id查询商品数据</span></span><br><span class="line">	Item item = <span class="keyword">this</span>.itemService.queryItemById(id);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 把结果传递给页面</span></span><br><span class="line">	<span class="comment">// ModelAndView modelAndView = new ModelAndView();</span></span><br><span class="line">	<span class="comment">// 把商品数据放在模型中</span></span><br><span class="line">	<span class="comment">// modelAndView.addObject("item", item);</span></span><br><span class="line">	<span class="comment">// 设置逻辑视图</span></span><br><span class="line">	<span class="comment">// modelAndView.setViewName("itemEdit");</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 把商品数据放在模型中,相当于ModelAndView.addObject（name，value）</span></span><br><span class="line">	model.addAttribute(<span class="string">"item"</span>, item);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相当于ModelAndView.setViewName("viewName")</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"itemEdit"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-ModelMap"><a href="#2-2-ModelMap" class="headerlink" title="2-2 ModelMap"></a>2-2 ModelMap</h3><p>ModelMap是Model接口的实现类，也可以通过ModelMap向页面传递数据。</p>
<p><font color="red"><u><strong>使用ModelMap和Model的用法和效果一样，如果直接使用Model，springmvc会实例化ModelMap。</strong></u></font></p>
<hr>
<h2 id="3-绑定简单类型"><a href="#3-绑定简单类型" class="headerlink" title="3. 绑定简单类型"></a>3. 绑定简单类型</h2><h3 id="3-1-请求中参数名称和处理器形参名称一致"><a href="#3-1-请求中参数名称和处理器形参名称一致" class="headerlink" title="3-1 请求中参数名称和处理器形参名称一致"></a>3-1 请求中参数名称<strong>和</strong>处理器形参名<strong>称</strong>一致</h3><p>当<strong>请求的参数名称</strong>和<strong>处理器形参名</strong>称<strong>一致</strong>时会自动将请求参数与形参进行绑定。</p>
<p>这样，从Request取参数的方法就可以进一步简化。</p>
<h4 id="支持的数据类型："><a href="#支持的数据类型：" class="headerlink" title="支持的数据类型："></a>支持的数据类型：</h4><p>​                    整形：Integer、int</p>
<p>​                    字符串：String</p>
<p>​                    单精度：Float、float</p>
<p>​                    双精度：Double、double</p>
<p>​                    布尔型：Boolean、boolean</p>
<p><font color="red"><strong><u>说明：URL中对于布尔类型的参数，请求的参数值为true或false。或者1或0。</u></strong></font>    </p>
<p><font color="red"><strong><u>        参数类型推荐使用包装数据类型，因为基础数据类型不可以为null。</u></strong></font></p>
<h3 id="3-2-RequestParam"><a href="#3-2-RequestParam" class="headerlink" title="3-2 @RequestParam"></a>3-2 @RequestParam</h3><p>当<strong>请求的参数名称</strong>和<strong>处理器形参名</strong>称<strong>不一致</strong>时，可以使用注解进行绑定。</p>
<h4 id="注解的参数："><a href="#注解的参数：" class="headerlink" title="注解的参数："></a>注解的参数：</h4><p>​            <strong>value</strong>：参数名字，即入参的请求参数名字，如value=“itemId”表示请求的参数区中的名字为itemId的参数的值将传入。</p>
<p>​            <strong>required</strong>：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报错：<font color="red">TTP Status 400 - Required Integer parameter ‘XXXX’ is not present</font></p>
<p>​            <strong>defaultValue</strong>：默认值，表示如果请求中没有同名参数时的默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/itemEdit"</span>)</span><br><span class="line"><span class="comment">//将请求域中名为“itemId”的参数 和 方法中名为“id”的形参绑定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryItemById</span><span class="params">(@RequestParam(value = <span class="string">"itemId"</span>, required = <span class="keyword">true</span>, defaultValue = <span class="string">"1"</span>)</span> Integer id,</span></span><br><span class="line"><span class="function">		ModelMap modelMap) </span>&#123;</span><br><span class="line">	<span class="comment">// 根据id查询商品数据</span></span><br><span class="line">	Item item = <span class="keyword">this</span>.itemService.queryItemById(id);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 把商品数据放在模型中</span></span><br><span class="line">	modelMap.addAttribute(<span class="string">"item"</span>, item);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"itemEdit"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-绑定pojo类型"><a href="#4-绑定pojo类型" class="headerlink" title="4. 绑定pojo类型"></a>4. 绑定pojo类型</h2><h3 id="4-1-绑定普通pojo类型（属性中不含pojo类）"><a href="#4-1-绑定普通pojo类型（属性中不含pojo类）" class="headerlink" title="4-1 绑定普通pojo类型（属性中不含pojo类）"></a>4-1 绑定普通pojo类型（属性中不含pojo类）</h3><p>使用pojo接收表单数据,如果提交的参数很多，或者提交的表单中的内容很多的时候,可以使用简单类型接受数据,也可以使用pojo接收数据。</p>
<p><font color="red">要求：pojo对象中的属性名和表单中input的name属性一致。</font></p>
<p><strong>请求的参数名称</strong>和<strong>pojo的属性名称</strong>一致，会自动将请求参数赋值给pojo的属性。</p>
<h3 id="4-2-绑定包装pojo类型"><a href="#4-2-绑定包装pojo类型" class="headerlink" title="4-2 绑定包装pojo类型"></a>4-2 绑定包装pojo类型</h3><p>例如这种包装pojo类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String itemname;</span><br><span class="line">	<span class="keyword">private</span> Double price;</span><br><span class="line">	<span class="keyword">private</span> Date itemdate;</span><br><span class="line">	set/get。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryVo</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Item item;</span><br><span class="line">set/get。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>jsp表单中：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;tr&gt;</span><br><span class="line">    &lt;td&gt;&lt;input type="text" name="item.id"&gt;&lt;/td&gt;</span><br><span class="line">    &lt;td&gt;&lt;input type="text" name="item.itemname"&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>

<p><strong>controller中接收包装pojo类的值</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/queryItem"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">queryItem</span><span class="params">(QueryVo queryVo)</span> </span>&#123;</span><br><span class="line">		System.out.println(queryVo.getItem().getId());</span><br><span class="line">		System.out.println(queryVo.getItem().getItemname());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-自定义参数绑定"><a href="#5-自定义参数绑定" class="headerlink" title="5. 自定义参数绑定"></a>5. 自定义参数绑定</h2><p>例如，前端页面中修改商品的生产日期，并且根据业务需求自定义日期格式。</p>
<p>由于日期数据有很多种格式，springmvc没办法把字符串转换成日期类型。所以需要自定义参数绑定。</p>
<p><strong>前端控制器接</strong>收到请求后，找到注解形式的<strong>处理器适配器</strong>，<u>对RequestMapping标记的方法进行适配，并对方法中的形参进行参数绑定</u>。可以在<strong>springmvc处理器适配器</strong>上<strong>自定义转换器Converter</strong><u>进行参数绑定</u>。</p>
<p>一般使用<strong>mvc:annotation-driven</strong>标签注解驱动加载处理器适配器，可以在此标签上进行配置。</p>
<h3 id="5-1-如果使用MVC注解驱动的方式加载处理器适配器和处理器映射器："><a href="#5-1-如果使用MVC注解驱动的方式加载处理器适配器和处理器映射器：" class="headerlink" title="5-1. 如果使用MVC注解驱动的方式加载处理器适配器和处理器映射器："></a>5-1. 如果使用<strong>MVC注解驱动</strong>的方式加载<strong>处理器适配器</strong>和<strong>处理器映射器</strong>：</h3><p>先写一个日期转换器类（DateConverter），实现Converter&lt;S, T&gt;接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Converter&lt;S, T&gt;</span></span><br><span class="line"><span class="comment">//S:source,需要转换的源的类型</span></span><br><span class="line"><span class="comment">//T:target,需要转换的目标类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 把字符串转换为日期类型</span></span><br><span class="line">			SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">			Date date = simpleDateFormat.parse(source);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> date;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果转换异常则返回空</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以同时配置多个转换器，在springmvc.xml配置文件中进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置注解驱动 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果配置此标签,可以不用配置处理器适配器和处理器映射器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 转换器工厂配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">	  <span class="comment">&lt;!-- 自己写的转换器配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"nynu.converter.DateConverter"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="5-2-如果使用独立配置加载处理器适配器和处理器映射器："><a href="#5-2-如果使用独立配置加载处理器适配器和处理器映射器：" class="headerlink" title="5-2. 如果使用独立配置加载处理器适配器和处理器映射器："></a>5-2. 如果使用独立配置加载<strong>处理器适配器</strong>和<strong>处理器映射器</strong>：</h3><p>转换器类的编写同上。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解适配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webBindingInitializer"</span> <span class="attr">ref</span>=<span class="string">"customBinder"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 自定义webBinder --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customBinder"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.bind.support.ConfigurableWebBindingInitializer"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"conversionService"</span> <span class="attr">ref</span>=<span class="string">"conversionService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 转换器配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.itcast.springmvc.convert.DateConverter"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>初始SpringCloud</title>
    <url>/2020/03/15/SpringCloud%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>本篇不讲具体使用细节，只讲由来，仅为像博主一样的新鸟作为入门了解。<a id="more"></a></p>
<p>学习需要循序渐进，先用一篇初体验来了解一下SpringCloud来龙去脉，才能在后序学习中做到事半功倍。从“SpringCloud诞生的大环境？”和“SpringCloud是什么？”两个问题步入SpringCloud的大门。只有脑海中对学习目标有了一个大致的认识，才能在后序学习中做到事半功倍。</p>
<h2 id="引子：什么是微服务？"><a href="#引子：什么是微服务？" class="headerlink" title="引子：什么是微服务？"></a>引子：什么是微服务？</h2><p>微服务业界没有一个统一的、标准的定义。但通常而言，微服务架构是一种架构模式或者说是一种架构风格，他提倡将单一应用程序划分成一组小的服务，但每个服务运行在其独立的自己的进程中，服务之间互相协调、互相配合，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通（通常是基于HTTP的RESTful API）。每个服务都围绕着具体业务进行构建，并且能够被独立地部署到生产环境、类生产环境等。另外，应尽量避免统一的、集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。——出自大牛<a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">Martin Fowler</a></p>
<h3 id="微服务有什么优点？"><a href="#微服务有什么优点？" class="headerlink" title="微服务有什么优点？"></a><font color=red>微服务有什么优点？</font></h3><ul>
<li>每个服务足够内聚，足够小，代码容易理解，聚焦于一个指定的业务功能和业务需求。开发简单，开发效率高，一个服务可能就专一于一个事情。能够被小团队单独开发。</li>
<li>松耦合，无论是在开发阶段或部署阶段都是独立的。</li>
<li>微服务能使用不同的语言开发。</li>
<li>易于集成第三方，允许容易且灵活的方式集成自动部署，通过持续集成工具（Jenkins、Hudson、Bamboo等）。</li>
<li>微服务只是业务逻辑代码，不会和HTML、CSS或其他界面组件混合。</li>
<li>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库。</li>
</ul>
<h3 id="微服务有什么缺点？"><a href="#微服务有什么缺点？" class="headerlink" title="微服务有什么缺点？"></a><font color=green>微服务有什么缺点？</font></h3><ul>
<li>开发人员要处理分布式系统的复杂性。</li>
<li>多服务运维难度，随着服务的增加，运维的压力也在增大。</li>
<li>系统部署依赖、服务之间通信成本、数据一致性、系统集成测试、性能监控。。。。</li>
</ul>
<h3 id="微服务架构所需的技术栈："><a href="#微服务架构所需的技术栈：" class="headerlink" title="微服务架构所需的技术栈："></a><font color=red>微服务架构所需的技术栈：</font></h3><p><strong><u>服务注册、服务治理、服务调用、负载均衡、服务监控、服务熔断、服务降级。。。</u></strong></p>
<p>可以看到一个微服务架构需要多种功能模块联合完成实现。那么有需求就有市场，阿里的dubbo+阿帕奇的zookeeper+Nginx等等技术框架就可以完成微服务架构的基本功能。随着微服务的发展不断地有新需求新技术的诞生，于是就催生了<strong>SpringCloud</strong>这个一站式微服务架构框架，SpringCloud对很多开源产品进行了集成，使微服务架构产品的开发进入了前所未有的快捷时代。</p>
<h2 id="正文：什么是SpringCloud？"><a href="#正文：什么是SpringCloud？" class="headerlink" title="正文：什么是SpringCloud？"></a>正文：什么是SpringCloud？</h2><p>SpringCloud是在SpringBoot的基础上构建的，用于简化分布式系统构建的<strong>工具集</strong>。该工具集为微服务架构中所涉及的<strong>配置管理、服务发现、智能路由、断路器、微代理、控制总线等</strong>操作提供了一种简单的开发方式。SpringCloud中包含了很多子项目，可通过<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">官网</a>查看。</p>
<h3 id="SpringCloud有什么特点？"><a href="#SpringCloud有什么特点？" class="headerlink" title="SpringCloud有什么特点？"></a><font color=red>SpringCloud有什么特点？</font></h3><ol>
<li><strong>集成性</strong>，它将很多开源产品都集成到了自身的框架中，使其越来越强大。</li>
<li><strong>便利性</strong>，不需要过多的配置，也不需要调用很多的接口，简单配置即可上手。</li>
<li><strong>扩展性</strong>，所有组件均通过Maven或Gradle引入依赖。各个组件直接没有代码上的耦合，可以不断地增删。</li>
<li><strong>适应性</strong>，使用SpringCloud开发的项目可应用于PC服务器、云环境、以及各种容器（例如Docker）。</li>
</ol>
<p>SpringCloud的版本号不像其他项目用数字来区分版本，而是根据字母顺序采用伦敦的“地名+版本号”的方式来命名。</p>
<h3 id="SpringCloud和SpringBoot是什么关系？"><a href="#SpringCloud和SpringBoot是什么关系？" class="headerlink" title="SpringCloud和SpringBoot是什么关系？"></a><font color=red>SpringCloud和SpringBoot是什么关系？</font></h3><p>SpringBoot专注于快速方便的开发单个个体微服务。SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务。<strong><u>SpringBoot可以离开SpringCloud独立使用开发项目，但是SpringCloud离不开SpringBoot，属于依赖关系。SpringBoot专注于开发快速、方便的开发单个微服务个体，SpringCloud专注全局的服务治理框架。</u></strong></p>
<h3 id="SpringCloud和Dubbo有什么区别？"><a href="#SpringCloud和Dubbo有什么区别？" class="headerlink" title="SpringCloud和Dubbo有什么区别？"></a><font color=red>SpringCloud和Dubbo有什么区别？</font></h3><p><img src="https://s2.ax1x.com/2019/11/12/M3zHns.png" alt="M3zHns.png"></p>
<p><strong><u>最大区别：SpringCloud抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式。</u></strong></p>
<blockquote>
<p>严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更加合适。</p>
</blockquote>
<p><strong><u>品牌机与组装机的区别</u></strong></p>
<blockquote>
<p>很明显，Spring Cloud的功能比DUBBO更加强大，涵盖面更广，而且作为Spring的拳头项目，它也能够与Spring Framework、Spring Boot、Spring Data、Spring Batch等其他Spring项目完美融合，这些对于微服务而言是至关重要的。使用Dubbo构建的微服务架构就像组装电脑，各环节我们的选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果你是一名高手，那这些都不是问题；而Spring Cloud就像品牌机，在Spring Source的整合下，做了大量的兼容性测试，保证了机器拥有更高的稳定性，但是如果要在使用非原装组件外的东西，就需要对其基础有足够的了解。</p>
</blockquote>
<p><strong><u>社区支持与更新力度</u></strong></p>
<blockquote>
<p>最为重要的是，DUBBO停止了5年左右的更新，虽然2017.7重启了。对于技术发展的新需求，需要由开发者自行拓展升级（比如当当网弄出了DubboX），这对于很多想要采用微服务架构的中小软件组织，显然是不太合适的，中小公司没有这么强大的技术能力去修改Dubbo源码+周边的一整套解决方案，并不是每一个公司都有阿里的大牛+真实的线上生产环境测试过。</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC框架结构和SSM</title>
    <url>/2020/03/15/springMVC%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0%E5%92%8CSSM%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="框架流程简述"><a href="#框架流程简述" class="headerlink" title="框架流程简述"></a>框架流程简述</h2><ol>
<li><p>用户发送请求至前端控制器DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet收到请求调用HandlerMapping处理器映射器。<a id="more"></a></p>
</li>
<li><p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器。</p>
</li>
<li><p>执行处理器(Controller，也叫后端控制器)。</p>
</li>
<li><p>Controller执行完成返回ModelAndView。</p>
</li>
<li><p>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p>
</li>
<li><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p>
</li>
<li><p>ViewReslover解析后返回具体View。</p>
</li>
<li><p>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p>
</li>
<li><p>DispatcherServlet响应用户。</p>
<p><img src="https://s2.ax1x.com/2019/05/30/VKxVrn.png" alt="框架结构图"></p>
</li>
</ol>
<h2 id="重要组件说明"><a href="#重要组件说明" class="headerlink" title="重要组件说明"></a>重要组件说明</h2><ul>
<li><p><font size=4><strong>DispatcherServlet：前端控制器</strong></font></p>
<p>用户请求到达前端控制器，它就相当于<strong>mvc模式中的c</strong>，dispatcherServlet是整个流程<strong>控制的中心</strong>，由它调用其它组件处理用户的请求，dispatcherServlet的存在<strong>降低了组件之间的耦合性</strong>。</p>
</li>
<li><p><font size=4 ><strong>HandlerMapping：处理器映射器</strong></font></p>
<p>HandlerMapping负责<strong>根据用户请求url</strong>找到<strong>Handler即处理器</strong>，<strong>springmvc提供</strong>了不同的映射器实现不同的映射方式，例如：<strong>配置文件方式，实现接口方式，注解方式等</strong>。</p>
</li>
<li><p><font size=4 > <strong>Handler：处理器</strong></font></p>
<p>Handler 是继DispatcherServlet前端控制器的<strong>后端控制器</strong>，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。</p>
<p>*<u>由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</u>*</p>
</li>
<li><p><font size=4 ><strong>HandlAdapter：处理器适配器</strong></font></p>
<p>通过HandlerAdapter对处理器进行执行，这是适<strong>配器模式的应用</strong>，通过扩展适配器可以对更多类型的处理器进行执行。</p>
</li>
<li><p><font size=4 ><strong>ViewResolver：视图解析器</strong></font></p>
<p>View Resolver负责将处理结果生成<strong>View视图</strong>，View Resolver首先根据<strong>逻辑视图名</strong>解析成<strong>物理视图名</strong>（<u>即具体的页面地址</u>），再生成<strong>View视图对象</strong>，最后对View进行<strong>渲染</strong>将处理结果通过页面展示给用户。</p>
</li>
<li><p><font size=4><strong>View：视图</strong></font></p>
<p>springmvc框架提供了很多的View视图类型的支持，包括：<strong>jstlView、freemarkerView、pdfView等</strong>。我们最常用的视图就是jsp。</p>
<p><u><em>一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。</em></u></p>
</li>
<li><p><font color=red size=6><strong>说明</strong></font>：在springmvc的各个组件中，<strong>处理器映射器</strong>、<strong>处理器适配器</strong>、<strong>视图解析器</strong>称为springmvc的<strong>三大组件</strong>。</p>
<p><strong>需要用户开发</strong>的组件有<strong>handler、view</strong>。（一般码农）</p>
<p>有时候需要对框架<strong>二次封装\开发</strong>时，<strong>可能会继承三大组件后添加\重写方法</strong>。（高级一点的码农。。。）</p>
</li>
</ul>
<h2 id="简单配置（SSM整合）"><a href="#简单配置（SSM整合）" class="headerlink" title="简单配置（SSM整合）"></a>简单配置（SSM整合）</h2><h3 id="默认配置："><a href="#默认配置：" class="headerlink" title="默认配置："></a>默认配置：</h3><p>我们没有做任何配置，就可以使用这些组件因为框架已经<strong>默认加载这些组件</strong>了，配置文件位置如下图：</p>
<p><img src="https://s2.ax1x.com/2019/05/30/VMPxSK.png" alt="默认配置文件"></p>
<h3 id="手动配置："><a href="#手动配置：" class="headerlink" title="手动配置："></a>手动配置：</h3><p><strong>开发环境\工具：</strong>MyEclipse Professional 2014+SQLyog+TomCat8+JDK1.7</p>
<p><font color=green><u>因为是练习，所有的配置都是简单的配了一下。</u></font></p>
<p><font color=green><u>src下的java源代码就不做解释和记录了，经典的<strong>三层架构模式</strong>。</u></font></p>
<ol>
<li><p>导入各项jar包至/WebRoot/WEB-INF/lib，添加约束文件方便开发。</p>
</li>
<li><p>创建一个web项目，类路径下<strong>src包</strong>（dao、Service、controller、pojo等等.java文件源代码）和<strong>config包</strong>（mybatis配置文件，spring容器配置文件，springmvc配置文件，数据库配置文件等等），<strong>/WebRoot/WEB-INF</strong>下自动生成<strong>web.xml</strong>、<strong>lib包（jar包）</strong>、<strong>jsp（写的jsp页面）</strong>。</p>
<p>项目结构如下：</p>
<p><img src="https://s2.ax1x.com/2019/05/30/VMPjW6.png" alt="项目结构"></p>
</li>
<li><p>mybatis配置文件（mybatis-config.xml）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">PUBLIC <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"logImpl"</span> <span class="attr">value</span>=<span class="string">"LOG4J"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"nynu.pojo"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>spring容器配置文件（applicationContext-dao.xml）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context/spring-context-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop/spring-aop-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx/spring-tx-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd"</span>&gt;</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">&lt;!-- 		导入db.properties --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">&lt;!-- 		配置数据源 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">&lt;!-- 		配置SqlSessionFactor --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">&lt;!-- 		配置接口扫描器，自动创建包中的接口的实现类 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 			sqlSessionFactory不需要手动注入，该类会自动在容器中寻找一个SqlSessionFactoryBean类型的对象 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"nynu.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring容器配置文件（applicationContext-service.xml）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context/spring-context-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop/spring-aop-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx/spring-tx-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 		扫描注解 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"nynu.service"</span> /&gt;</span></span><br><span class="line">		</span><br><span class="line"><span class="comment">&lt;!-- 		配置事务管理器 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">			</span><br><span class="line"><span class="comment">&lt;!-- 		开启注解式事务支持 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>springMVC配置文件（springmvc.xml）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans/spring-beans-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context/spring-context-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop/spring-aop-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx/spring-tx-4.3.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 开启controller包注解扫描  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"nynu.controller"</span> /&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置处理器映射器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  	&lt;bean class="org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping.class"&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  	&lt;/bean&gt;  --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置处理器适配器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  	&lt;bean class="org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.class"&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  	&lt;/bean&gt;  --&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 使用MVC注解驱动时，自动配置处理器映射器和处理器适配器 --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span> </span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 配置视图解析器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置逻辑视图名的前缀和后缀，可以方便controller开发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 		&lt;property name="prefix" value="/WEB-INF/jsp/"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 		&lt;property name="suffix" value=".jsp"&gt;&lt;/property&gt; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数据库配置文件（db.properties）：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc\:mysql\://localhost\:3306/login?characterEncoding\=utf-8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure>

<p>日志配置文件（log4j.properties）：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Global logging configuration</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG, stdout</span></span><br><span class="line"><span class="comment"># Console output...</span></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%5p [%t] - %m%n</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>web配置文件（web.xml）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">					http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>SpringMvc_01<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.htm<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>default.jsp<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--   	配置spring --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">&lt;!-- 	使用监听器加载spring配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 配置springmvc的前端控制器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">&lt;!-- 配置springmvc的配置文件路径 --&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 设置所有.action的请求进入 springmvc--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这么多东西练习完，再写完这篇文章有点累啊。。。看来以后要分开完成了。。。</p>
<p>搞定这些，也就算是知道springmvc是个什么东西了。具体开发方法还是要多加练习。。。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅编程（一）——Lombok</title>
    <url>/2020/03/15/%E4%BC%98%E9%9B%85%E7%BC%96%E7%A8%8B(%E4%B8%80)%E2%80%94%E2%80%94Lombok/</url>
    <content><![CDATA[<p>最初学习java时候，手写一个个的pojo类及其getter、setter、toString。。。逐渐的熟练之后感觉这样的方式很机械，于是发现各大IDE就提供了快捷键创建这些内容（idea的ALT+INS、MyEclipse的ALT+Shift+s），从这时候开始逐渐深感IDE之便捷；但是在不断地学习生活中开始厌倦这种存在“居然要按下三四次快捷键才能生产代码！每当类中属性发生变化时还要手动去修改对应方法！”等等“不便”因素的笨重方法，于是Lombok就诞生了。<a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。</p>
<p>Lombok提供了很多注解，帮我们省去了很多代码量（例如getter、setter。。。）同时可以自动化日志变量。<a href="https://www.projectlombok.org/" target="_blank" rel="noopener">官网链接</a></p>
<p>简而言之：Lombok是能以简单的注解形式来简化java代码，提高开发人员的开发效率的语法糖！</p>
<h3 id="怎么使用lombok？"><a href="#怎么使用lombok？" class="headerlink" title="怎么使用lombok？"></a>怎么使用lombok？</h3><p>首先安装lombok plugin：</p>
<p><a href="https://imgchr.com/i/MrCN38" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/17/MrCN38.md.png" alt="MrCN38.md.png"></a></p>
<p>设置enable注解处理器，否则编译时可能出错：</p>
<p><a href="https://imgchr.com/i/MrCt9f" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/17/MrCt9f.md.png" alt="MrCt9f.md.png"></a>](<a href="https://imgchr.com/i/MrCt9f" target="_blank" rel="noopener">https://imgchr.com/i/MrCt9f</a>)</p>
<p>项目中添加依赖，maven项目为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Lombok主要注解"><a href="#Lombok主要注解" class="headerlink" title="Lombok主要注解"></a>Lombok主要注解</h3><ul>
<li><code>@Getter and @Setter</code> / 自动为属性提供 Set和Get 方法</li>
<li><code>@ToString</code> / 该注解的作用是为类自动生成toString()方法</li>
<li><code>@EqualsAndHashCode</code> / 为对象字段自动生成hashCode和equals实现</li>
<li><code>@RequiredArgsConstructor</code> / 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。</li>
<li><code>@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor</code> / 顾名思义，为类自动生成对应参数的constructor</li>
<li><code>@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog</code> / 自动为类添加对应的log支持</li>
<li><code>@Data</code> / 自动为所有字段添加@ToString, @EqualsAndHashCode, @Getter，为非final字段添加@Setter,和@RequiredArgsConstructor，本质上相当于几个注解的综合效果</li>
<li><code>@NonNull</code> / 自动帮助我们避免空指针。作用在方法参数上的注解，用于自动生成空值参数检查</li>
<li><code>@Cleanup</code> / 自动帮我们调用close()方法。作用在局部变量上，在作用域结束时会自动调用close方法释放资源</li>
</ul>
<p>这些注解都有一些可选参数，都比较简单易懂，就不记录了</p>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>最常见常用的就是实体类的创建了，大量<strong><u>没有特殊需求</u></strong>的Getter、Setter方法如果堆积在代码中实在是臃肿：</p>
<p><a href="https://imgchr.com/i/MrZLB8" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/17/MrZLB8.md.png" alt="MrZLB8.md.png"></a></p>
<p>从方法视图可以看到，与注解对应的方法已经存在了，根据属性的修改变化，方法也会自动做出调整。</p>
<p>还有另一大应用场景，就是可以注解生成日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Slf</span>4j<span class="comment">//直接使用log进行日志记录，lombok帮我们自动创建Logger对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">estSlf4jApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            log.info(<span class="string">"info....lobok"</span>);</span><br><span class="line">            log.warn(<span class="string">"warn....lobok"</span>);</span><br><span class="line">            log.error(<span class="string">"error....lobok"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a><font color=red>优缺点：</font></h3><p><font color=red><strong>优点：</strong></font></p>
<ol>
<li>能通过注解的形式自动生成构造器、getter/setter、equals、hashcode、toString等方法，提高了一定的开发效率。</li>
<li>让代码变得简洁，不用过多的去关注相应的方法。</li>
<li>属性做修改时，也简化了维护为这些属性所生成的getter/setter方法等。</li>
</ol>
<p><font color=green><strong>缺点：</strong></font></p>
<ol>
<li>不支持多种参数构造器的重载。</li>
<li>虽然省去了手动创建getter/setter方法的麻烦，但大大降低了源代码的可读性和完整性，降低了阅读源代码的舒适度。<strong><u>有时可以通过给getter/setter加一点点业务代码，能极大的简化某些业务场景的代码。</u></strong></li>
<li>要依赖插件的支持，最不能忍受的！！！</li>
</ol>
<p><font color=red><strong>Lombok有它的得天独厚的优点，也有它避之不及的缺点，熟知其优缺点，在实战中灵活运用才是王道。任何技术的学习和使用都要讲求一个灵活运用！</strong></font></p>
<hr>
<p>Lombok的功能还有很多很多，博主浅尝辄止，但是在后续的学习中还会不断地完善和熟练对其的使用。</p>
]]></content>
      <categories>
        <category>工具环境</category>
      </categories>
  </entry>
  <entry>
    <title>优雅编程（三）——MybatisPageHelper</title>
    <url>/2020/03/15/%E4%BC%98%E9%9B%85%E7%BC%96%E7%A8%8B(%E4%B8%89)%E2%80%94%E2%80%94MybatisPageHelper/</url>
    <content><![CDATA[<p>如果你也在用 MyBatis，建议尝试该分页插件，该插件支持很多复杂的单表、多表物理分页。<a id="more"></a></p>
<ul>
<li><p>支持常见的12中数据库（MySQL、Oracle、SqlServer。。。）</p>
</li>
<li><p>支持常见的RowBounds(PageRowBounds)、PageHelper.startPage 方法调用、Mapper 接口参数调用</p>
</li>
<li><p>使用 QueryInterceptor 规范</p>
<blockquote>
<p>详情查看PH官网：<a href="https://pagehelper.github.io/" target="_blank" rel="noopener">https://pagehelper.github.io/</a></p>
</blockquote>
</li>
</ul>
<p>PageHelper插件功能直接明了，就是简化开发中的分页操作，直接上手学习一下。</p>
<p>百度上SSM项目引入PageHelper的解决方法已经很多了，主要学习一下SpringBoot引入的方法，首先引入Pom依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper-spring-boot-starter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>甚至可以不进行任何PageHelper的配置即可使用，粘出演示应用的配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pageHelper</span></span><br><span class="line"><span class="comment">#pagehelper.helper-dialect=mysql</span></span><br><span class="line"><span class="comment">#pagehelper.reasonable=true</span></span><br><span class="line"><span class="comment">#pagehelper.support-methods-arguments=true</span></span><br><span class="line"><span class="comment">#pagehelper.params=count=countSql</span></span><br><span class="line"><span class="comment">#Mybatis</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.example.testpagehelper.edu.li.pojo</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*.xml</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123</span></span><br><span class="line"></span><br><span class="line"><span class="meta">logging.level.com.example.testpagehelper.edu.li.dao</span>=<span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>因为演示应用比较简单，所以直接使用mybatis-generator生成了持久层代码（pojo、mapper、mapper.xml），如果还没用过mybatis-generator这一利器的话，可以看一下上一篇博文——<a href="https://jerrymouse1998.github.io/post/%E4%BC%98%E9%9B%85%E7%BC%96%E7%A8%8B%E4%BA%8Cmybatisgenerator/">优雅编程（二）</a>。</p>
<p>完成了上述操作，即可开始使用了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用静态方法startPage方法即可开启分页操作，自动将后面的查询进行分页操作</span></span><br><span class="line">        PageHelper.startPage(<span class="number">1</span>,<span class="number">7</span>);</span><br><span class="line">        <span class="comment">//直接使用自动生成的mapper接口方法</span></span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByExample(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写controller方法后，验证一下分页结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAllUsers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.selectAllUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到请求结果只有7条：</p>
<p><a href="https://imgchr.com/i/MHIcWj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/23/MHIcWj.md.png" alt="MHIcWj.md.png"></a></p>
<p>观察控制台上的日志发现，先进行了一次查数据量sql，再进行了使用limit分页查询sql，逻辑比较简单清晰：</p>
<p><a href="https://imgchr.com/i/MHIyFg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/23/MHIyFg.md.png" alt="MHIyFg.md.png"></a></p>
<hr>
<p>PageHelper的使用看起来还是非常简单的，但是其中的坑也有很多。因为博主也是初次使用的菜鸟，所以只能等待后续学习中慢慢踩坑记录。本博文撰写时的应用演示蹭了SpringBoot的光，使用的是基于SpringBoot版本的PageHelper，如果使用了其他非SpringBoot版本的PageHelper依赖，可能需要对PageHelper进行Bean注入，下面是实现Bean注入的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyabatisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageHelper <span class="title">pageHelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"PageHelper 注入容器。。。"</span>);</span><br><span class="line">        PageHelper pageHelper=<span class="keyword">new</span> PageHelper();</span><br><span class="line">        Properties properties=<span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">"offsetAsPageNum"</span>, <span class="string">"true"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"rowBoundsWithCount"</span>, <span class="string">"true"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"reasonable"</span>, <span class="string">"true"</span>);</span><br><span class="line">        pageHelper.setProperties(properties);</span><br><span class="line">        <span class="keyword">return</span> pageHelper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>优雅编程（二）——MybatisGenerator</title>
    <url>/2020/03/15/%E4%BC%98%E9%9B%85%E7%BC%96%E7%A8%8B(%E4%BA%8C)%E2%80%94%E2%80%94MybatisGenerator/</url>
    <content><![CDATA[<p>Mybatis是一个使用相当频繁的ORM框架，但在使用此框架时不可避免的要编写和数据表对应的POJO类、XXmapper接口以及XXmapper.xml，如果都是简单的、基础的CRUD场景，那么这个过程也是相当枯燥和机械的，可以适时的引入MyBatis Generator来解放一下。<a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>MyBatis Generator (简称 MBG) 是Mybatis官方提供的逆向工程工具。它可以为 MyBatis的所有版本以及 2.2.0之后的 iBATIS版本自动生成 ORM层代码，典型地包括我们日常需要手写的 <code>POJO</code>、<code>mapper xml</code> 以及 <code>mapper</code> 接口等。MyBatis Generator 自动生成的 ORM层代码几乎可以应对大部分 CRUD 数据表操作场景，可谓是一个生产力工具啊！</p>
<p>既然它的功能就是这么的简单明了，那就话不多说上手使用一下，先创建一个t_user数据表,表结构如下:</p>
<p><a href="https://imgchr.com/i/MRi4sI" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2019/11/19/MRi4sI.md.png" alt="MRi4sI.md.png"></a></p>
<p>引入相关pom依赖及其插件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis generator 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis generator 插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/mybatis-generator.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后创建src/main/resources/mybatis-generator.xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MySql"</span> <span class="attr">defaultModelType</span>=<span class="string">"flat"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">type</span>=<span class="string">"org.mybatis.generator.plugins.SerializablePlugin"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--suppressAllComments是去掉所有的注解；</span></span><br><span class="line"><span class="comment">    另外，commentGenerator还可以配置一个type，设置自己的注解生成器，默认使用的是</span></span><br><span class="line"><span class="comment">    org.mybatis.generator.internal.DefaultCommentGenerator；--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.testpagehelper.edu.li.pojo"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span> <span class="attr">targetProject</span>=<span class="string">"src/main/resources"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">targetProject</span>=<span class="string">"src/main/java"</span> <span class="attr">targetPackage</span>=<span class="string">"com.example.testpagehelper.edu.li.dao"</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"t_user"</span> <span class="attr">domainObjectName</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useActualColumnNames"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>记录几个关键标签的作用：</p>
<ul>
<li><code>&lt; jdbcConnection /&gt;</code> 数据库连接配置，至关重要</li>
<li><code>&lt;javaModelGenerator /&gt;</code> 指定自动生成的 POJO置于哪个包下</li>
<li><code>&lt;sqlMapGenerator /&gt;</code> 指定自动生成的 mapper.xml置于哪个包下</li>
<li><code>&lt;javaClientGenerator /&gt;</code> 指定自动生成的 DAO接口置于哪个包下</li>
<li><code>&lt;table /&gt;</code> 指定数据表名，可以使用_和%通配符</li>
</ul>
<p>更多关于 MyBatis Generator 配置的内容，可以移步 <a href="http://www.mybatis.org/generator/" target="_blank" rel="noopener">官方文档</a>。</p>
<p>准备好上述两步操作，就可以在maven图形化构建中找到generator插件运行，即可逆向工程自动生成：</p>
<p><img src="https://s1.ax1x.com/2019/11/19/MRPyCQ.png" alt="MRPyCQ.png"></p>
<p>可以看到熟悉的User、UserMapper.xml、UserMapper都自动生成好了。</p>
<h2 id="自动生成的代码怎么使用呢？"><a href="#自动生成的代码怎么使用呢？" class="headerlink" title="自动生成的代码怎么使用呢？"></a>自动生成的代码怎么使用呢？</h2><p>我们发现通过 MyBatis Generator自动生成的代码中带有一个 Example文件，比如上图中的UserExample，其实 Example文件对于平时快速开发还是有很大好处的，它能节省很多写 sql语句的时间，举几个实际的例子吧：</p>
<h3 id="单条件模糊搜索-排序"><a href="#单条件模糊搜索-排序" class="headerlink" title="单条件模糊搜索 + 排序"></a>单条件模糊搜索 + 排序</h3><p>在我们的例子中，假如我想通过用户名 <code>username</code>来在 MySQL数据表 <code>t_user</code>中进行模糊搜索，并对结果进行排序，此时利用<code>UserExample</code>可以方便快速的实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">searchUserByUsername</span><span class="params">(String username)</span></span>&#123;</span><br><span class="line">        UserExample userExample=<span class="keyword">new</span> UserExample();</span><br><span class="line"><span class="comment">//        设置模糊搜索条件</span></span><br><span class="line">        userExample.createCriteria().andUsernameLike(<span class="string">'%'</span>+username+<span class="string">'%'</span>);</span><br><span class="line"></span><br><span class="line">        String orderByClause = <span class="string">"creattime DESC"</span>;</span><br><span class="line"><span class="comment">//        设置通过某个字段排序条件</span></span><br><span class="line">        userExample.setOrderByClause(orderByClause);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByExample(userExample);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多条件精确搜索"><a href="#多条件精确搜索" class="headerlink" title="多条件精确搜索"></a>多条件精确搜索</h3><p>再比如，我们想通过住址 <code>address</code>和用户名 <code>username</code> 两个字段来在数据表 <code>t_user</code>中实现精确搜索，则可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">multiConditionsSearch</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        UserExample userExample=<span class="keyword">new</span> UserExample();</span><br><span class="line">        UserExample.Criteria criteria = userExample.createCriteria();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">""</span>.equals(user.getUsername()))</span><br><span class="line">            criteria.andUsernameEqualTo(user.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">""</span>.equals(user.getAddress()))</span><br><span class="line">            criteria.andAddressEqualTo(user.getAddress());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByExample(userExample);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>MybatisGenerator的用法还有很多很多，博主只不过是初步了解。对于生成的Example的使用仁者见仁智者见智，也有很多人喜欢在配置时不生成Example，也就不能使用上述展示的用逻辑代码取代编写sql语句的方式，而是选择去xml文件中编写sql语句。这两种方法各有利弊，还是那句话：“扬长避短，灵活运用”。</p>
]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
  </entry>
  <entry>
    <title>优雅编程(四)——热部署</title>
    <url>/2020/03/15/%E4%BC%98%E9%9B%85%E7%BC%96%E7%A8%8B(%E5%9B%9B)%E2%80%94%E2%80%94%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>在开发SpringBoot的Web应用时，经常需要的重启Web服务器才能使最新修改的代码、配置文件、静态文件生效，这样就不够“优雅”了。想要改变这种情况也并不繁琐，需要我们加入“热部署”的支持，就可以在不重启Web服务器的情况下保证各项文件的修改立即生效。<a id="more"></a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在IDEA中开发SpringBoot应用时，如果想加入热部署的加持，可以使用<strong>spring-boot-devtools</strong>来完成：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>spring-boot-devtools会监听classpath下的文件变动，变动保存生效，其就会立即重启应用。</p>
<p><font color=red><strong>设置IDEA环境自动编译，</strong></font>首先开启设置中的<strong>项目自动编译</strong>选项：</p>
<p><a href="https://imgchr.com/i/QiSQTH" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/28/QiSQTH.md.png" alt="QiSQTH.md.png"></a></p>
<p>然后Find Action，找到Registry…打开，找到并勾选compiler.automake.allow.when.app.running：</p>
<p><a href="https://imgchr.com/i/QiSM0e" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/28/QiSM0e.md.png" alt="QiSM0e.md.png"></a></p>
<p>其实，完成上述步骤后，热部署就已经默认开启了。测试一下：</p>
<p>启动应用，去浏览器中请求一下/hello：</p>
<p><a href="https://imgchr.com/i/QiFJpj" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/28/QiFJpj.png" alt="QiFJpj.png"></a></p>
<p>然后去加一个Controller方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String temp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>稍等片刻，控制台就有重启应用的相关日志：</p>
<p><a href="https://imgchr.com/i/QiF3tg" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/28/QiF3tg.md.png" alt="QiF3tg.md.png"></a></p>
<p>重新发起请求：</p>
<p><a href="https://imgchr.com/i/QiF8hQ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/28/QiF8hQ.png" alt="QiF8hQ.png"></a></p>
<hr>
<p>此时的效果是只要我们修改了编辑区的源代码，保存之后，应用程序便会自动重启让修改生效。</p>
<p>可以在application.properties中自定义热部署的配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#热部署生效，默认为true开启</span></span><br><span class="line"><span class="meta">spring.devtools.restart.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#监听某个静态文件夹下文件的变化（如html文件），当其下面的文件改变的时候能够重新启动SpringBoot</span></span><br><span class="line"><span class="meta">spring.devtools.restart.additional-paths</span>=<span class="string">src/main/resources/templates</span></span><br><span class="line"><span class="comment">#classpath目录下的WEB-INF文件夹内容修改不重启</span></span><br><span class="line"><span class="meta">spring.devtools.restart.exclude</span>=<span class="string">WEB-INF/**</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具环境</category>
      </categories>
  </entry>
  <entry>
    <title>成员内部类&amp;静态内部类</title>
    <url>/2020/03/15/%E5%86%85%E9%83%A8%E7%B1%BB(%E4%B8%8A)%EF%BC%9A%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB&amp;%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>成员内部类&amp;静态内部类<a id="more"></a></p>
<h2 id="成员内部类（普通内部类）"><a href="#成员内部类（普通内部类）" class="headerlink" title="成员内部类（普通内部类）"></a>成员内部类（普通内部类）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">55</span>;<span class="comment">//外部私有成员变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;<span class="comment">//内部类</span></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">66</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(a);<span class="comment">//访问外部私有成员变量</span></span><br><span class="line">			System.out.println(b);<span class="comment">//访问内部私有成员变量</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Outer outer=<span class="keyword">new</span> Outer();</span><br><span class="line">		Inner inner=outer.<span class="keyword">new</span> Inner();</span><br><span class="line">		inner.test();</span><br><span class="line">	&#125;<span class="comment">//运行结果： 55</span></span><br><span class="line">	 <span class="comment">//		     66</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>Inner类相当于Outer类内部的一个成员，Inner类可以用任何访问修饰符。</p>
</li>
<li><p>Inner类中的test()方法可以不受限制地访问外部类中的数据，但是外部类不能直接访问内部类中的成员。</p>
</li>
<li><p>定义了内部类之后，必须使用外部类对象创建内部类，不能直接new内部类。</p>
<p>即：<strong>内部类 对象名 = 外部类对象.new 内部类()；</strong></p>
<p><font color=red><strong>注*：</strong>可以通过创建内部类对象，对象调用内部类成员的方法来实现外部类调用内部类的成员(main方法中的代码)。</font></p>
</li>
<li><p>上述程序编译之后会产生两个class文件“Outer.class”和“Outer$Inner.class”。</p>
<p>成员内部类的class文件总是：<strong>外部类$内部类.class</strong></p>
<p><font color=red><strong>注*：</strong>Java 编译器在创建内部类对象时，隐式的把其外部类对象的引用也传了进去并一直保存着（先创建指向外部类的指针，再作为内部类构造函数的参数）。这样就使得内部类对象始终可以访问其外部类对象，同时这也是为什么在外部类作用范围之外想要创建内部类对象必须先创建其外部类对象的原因。 </font></p>
</li>
<li><p>如果外部类有和内部类同名的成员变量或方法，内部类对象默认使用内部类的成员变量或方法。</p>
<p><font color=red><strong>注*：</strong>如果内部类对象想要调用外部类对象的变量或者方法，可以使用this关键字。</p>
<p><strong>成员变量名（方法名）→调用内部类自身的。</strong></p>
<p><strong>this. 成员变量名（方法名）→调用内部类自身的。</strong></p>
<p><strong>外部类名.this.成员变量名（方法名）→调用外部类自身的。</strong></p>
<p>如果外部类中的同名成员变量或方法被<strong>static</strong>关键字修饰，内部类中可以直接<strong>外部类.静态成员</strong>的方式范文。</font></p>
</li>
<li><p>普通内部类只能包含<strong>非静态变量</strong>、<strong>非静态方法</strong>、<strong>非静态类</strong>。 </p>
</li>
</ol>
<hr>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">55</span>;<span class="comment">//外部私有成员变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">66</span>;<span class="comment">//外部私有静态成员</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//静态内部类</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SInner</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> b = <span class="number">77</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"外部类的b:"</span>+Outer.b);</span><br><span class="line">			System.out.println(<span class="string">"内部类的b:"</span>+b);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SInner inner = <span class="keyword">new</span> SInner();<span class="comment">//直接创建静态内部类对象</span></span><br><span class="line">		inner.test();</span><br><span class="line">	&#125;<span class="comment">//运行结果：外部类的b:66</span></span><br><span class="line">	<span class="comment">//	    内部类的b:77</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>静态内部类不能直接访问外部类的非静态成员，但可以通过<strong>new  外部类().非静态成员名</strong>的方式访问。</p>
</li>
<li><p>如果外部类的<strong>静态成员</strong>和内部类的成员同名，内部类中可以<strong>外部类.静态成员</strong>的方式访问。如果外部类的<strong>静态成员</strong>和内部类的成员不同名，内部类中可以直接用<strong>静态成员</strong>名访问。</p>
</li>
<li><p>创建静态内部类时不需要外部类对象，可以直接创建静态内部类对象。</p>
</li>
<li><p>接口中的静态内部类作为接口的一部分来使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OutInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在接口中定义的任何类都自动的是public和static的，因此这两个关键字都可以省略</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"print()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>在接口中定义的任何类都自动的是public和static的，因此这两个关键字都可以省略。</font></p>
</li>
<li><p>静态内部类可以包含<strong>静态和非静态变量</strong>、<strong>静态和非静态方法</strong>、<strong>静态内部类和成员内部类</strong>。</p>
<hr>
</li>
</ol>
<blockquote>
<p>《Java编程思想》（第四版，P203）:</p>
<blockquote>
<p><u>如果你想要创建某些公共代码，使得它们可以被某个接口的所有不同实现所共用，那么使用接口内部的静态内部类会显得很方便。</u></p>
</blockquote>
</blockquote>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OutInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method_1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method_2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/** 嵌套类*/</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"print something..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 实现类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">OutInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OutInterface.Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inner.print();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inner.print();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        OutInterface oif = <span class="keyword">new</span> OutInterfaceImpl();</span><br><span class="line">        oif.method_1();</span><br><span class="line">        oif.method_2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>内部类总结</title>
    <url>/2020/03/15/%E5%86%85%E9%83%A8%E7%B1%BB(%E4%B8%8B)%EF%BC%9A%E6%80%BB%E7%BB%93&amp;%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="原理分析："><a href="#原理分析：" class="headerlink" title="原理分析："></a>原理分析：<a id="more"></a></h1><blockquote>
<p>图片摘自网络，未找到原作者，如需删除请告知</p>
</blockquote>
<p><a href="https://imgchr.com/i/mlQxsJ" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/08/19/mlQxsJ.md.png" alt="mlQxsJ.md.png"></a></p>
<p><font color=red><strong>为什么内部类可以直接访问外部类的成员，而外部类不能直接访问内部类？</strong></font></p>
<p>首先写一个类：</p>
<p><img src="https://s2.ax1x.com/2019/08/19/m3CavV.png" alt="m3CavV.png"></p>
<p>编译之后产生两个文件：</p>
<p><img src="https://s2.ax1x.com/2019/08/19/m3CwuT.png" alt="m3CwuT.png"></p>
<p>用javap反编译Outter$Inner.class：</p>
<p><a href="https://imgchr.com/i/m3CBbF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/08/19/m3CBbF.md.png" alt="m3CBbF.md.png"></a></p>
<p><a href="https://imgchr.com/i/m3C0DU" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/08/19/m3C0DU.md.png" alt="m3C0DU.md.png"></a></p>
<p><strong>答：</strong><u>可以看到，内部类中保存的有外部类的引用，所以内部类可以直接访问外部类的成员。通过同样的方式反编译Outter.class文件后会发现外部类中没有传入内部类的引用。</u></p>
<hr>
<p><font color=red><strong>为什么局部内部类和匿名内部类只能访问被final修饰的局部成员？</strong></font></p>
<p><font color=red><strong>注</strong>：JDK1.8之后虽然不写final编译器并不会报错，但是依然不允许修改被使用的局部成员，相当于隐式的添加了final修饰词。</font></p>
<p>这是一个编译器设计的问题，从代码中直接看，很容易让人误解为内部类直接使用了局部成员（参数）。实际上并不是这样的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> String name,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Inner().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以这么理解：局部有个变量name，当内部类要使用的时候就会使“内部类name”=“局部变量name”，然后去使用这个“内部类name”。这么做很容易出现问题，如果这个“内部类name”改变了，“局部变量name”是不会随着改变的。为了解决这个问题，编译器要求这个被使用的“局部变量name”被final修饰。（<strong>被访问的外部类成员不需要final修饰，因为内部类中有外部类的引用，所有的变量修改都会真实的反映到内部类和外部类中</strong>）</p>
<p>反编译之后，会发现实际上的操作是这样的：</p>
<p><img src="https://s2.ax1x.com/2019/08/19/m3tlEF.png" alt="m3tlEF.png"></p>
<p>在show（）方法之前增加了一个初始化的操作，可以这么理解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> String name,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="comment">//方法内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Outter</span>$<span class="title">Inner</span></span>&#123;</span><br><span class="line">            <span class="comment">//增加初始化方法</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">( String Inner$name)</span></span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.Inner$name=name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(Inner$name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">new</span> Outter$Inner().show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答：</strong></p>
<ol>
<li><u>保证一致性：在内部类中通过构造器将局部的变量copy了一份，然后使用copy后的变量。实际上内部类中使用的是自身的属性。所以为了保持“本体”和“克隆体”的一致性，必须加上final修饰符。</u></li>
<li><u>改变变量的生命周期：当局部方法结束时，局部变量的生命周期就结束了，但是局部内部类（匿名内部类）对象的生命周期可能还没有结束，这时对象再去使用局部变量就变得不可能了，给局部变量加上final修饰符其实就是改变了它的生命周期。</u></li>
</ol>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>局部内部类&amp;匿名内部类</title>
    <url>/2020/03/15/%E5%86%85%E9%83%A8%E7%B1%BB(%E4%B8%AD)%EF%BC%9A%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB&amp;%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>局部内部类又称方法内部类，顾名思义就是定义在方法体内的类。</p>
<p>局部内部类只又在方法中可见，即只能在该方法中使用。<a id="more"></a></p>
<h2 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h2><p><font color=red>局部内部类不能用<strong>static、public、protect、private</strong>修饰。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//外部类方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Outter_show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">11</span>;<span class="comment">//外部类成员变量</span></span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">22</span>;<span class="comment">//外部类成员变量</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//方法内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> b = <span class="number">33</span>;<span class="comment">//内部类成员变量</span></span><br><span class="line">			<span class="comment">//内部类方法</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Inner_show</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(a);</span><br><span class="line">				System.out.println(b);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建内部类对象，调用内部类方法</span></span><br><span class="line">		<span class="keyword">new</span> Inner().Inner_show();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">		outter.Outter_show();</span><br><span class="line">	&#125;<span class="comment">//运行结果：11</span></span><br><span class="line">&#125;     <span class="comment">//	    33</span></span><br></pre></td></tr></table></figure>

<p>实际应用中，可能需要在内部类外部调用成员内部类，但是由于外部类不能访问内部类，所以只能使用返回内部类的父类或者接口的形式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">	<span class="comment">//外部类方法,因为外部类不能访问内部类</span></span><br><span class="line">    <span class="comment">//所以通过父类或者接口的方式返回</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Runnable <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//方法内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"I'm Inner...."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建外部类对象，调用外部类方法返回内部类</span></span><br><span class="line">		Runnable runnable = <span class="keyword">new</span> Outter().getInner();</span><br><span class="line">		runnable.run();</span><br><span class="line">	&#125;<span class="comment">//运行结果：I'm Inner....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h2><p>swing应用程序编程时添加监听器、初始化新线程时。。。经常会用到匿名内部类。</p>
<p>无论是继承父类还是实现接口，实际上拿到的是父类或者接口的<strong>引用</strong>，这个<strong>引用</strong>指向由<strong>匿名内部类定义的类的实例</strong>。这个被继承的父类或者接口<strong>必须是实际存在</strong>的。</p>
<p>栗子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用GUI编程时常见的添加事件监听器的代码为例</span></span><br><span class="line"><span class="comment">//匿名实例</span></span><br><span class="line"><span class="comment">// 添加鼠标监听事件</span></span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"按钮被点击"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>匿名内部类在使用时的编写方式不同又可以分为<strong>匿名实例</strong>、<strong>匿名类实例</strong>，上述代码就是匿名实例，下面介绍匿名类实例的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名类实例</span></span><br><span class="line"><span class="comment">//同样使用添加鼠标监听事件</span></span><br><span class="line">ActionListener listener = <span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"按钮被点击"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">button.addActionListener(listener);</span><br></pre></td></tr></table></figure>

<p>两者的区别和应用场景显而易见，不再赘述。</p>
<hr>
<p><strong><u>匿名内部类的目的和应用场景：</u></strong></p>
<p>1.解决抽象类和接口不能实例化对象，有时候没必要特意去编写一个类去实现接口中的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以接口用匿名内部类为例</span></span><br><span class="line"><span class="comment">//抽象类用匿名内部类方法一样</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span>()</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]  args)</span></span>&#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"跑了。。。。"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        animal.run();</span><br><span class="line">&#125;<span class="comment">//运行结果：跑了。。。。</span></span><br></pre></td></tr></table></figure>

<p>2.当接口或者抽象类作为参数时，用匿名内部类来实例化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plant</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Farmer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plant</span><span class="params">(Fruit fruit)</span></span>&#123;</span><br><span class="line">        fruit.plant();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]  args)</span></span>&#123;</span><br><span class="line">        Farmer farmer = <span class="keyword">new</span> Farmer();</span><br><span class="line">        farmer.plant(<span class="keyword">new</span> Fruit()&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plant</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"种植"</span>+<span class="keyword">this</span>.getName());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">"苹果"</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;<span class="comment">//运行结果:种植苹果</span></span><br></pre></td></tr></table></figure>

<p>以上方法也经常采用定义一个苹果类实现Fruit接口，然后农民类中不变，传参时传入苹果类对象（多态）。</p>
<hr>
<p><font color=red>注意:</font></p>
<ol>
<li><p>使用匿名内部类时，匿名内部类既可以继承父类，也可以实现接口 ，同时只能继承一个类或者实现一个接口。</p>
</li>
<li><p>匿名内部类中<strong>不能存在任何的静态成员变量和静态方法</strong>。 </p>
</li>
<li><p>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
</li>
<li><p>匿名类的声明是在编译时进行的，实例化在运行时进行。这意味着 for循环中的一个new语句会创建相同匿名类的几个实例，而不是创建几个不同匿名类的一个实例。 </p>
</li>
<li><p>匿名内部类中的方法都是通过父类引用访问的，所以，如果定义了一个在父类中没有的方法，那么这个方法是不能被这个父类引用调用到的。但是可以仅仅作为匿名内部类中方法之间的代码共享（类似于面向过程）。</p>
</li>
<li><p>匿名内部类中是不能定义构造函数的，但可通过实例初始化代码块来达到构造器的效果，但是也不能重载实例初始化方法（即仅有一个这样的“构造器”）。 </p>
<p>初始化代码块（构造代码块）例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> age,<span class="keyword">final</span> String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">            <span class="keyword">int</span> age_ ;</span><br><span class="line">            String name_;</span><br><span class="line">            <span class="comment">//构造代码块完成初始化工作</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">0</span> &lt; age &amp;&amp; age &lt; <span class="number">200</span>)&#123;</span><br><span class="line">                    age_ = age;</span><br><span class="line">                    name_ = name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> name_;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> age_;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outter out = <span class="keyword">new</span> Outter();</span><br><span class="line">        Inner inner_1 = out.getInner(<span class="number">201</span>, <span class="string">"chenssy"</span>);</span><br><span class="line">        System.out.println(inner_1.getName());</span><br><span class="line">        Inner inner_2 = out.getInner(<span class="number">23</span>, <span class="string">"chenssy"</span>);</span><br><span class="line">        System.out.println(inner_2.getName());</span><br><span class="line">    &#125;<span class="comment">//运行结果：null</span></span><br><span class="line">&#125;<span class="comment">//    	    chenssy</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>拦截器转换器</title>
    <url>/2020/03/15/%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BD%AC%E6%8D%A2%E5%99%A8/</url>
    <content><![CDATA[<p>Spring Web MVC的拦截器类似于servlet开发中的filter过滤器，用于对处理器进行预处理和后处理。</p>
<p>想要写一个拦截器只需要让拦截器实现HandlerInterceptor接口，并在springmvc.xml中进行配置即可使用。<a id="more"></a></p>
<h3 id="拦截器："><a href="#拦截器：" class="headerlink" title="拦截器："></a>拦截器：</h3><h5 id="HandlerInterceptor接口："><a href="#HandlerInterceptor接口：" class="headerlink" title="HandlerInterceptor接口："></a>HandlerInterceptor接口：</h5><p>该接口一共有三个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//都是default方法，可以根据需要选择实现</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写拦截器时需要实现此接口根据不同的需要重写不同的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandlerInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"><span class="comment">//    这个方法是在controller方法执行之前调用的</span></span><br><span class="line"><span class="comment">//    如果返回值为true则继续执行controller方法，反之如果是false则终止controller方法的执行</span></span><br><span class="line"><span class="comment">//    可以用做是否登录的校验，身份权限的检验等等。。。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    这个方法是在controller方法执行之后，但视图还没有返回时调用的</span></span><br><span class="line"><span class="comment">//    这里可以得到数据模型和视图(ModelAndView)的信息</span></span><br><span class="line"><span class="comment">//    可以用做在视图返回前对数据模型进行统一的加工处理，加入公用信息以便页面显示等等。。。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    这个方法controller方法完全执行完毕并且视图也返回之后调用</span></span><br><span class="line"><span class="comment">//    这个方法可以得到controller执行时的异常信息</span></span><br><span class="line"><span class="comment">//    可以用做记录操作日志等等。。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="springmvc-xml中配置拦截器："><a href="#springmvc-xml中配置拦截器：" class="headerlink" title="springmvc.xml中配置拦截器："></a>springmvc.xml中配置拦截器：</h5><p>写好HandlerInterceptor之后需要在springmvc.xml中进行拦截器的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置拦截器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            可以配置多个拦截器--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            进入拦截器的请求路径  /**全部进入拦截器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置具体的拦截器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"nynu.li.interceptor.MyHandlerInterceptor1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            进入拦截器的请求路径  /**全部进入拦截器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            配置具体的拦截器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"nynu.li.interceptor.MyHandlerInterceptor2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意</strong>：</font>preHandle按拦截器定义顺序调用</p>
<p>postHandler按拦截器定义逆序调用</p>
<p>afterCompletion按拦截器定义逆序调用</p>
<p>postHandler在拦截器链内所有拦截器的preHandle都返回成功才调用</p>
<p>afterCompletion只有自身拦截器的preHandle返回true才调用</p>
<hr>
<h3 id="转换器："><a href="#转换器：" class="headerlink" title="转换器："></a>转换器：</h3><p>主要用作自定义参数绑定时，前端控制器接收到请求后，找到注解形式的处理器适配器，对RequestMapping标记的方法进行适配，并对方法中的形参进行参数绑定。可以在springmvc处理器适配器上自定义转换器Converter进行参数绑定。</p>
<p>一般使用&lt;mvc:annotation-driven/&gt;注解驱动加载处理器适配器，可以在此标签上进行配置。</p>
<h5 id="Converter-lt-S-T-gt-接口："><a href="#Converter-lt-S-T-gt-接口：" class="headerlink" title="Converter&lt;S,T&gt;接口："></a>Converter&lt;S,T&gt;接口：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="comment">//S：source 转换源的类型</span></span><br><span class="line"><span class="comment">//T：target 转换目标的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(S var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想自定义一个转换器，只需要实现Converter接口即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">	<span class="comment">//时间格式转换器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat sdf= <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        Date targetDate = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            targetDate = sdf.parse(date);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> targetDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="springmvc-xml中配置拦截器：-1"><a href="#springmvc-xml中配置拦截器：-1" class="headerlink" title="springmvc.xml中配置拦截器："></a>springmvc.xml中配置拦截器：</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置转换器工厂bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span> <span class="attr">name</span>=<span class="string">"formattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"nynu.li.converter.DateConverter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    配置注解驱动,代替了处理器映射器(HandlerMapping)和处理器适配器(HandlerAdapter)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"formattingConversionServiceFactoryBean"</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot编写简单文件(图片)上传</title>
    <url>/2020/03/15/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%BC%95%E5%8F%91%E7%9A%84%E6%9C%89%E8%B6%A3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>表单的文件信息使用serialize()序列化之后传参引发问题，需要使用FormData对象封装form表单。<a id="more"></a></p>
<p>jsp:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form id=<span class="string">"addUserForm"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">        &lt;label for="add_username" class="col-sm-2 control-label"&gt;username&lt;/label&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-sm-10"</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> id=<span class="string">"add_username"</span> placeholder=<span class="string">"username"</span> name=<span class="string">"username"</span> /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    。。。</span><br><span class="line">     &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">         其他的各种属性的input。。。</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    。。。</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">        &lt;label for="add_pic" class="col-sm-2 control-label"&gt;pic&lt;/label&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-sm-10"</span>&gt;</span><br><span class="line">            &lt;input type=<span class="string">"file"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> id=<span class="string">"add_pic"</span> placeholder=<span class="string">"pic"</span> name=<span class="string">"fileUpload"</span> /&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"modal-footer"</span>&gt;</span><br><span class="line">    &lt;button type="button" class="btn btn-default" data-dismiss="modal"&gt;关闭&lt;/button&gt;</span><br><span class="line">    &lt;button type="button" class="btn btn-primary" onclick="user_insert()"&gt;添加&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user_insert</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.post(<span class="string">"addUser"</span>,$(<span class="string">"#addUserForm"</span>).serialize(),<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data==<span class="string">"OK"</span>)&#123;</span><br><span class="line">            alert(<span class="string">"添加成功"</span>);</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">"添加失败"</span>);</span><br><span class="line">            <span class="built_in">window</span>.location.reload();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要添加form属性enctype=”multipart/form-data”。</p>
<p>需要几点：<br>　　1. method=”post” 是必须的<br>　　2. enctype=”multipart/form-data” 是必须的，表示提交二进制文件<br>　　3. accept=”image/*” 表示只选择图片</p>
<p><strong>注意：这里的form表单没有直接submit提交，而是js使用$.post()提交的，表单的信息使用serialize()序列化之后传参的。这个操作会引发一个问题。。。后面再说。。。</strong></p>
<p>在webapp/WEB-INF下新建一个pic文件夹用来存放上传的图片：</p>
<p><img src="https://s2.ax1x.com/2019/09/15/ncO5lD.png" alt="ncO5lD.png"></p>
<p>controller：</p>
<p>这里选择用添加新用户时上传头像图片例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"addUser"</span>,method = RequestMethod.POST)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">addUser</span><span class="params">(User user, MultipartFile fileUpload, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//        判断是否上传了图片</span></span><br><span class="line">        <span class="keyword">if</span> (!fileUpload.isEmpty())&#123;</span><br><span class="line"><span class="comment">//            使用UUID生成32位随机字符串作为文件名</span></span><br><span class="line"><span class="comment">//            如果依然怕重复就加上当前时间System.currentTimeMillis()</span></span><br><span class="line">            String rname = UUID.randomUUID().toString();</span><br><span class="line"><span class="comment">//            使用getExtension(commons.io包)获取文件名的后缀名(不含.)</span></span><br><span class="line">            String ext = FilenameUtils.getExtension(fileUpload.getOriginalFilename());</span><br><span class="line"><span class="comment">//            使用getRealPath获取/pic的真是路径</span></span><br><span class="line">            String path = request.getServletContext().getRealPath(<span class="string">"/pic"</span>);</span><br><span class="line"><span class="comment">//            新建一个file对象，判断/pic文件夹是否存在，不存在就创建一个</span></span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">"path"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">                file.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            将文件写入磁盘</span></span><br><span class="line">            fileUpload.transferTo(<span class="keyword">new</span> File(path,rname+<span class="string">"."</span>+ext));</span><br><span class="line"><span class="comment">//            准备将文件名和其他属性一起写入数据库</span></span><br><span class="line">            user.setPic(rname+<span class="string">"."</span>+ext);</span><br><span class="line">        &#125;</span><br><span class="line">        Integer result = userService.addUser(user);</span><br><span class="line">        <span class="keyword">if</span> (result==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"FALSE"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>MultipartFile</strong>这个类一般用来接受前台传过来的文件，提供了一些比较便捷的方法。</p>
<p>接下来完善service和dao，直接insert没什么特色就不细说了。</p>
<p>可以在application.properties中加入上传大小限制的配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.servlet.multipart.max-file-size</span>=<span class="string">100MB</span></span><br><span class="line"><span class="meta">spring.servlet.multipart.max-request-size</span>=<span class="string">100MB</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="出现问题："><a href="#出现问题：" class="headerlink" title="出现问题："></a>出现问题：</h1><p>完善上面的编码之后，运行发现添加请求之后处理器方法有一个空指针异常。。fileUpload是null。。。经过排查觉得应该是serialize()，因为上传文件的文件流不能被序列化并传递导致后台接收不到MultipartFile对象。</p>
<p>经过思考和查询，总结了解决这个问题大概有如下几种方法：</p>
<ol>
<li><p>逃避这个问题：serialize()使用的情况比较局限，只能正确序列化check、text、password等等简单的常用类型。不用异步请求。。。就不用serialize()去序列化，直接submit提交form表单。(废话。。。)</p>
</li>
<li><p>使用异步请求：需要使用FormData对象封装form表单。</p>
<p>FormData 对象可以把form中所有表单元素的name与value组成一个queryString，提交到后台，在使用Ajax提交时，使用FormData对象可以减少拼接queryString的工作量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> formdata=<span class="keyword">new</span> FromData($(<span class="string">"#form"</span>)[<span class="number">0</span>])；</span><br><span class="line">formser.append(<span class="string">"test"</span>,test);<span class="comment">//可增加请求的参数</span></span><br><span class="line">FormData还有<span class="keyword">set</span>、<span class="keyword">get</span>、has等等很多方法</span><br></pre></td></tr></table></figure>

<p>formData.append(‘a’, 1)意为添加一个键值对,重复添加的键不会被覆盖。</p>
<p>formData.set(‘a’, 1)意为修改某个键的值，如果不存在则作用等同于append，但是重复添加的值会相互覆盖。</p>
<p><font color=red><strong>注意:</strong>这里的[0]去掉的话会报错！Failed to construct ‘FormData’: parameter 1 is not of type ‘HTMLFormElement’.</font></p>
<p><u><strong>这里出现了一个很鬼畜的现象：id选择器，为什么可以取出一个数组？？？</strong></u></p>
<p><font color=red><strong>为什么要加[0]？</strong>因为new FormData需要的是一个HtmlElement类型的数据，但是JQ得到的是一个HtmlElement的集合，及时这个集合只有一个元素，也要用[ ]取一个元素。</font></p>
<p><font color=red>JQ是一个伪数组对象，虽然其本身是一个对象，但也能表现出数组的特点：有length，能用下标取值。为什么这么设计？</font></p>
<p><font color=red><strong>为什么这么设计？</strong>因为JS有getElementByXX和getElementsByXX，但是JQ却没有这么的直白,举个例子：</font></p>
<p>$(“.someClass”) 这个时候将所有匹配到DOM元素对象放在jQuery维护的数组中;</p>
<p>$(“#id”)这个时候将所有匹配到DOM元素对象放在jQuery维护的数组中;<br><font color=red>在数组的特征外，jQuery还可以调用<code>next()</code>, <code>last()</code>等方法（返回结果也还是jQuery对象，jQuery链式功能）,<strong>总而言之jQuery得到的是个HTMLElement的集合基础上的封装后的对象。</strong></font></p>
<p>   将添加用户的js改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">user_insert</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> formdata = <span class="keyword">new</span> FormData($(<span class="string">"#addUserForm"</span>)[<span class="number">0</span>]);</span><br><span class="line">       $.ajax(&#123;</span><br><span class="line">           type:<span class="string">"POST"</span>,</span><br><span class="line">           url:<span class="string">"addUser"</span>,</span><br><span class="line">           data:formdata,</span><br><span class="line">           processData:<span class="literal">false</span>,</span><br><span class="line">           contentType:<span class="literal">false</span>,</span><br><span class="line">           <span class="comment">//async:false,</span></span><br><span class="line">           success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (data==<span class="string">"OK"</span>)&#123;</span><br><span class="line">                   alert(<span class="string">"添加成功"</span>);</span><br><span class="line">                   <span class="built_in">window</span>.location.reload();</span><br><span class="line">               &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                   alert(<span class="string">"添加失败"</span>);</span><br><span class="line">                   <span class="built_in">window</span>.location.reload();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意的几点：</strong></p>
<ol>
<li>processData<strong>必须</strong>设置为false。因为data值是FormData对象，不需要对数据做处理。</li>
<li>contentType<strong>必须</strong>设置为false，不设置contentType的值，因为使用form表单构造的FormData对象，且form表单已经声明了属性enctype=”multipart/form-data”，所以这里设置为false。<ol start="3">
<li>async：要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<p>   虽然不是什么很高大上的问题，但是想我一样初学者遇到时还是很棘手的。暂时使用这样的方式完成了上传并解决了小麻烦。上面的controller代码是添加用户的，如果是修改用户还需要在jsp页面传一个修改前pic的值，方便对修改前的图片进行删除。代码如下：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"updateUser"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">updateUser</span><span class="params">(User user,MultipartFile fileUpload,HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//        判断是否上传了图片</span></span><br><span class="line">	<span class="keyword">if</span> (!fileUpload.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//            使用UUID生成32位随机字符串作为文件名</span></span><br><span class="line">        <span class="comment">//            如果依然怕重复就加上当前时间System.currentTimeMillis()</span></span><br><span class="line">        String rname = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//            使用getExtension(commons.io包)获取文件名的后缀名(不含.)</span></span><br><span class="line">        String ext=FilenameUtils.getExtension(fileUpload.getOriginalFilename());</span><br><span class="line">        <span class="comment">//            使用getRealPath获取/pic的真是路径</span></span><br><span class="line">        String path = request.getServletContext().getRealPath(<span class="string">"/pic"</span>);</span><br><span class="line">        <span class="comment">//            新建一个file对象，判断/pic文件夹是否存在，不存在就创建一个</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"path"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists())&#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//            将文件写入磁盘</span></span><br><span class="line">        fileUpload.transferTo(<span class="keyword">new</span> File(path,rname+<span class="string">"."</span>+ext));</span><br><span class="line">        <span class="comment">//            如果用户修改前不是使用默认图片，就把之前的图片删掉</span></span><br><span class="line">        <span class="keyword">if</span> (!user.getPic().equals(<span class="string">"default.png"</span>))&#123;</span><br><span class="line">            File originFile = <span class="keyword">new</span> File(path,user.getPic());</span><br><span class="line">            <span class="keyword">if</span> (originFile.exists())&#123;</span><br><span class="line">                originFile.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//            准备将文件名和其他属性一起写入数据库</span></span><br><span class="line">        user.setPic(rname+<span class="string">"."</span>+ext);</span><br><span class="line">	&#125;</span><br><span class="line">	Integer result = userService.updateUser(user);</span><br><span class="line">	<span class="keyword">if</span> (result==<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="string">"FALSE"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>多条件分页查询</title>
    <url>/2020/03/15/%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%86%E9%A1%B5%E5%92%8C%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="多条件分页查询："><a href="#多条件分页查询：" class="headerlink" title="多条件分页查询："></a>多条件分页查询：<a id="more"></a></h3><p>修改pojo类user，添加两个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer start;<span class="comment">//方便传参，方便mapper中limit语句使用</span></span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">	getter/setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先创建一个pojo类Page</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> total;<span class="comment">//总条数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> page;<span class="comment">//当前页码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//页大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalPage;<span class="comment">//总页数</span></span><br><span class="line">    <span class="keyword">private</span> T t;<span class="comment">//封装查询条件，在条件查询时候要用到</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; rows;<span class="comment">//结果集</span></span><br><span class="line">    getter/setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写controller的处理器方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"users.action"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findUsers</span><span class="params">(Model model, @RequestParam(defaultValue = <span class="string">"1"</span>)</span> Integer page, @<span class="title">RequestParam</span><span class="params">(defaultValue = <span class="string">"7"</span>)</span> Integer size,Integer totalPage,String username,</span></span><br><span class="line"><span class="function">String address)</span>&#123;</span><br><span class="line">    <span class="comment">//翻页时需要对页码进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (page&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        page = <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (totalPage!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (page&gt;totalPage)&#123;</span><br><span class="line">            page = totalPage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Page&lt;User&gt; userslist = userService.selectUserList(page,size,username,address);</span><br><span class="line">    model.addAttribute(<span class="string">"page"</span>,userslist);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"usersList"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来写service中对应的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;User&gt; <span class="title">selectUserList</span><span class="params">(Integer page, Integer size, String username, String address)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        封装查询条件</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(username);</span><br><span class="line">        user.setAddress(address);</span><br><span class="line">        user.setStart((page-<span class="number">1</span>)*size);</span><br><span class="line">        user.setSize(size);</span><br><span class="line"><span class="comment">//        查询总记录数</span></span><br><span class="line">        <span class="keyword">int</span> total = userDao.selectUserListCount(user);</span><br><span class="line"><span class="comment">//        表查询结果</span></span><br><span class="line">        List&lt;User&gt; userslist = userDao.selectUserList(user);</span><br><span class="line"><span class="comment">//        封装结果集返回</span></span><br><span class="line">        Page&lt;User&gt; result = <span class="keyword">new</span> Page&lt;User&gt;();</span><br><span class="line">        result.setPage(page);</span><br><span class="line">        result.setSize(size);</span><br><span class="line">        result.setTotal(total);</span><br><span class="line">        result.setT(user);<span class="comment">//查询条件也需要封装到page类中</span></span><br><span class="line">        result.setRows(userslist);</span><br><span class="line">        result.setTotalPage(total%size==<span class="number">0</span>?total/size:(total/size)+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最后写mapper文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"selectUserListWhere"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username!=null"</span>&gt;</span></span><br><span class="line">            and username like "%"#&#123;username&#125;"%"</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"address!=null"</span>&gt;</span></span><br><span class="line">            and address like "%"#&#123;address&#125;"%"</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUserListCount"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    select count(*) from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"selectUserListWhere"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUserList"</span> <span class="attr">parameterType</span>=<span class="string">"User"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"selectUserListWhere"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"size!=null and start!=null"</span>&gt;</span></span><br><span class="line">        limit #&#123;start&#125;,#&#123;size&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>服务器端差不多写好了，开始写前端jsp(顺序按个人习惯):</p>
<p>这里会出现一个<font color=red><strong>问题：</strong></font>每次查询之后，点击翻页就会重新发起请求，导致结果集显示成不带查询条件的结果集。<strong>解决思路：</strong>想办法保存查询条件，每次翻页时都携带着查询条件。    </p>
<p>先在page类中加入一个封装查询条件的类(T t)，在每次service对应方法中将查询条件也封装到page类的t属性中，每次翻页的时候通过get请求拼接的方法将当前页码(page.page+-1)、总页数(page.totalPage向前翻不需要)、查询条件(page.t.username  page.t.address)传到分页查询方法中去。</p>
<p>还有另一种解决办法：使用伪分页，即通过前端分页。一次查出所有符合条件的结果集，然后每次翻页只显示部分。各有好坏：伪分页一次查询结果集大，后端分页查询次数多。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--   条件查询部分的表单--%&gt;</span><br><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/users.action"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"navbar-form navbar-left"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">        &lt;input name=<span class="string">"username"</span> type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> placeholder=<span class="string">"username"</span>&gt;</span><br><span class="line">        &lt;input name=<span class="string">"address"</span> type=<span class="string">"text"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> placeholder=<span class="string">"address"</span>&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;button type="submit" class="btn btn-default"&gt;&lt;span class="glyphicon glyphicon-search"&gt;&lt;/span&gt;查询&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;%-- 分页后，页码和翻页按钮部分 --%&gt;</span><br><span class="line">&lt;div id=<span class="string">"pageNumber"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"row"</span>&gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-lg-offset-5 col-lg-7"</span>&gt;</span><br><span class="line">        当前：$&#123;page.page&#125;/总计：$&#123;page.totalPage&#125;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;a href="$&#123;pageContext.request.contextPath&#125;/users.action?page=1&amp;username=$&#123;page.t.username&#125;&amp;address=$&#123;page.t.address&#125;" class="glyphicon glyphicon-fast-backward btn btn-lg col-lg-offset-4 col-lg-1"&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a href="$&#123;pageContext.request.contextPath&#125;/users.action?page=$&#123;page.page-1&#125;&amp;username=$&#123;page.t.username&#125;&amp;address=$&#123;page.t.address&#125;" class="glyphicon glyphicon-chevron-left btn btn-lg col-lg-1"&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a href="$&#123;pageContext.request.contextPath&#125;/users.action?page=$&#123;page.page+1&#125;&amp;totalPage=$&#123;page.totalPage&#125;&amp;username=$&#123;page.t.username&#125;&amp;address=$&#123;page.t.address&#125;" class="glyphicon glyphicon-chevron-right btn btn-lg col-lg-1"&gt;&lt;/a&gt;</span><br><span class="line">    &lt;a href="$&#123;pageContext.request.contextPath&#125;/users.action?page=$&#123;page.totalPage&#125;&amp;totalPage=$&#123;page.totalPage&#125;&amp;username=$&#123;page.t.username&#125;&amp;address=$&#123;page.t.address&#125;" class="glyphicon glyphicon-fast-forward btn btn-lg col-lg-1"&gt;&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>LeetCode——有效数字</title>
    <url>/2020/03/14/LeetCode-%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>什么是面向测试编程？试试本题就知道了！</p>
<h2 id="NO-65-有效数字-困难"><a href="#NO-65-有效数字-困难" class="headerlink" title="NO.65 有效数字 困难 "></a>NO.65 有效数字 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8Q6Wd0.png" alt="8Q6Wd0.png"></p>
<p>没有get到这道题目的点，这样的题目很搞心态。尤其是看了<a href="https://leetcode.com/problems/valid-number/discuss/23977/A-clean-design-solution-By-using-design-pattern" target="_blank" rel="noopener">作者的解答</a>之后更懵逼了，作者使用了责任链的设计模式，从来没想到解算法题还能用到设计模式。大牛的思维方式就适合我不一样，解个算法题都能考虑到扩展性和复用性。</p>
<h3 id="思路一：暴力法"><a href="#思路一：暴力法" class="headerlink" title="思路一：暴力法"></a><strong><font color=red>思路一：暴力法</font></strong></h3><p>按序遍历字符串，逐位判断是否合法。注意要去除首尾空格。</p>
<p>这种方法就是比较恶心，很容易有考虑不到的情况。</p>
<p>而且测试用例中有：”.1”、”.2”、”+.8”、”46.”、”2e0”等等，预期输出都是true。真的恶心到了。。。</p>
<p>切身感受什么是面向测试编程！！！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="keyword">if</span> (s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> pointSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 .</span></span><br><span class="line">    <span class="keyword">boolean</span> eSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 e</span></span><br><span class="line">    <span class="keyword">boolean</span> numberSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 0-9</span></span><br><span class="line">    <span class="keyword">boolean</span> numberAfterE = <span class="keyword">true</span>;<span class="comment">//e之后是否出现 0-9</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'0'</span> &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= <span class="string">'9'</span>) &#123;<span class="comment">//当前元素是数字</span></span><br><span class="line">            numberSeen = <span class="keyword">true</span>;</span><br><span class="line">            numberAfterE = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'.'</span>) &#123;<span class="comment">//当前元素是 .</span></span><br><span class="line">            <span class="keyword">if</span>(eSeen || pointSeen) &#123;<span class="comment">//已经出现过 e或者.，则非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pointSeen = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'e'</span>) &#123;<span class="comment">//当前元素 e</span></span><br><span class="line">            <span class="keyword">if</span>(eSeen || !numberSeen) &#123;<span class="comment">//已经出现过 e或者e之前没出现过数字，则非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numberAfterE = <span class="keyword">false</span>;<span class="comment">//注意这点很重要，现在开始记录e之后是否有数字</span></span><br><span class="line">            eSeen = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'-'</span> || s.charAt(i) == <span class="string">'+'</span>) &#123;<span class="comment">//当前元素是-或+</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) != <span class="string">'e'</span>) &#123;<span class="comment">//如果-或+不是第一个元素 或者 之前不是 e</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//当前元素不是0-9、. 、e 、- 、+，非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否有数字并且e之后也有数字</span></span><br><span class="line">    <span class="keyword">return</span> numberSeen &amp;&amp; numberAfterE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>写完暴力法，忍不住给下面这个骚操作点了个赞 : )</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            key=float(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="思路二：确定有限自动机-DFA"><a href="#思路二：确定有限自动机-DFA" class="headerlink" title="思路二：确定有限自动机(DFA)"></a><strong><font color=red>思路二：确定有限自动机(DFA)</font></strong></h3><p>下面搬运自leetcode社区windliang，我不是大佬，我只是大佬的搬运工。</p>
<p>先画出状态转换图：</p>
<p><img src="https://s1.ax1x.com/2020/03/14/8QIq3t.png" alt="8QIq3t.png"></p>
<p>如上图，从 0 开始总共有 9 个状态，橙色代表可接受状态，也就是表示此时是合法数字。总共有四大类输入，数字，小数点，e 和 正负号。我们只需要将这个图实现就够了。</p>
<p>这种方式思路清晰多了，但是之前没有接触过这种方法实现起来还是很生疏的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">0</span>;<span class="comment">//当前状态</span></span><br><span class="line">    s = s.trim();<span class="comment">//去除头尾的空格</span></span><br><span class="line">    <span class="comment">//遍历所有字符，当做输入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line">                <span class="comment">//输入正负号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                    state = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">4</span>) &#123;</span><br><span class="line">                    state = <span class="number">6</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//输入数字</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'6'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'7'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'9'</span>:</span><br><span class="line">                <span class="comment">//根据当前状态去跳转</span></span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        state = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        state = <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                        state = <span class="number">5</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                        state = <span class="number">8</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                        state = <span class="number">8</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//小数点</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        state = <span class="number">7</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        state = <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//e</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                        state = <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//橙色部分的状态代表合法数字</span></span><br><span class="line">    <span class="keyword">return</span> state == <span class="number">2</span> || state == <span class="number">3</span> || state == <span class="number">5</span> || state == <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h3 id="思路三：责任链模式"><a href="#思路三：责任链模式" class="headerlink" title="思路三：责任链模式"></a><strong><font color=red>思路三：责任链模式</font></strong></h3><p>解法二看起来已经很清晰明了了，只需要把状态图画出来，然后实现代码就很简单了。但是缺点是，如果状态图少考虑了东西，再改起来就会很麻烦。</p>
<p>这里作者提出来，利用责任链的设计模式，会使得写出的算法扩展性以及维护性更高。这里用到的思想就是，每个类只判断一种类型。比如判断是否是正数的类，判断是否是小数的类，判断是否是科学计数法的类，这样每个类只关心自己的部分，出了问题很好排查，而且互不影响。</p>
<p>虽然代码变多了，但是维护性，扩展性变的很强了。比如，题目新增了一种情况，”0x123” 16 进制也算是合法数字。这样的话，解法一和解法二就没什么用了，完全得重新设计。但对于解法三，我们只需要新增一个类，专门判断这种情况，然后加到执行者的数组里就够了，很牛逼！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个类都实现这个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NumberValidate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个抽象类，用来检查一些基础的操作，是否为空，去掉首尾空格，去掉 +/-</span></span><br><span class="line"><span class="comment">//doValidate 交给子类自己去实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>  <span class="title">NumberValidateTemplate</span> <span class="keyword">implements</span> <span class="title">NumberValidate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkStringEmpty(s))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = checkAndProcessHeader(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doValidate(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkStringEmpty</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">checkAndProcessHeader</span><span class="params">(String value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = value.trim();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value.startsWith(<span class="string">"+"</span>) || value.startsWith(<span class="string">"-"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            value = value.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是整数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String integer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integer.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(integer.charAt(i)) == <span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是科学计数法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SienceFormatValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> pos = s.indexOf(<span class="string">"e"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String first = s.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String second = s.substring(pos+<span class="number">1</span>, s.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validatePartBeforeE(first) == <span class="keyword">false</span> || validatePartAfterE(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePartBeforeE</span><span class="params">(String first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.equals(<span class="string">""</span>) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHeadAndEndForSpace(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate integerValidate = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        NumberValidate floatValidate = <span class="keyword">new</span> FloatValidate();</span><br><span class="line">        <span class="keyword">if</span> (integerValidate.validate(first) == <span class="keyword">false</span> &amp;&amp; floatValidate.validate(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkHeadAndEndForSpace</span><span class="params">(String part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (part.startsWith(<span class="string">" "</span>) ||</span><br><span class="line">            part.endsWith(<span class="string">" "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePartAfterE</span><span class="params">(String second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (second.equals(<span class="string">""</span>) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHeadAndEndForSpace(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate integerValidate = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        <span class="keyword">if</span> (integerValidate.validate(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是小数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String floatVal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = floatVal.indexOf(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (floatVal.length() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        String first = floatVal.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String second = floatVal.substring(pos + <span class="number">1</span>, floatVal.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkFirstPart(first) == <span class="keyword">true</span> &amp;&amp; checkFirstPart(second) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkFirstPart</span><span class="params">(String first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.equals(<span class="string">""</span>) == <span class="keyword">false</span> &amp;&amp; checkPart(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPart</span><span class="params">(String part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(part.charAt(<span class="number">0</span>)) == <span class="keyword">false</span> ||</span><br><span class="line">            Character.isDigit(part.charAt(part.length() - <span class="number">1</span>)) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        <span class="keyword">if</span> (nv.validate(part) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个执行者，我们把之前实现的各个类加到一个数组里，然后依次调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberValidator</span> <span class="keyword">implements</span> <span class="title">NumberValidate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;NumberValidate&gt; validators = <span class="keyword">new</span> ArrayList&lt;NumberValidate&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberValidator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        addValidators();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">addValidators</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line"></span><br><span class="line">        nv = <span class="keyword">new</span> FloatValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//nv = new HexValidate();</span></span><br><span class="line">        <span class="comment">//validators.add(nv);</span></span><br><span class="line"></span><br><span class="line">        nv = <span class="keyword">new</span> SienceFormatValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (NumberValidate nv : validators)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nv.validate(s) == <span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    NumberValidate nv = <span class="keyword">new</span> NumberValidator();</span><br><span class="line">    <span class="keyword">return</span> nv.validate(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>确定有限自动机</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%20%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="NO-20-有效括号-简单"><a href="#NO-20-有效括号-简单" class="headerlink" title="NO.20 有效括号 简单 "></a>NO.20 有效括号 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFVldS.png" alt="lFVldS.png"></p>
<p><font color=red><strong>思路一：栈</strong></font>  学校的数据结构课就是那这个作为例子来引入栈结构的。1. 遍历表达式中每个字符，如果是’(‘或’[]’或’{‘就放入栈中。2. 如果是’)’或’]’或’}’就弹出栈顶字符top，如果此时栈为空或者将此时被遍历字符和top不匹配，则说明表达式无效。3. 遍历完所有字符，检查栈是否为空，如果不为空则表达式无效，反之有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//        用hashmap存储括号对</span></span><br><span class="line">        HashMap&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line"><span class="comment">//        用栈来保存遍历到的'(' '[' '&#123;'</span></span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"><span class="comment">//            如果map中没有c这个key，则说明c是(或[或&#123;,就存入栈中（题目说只有六种字符）</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c))&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果存在c这个key则说明，c是)或]或&#125;，就需要去和栈顶字符进行匹配</span></span><br><span class="line"><span class="comment">//                如果栈为空，则无法匹配</span></span><br><span class="line">                <span class="keyword">if</span> (stack.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//                取出栈顶元素</span></span><br><span class="line">                Character top = stack.pop();</span><br><span class="line"><span class="comment">//                如果map中c的value和栈顶元素top不相等，则无法匹配</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(c)!=top)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        遍历完所有字符之后，检查栈是否为空，如果为空则匹配，反之无法匹配</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长上升子序列</title>
    <url>/2020/03/14/LeetCode-%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-300-最长上升子序列-中等"><a href="#NO-300-最长上升子序列-中等" class="headerlink" title="NO.300 最长上升子序列 中等 "></a>NO.300 最长上升子序列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8QQPq1.png" alt="8QQPq1.png"></p>
<p>刚看到题，我以为寻找的这个上升子序列需要是连续的递增元素，所以我想双指针。发现行不通，重新审题发现，示例中的子序列元素不是连续的。。。</p>
<h3 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a><strong><font color=red>思路一：动态规划</font></strong></h3><p>dp数组含义：dp[i]nums前i个元素中最长上升子序列的长度。</p>
<p>初始化：初始状态全部为1，因为每个元素自身至少是长度为1子序列。</p>
<p>状态转移：填写dp[i]时遍历j∈[0,i，</p>
<p>如果i元素&gt;j元素则当前元素i可以接在j元素之后作为上升子序列dp[i]=Max(dp[i],dp[j]+1)；</p>
<p>否则i元素&lt;=j元素当前元素i不能拼接在j元素之后就忽略。</p>
<p>每次填写完dp[i]更新当前最长上升子序列长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">//如果i元素&gt;j元素，则i可以接在j元素后面作为上升子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[j])dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最大长度</span></span><br><span class="line">        maxLen=Math.max(maxLen,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h3 id="思路二：TreeSet"><a href="#思路二：TreeSet" class="headerlink" title="思路二：TreeSet"></a><strong><font color=red>思路二：TreeSet</font></strong></h3><p>JAVA Api中的TreeSet有ceiling(x)方法，取大于x的数，如果不存在则返回null。(此方法时间复杂度O(logn)，但是最坏情况下会退化到O(n))</p>
<p>按序遍历nums，到TreeSet中取大于num的数x，如果存在x则删除x并将num加入set，如果不存在就是所有的数都小于num就将num加入set。</p>
<p>最后返回set的大小即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TreeSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        Integer x = set.ceiling(num);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.remove(x);</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏时间复杂度仍然是：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——N皇后II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20N%E7%9A%87%E5%90%8EII/</url>
    <content><![CDATA[<h2 id="NO-52-N皇后II-困难"><a href="#NO-52-N皇后II-困难" class="headerlink" title="NO.52 N皇后II 困难 "></a>NO.52 N皇后II <font color=#ff0099>困难</font> <a id="more"></a></h2><p>NO.52是NO.51的姊妹题，区别在于NO.51要求返回包含”棋子摆放”的List&lt;List&lt;String&gt;&gt;集合，而本题NO.52只需要返回一共有多少种摆法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO.51:public List&lt;List&lt;String&gt;&gt; solveNQueens(int n)</span><br><span class="line">NO.52:public int totalNQueens(int n)</span><br></pre></td></tr></table></figure>

<p><strong><font color=red>思路一：回溯法</font></strong> 看到题的第一反应是直接把上一题回溯法的终止处理”res.add”改成”计数器+1”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//棋盘,默认为0表示空，1表示皇后</span></span><br><span class="line">    <span class="keyword">int</span>[][] board=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//row当前填写得的行号</span></span><br><span class="line">    dfs(n,<span class="number">0</span>,board);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0~n-1都填写完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==n)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsable(board,row,col))&#123;</span><br><span class="line">            board[row][col]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//填写下一行</span></span><br><span class="line">            dfs(n,row+<span class="number">1</span>,board);</span><br><span class="line">            board[row][col]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//board[row][col]是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUsable</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查列上有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查左上至右下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+row-col&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i+row-col][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查右上至左下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row+col-i&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row+col-i][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——Z字形变换</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="NO-6-Z字形变换-中等"><a href="#NO-6-Z字形变换-中等" class="headerlink" title="NO.6 Z字形变换 中等 "></a>NO.6 Z字形变换 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/10/QDB5TA.png" alt="QDB5TA.png"></p>
<p><font color=red><strong>思路一：按列写，按行读</strong></font> 将原字符串按列写成”Z字形”，写好之后按行读取“Z字形”。1.先创建一个有min(numRows,len(s))个元素的list，且list的每个元素都是一个StringBuilder。2.用两个变量分别记录当前是第几行和当前的方向。3.然后将参数字符串中的字符逐一填入。4.仅当前行等于list的第一个参数下标0或者等于numRows-1时方向改变。</p>
<p>这个思路很类似我们动手在纸上将参数字符串写成Z字形的过程，将所有字符逐一写出，在第一行写字符之后写字符的方向变为向下写，在最后一行（numRows）写字符之后写字符的方向变为向上写。当全部写完之后，按行将字符串读出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        List&lt;StringBuilder&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Math.min(numRows,s.length());i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        定义一个变量记录方向，向下为false，向上为true</span></span><br><span class="line">        <span class="keyword">boolean</span> goingDown=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        记录当前是第几行</span></span><br><span class="line">        <span class="keyword">int</span> currentRow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            list.get(currentRow).append(c);</span><br><span class="line"><span class="comment">//            如果当前行下标是第一行或者是最后一行，就改变方向标识</span></span><br><span class="line">            <span class="keyword">if</span> (currentRow==<span class="number">0</span>||currentRow==numRows-<span class="number">1</span>)goingDown=!goingDown;</span><br><span class="line"><span class="comment">//            行下标向当前方向移动，如果true就+1向下移动，如果是false就-1向上移动</span></span><br><span class="line">            currentRow+=goingDown?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        按行读取，获取最后的输出结果</span></span><br><span class="line">        StringBuilder ret=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder stringBuilder : list) &#123;</span><br><span class="line">            ret.append(stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red><strong>思路二：直接按行访问</strong></font>  直接按照将参数字符串写成Z字形之后的结构进行按行访问拼接到结果字符串中。经过观察，可以发现如下规律：对于所有的行i和结果字符串中的字符索引k都有，1. 行0中的字符位于原字符串的k(2*numRows-2)索引处。 2. 行numRows-1中的字符位于原字符串的k(2*numRows-2)+numRows-1索引处。3. 内部的行i中的字符位于原字符串的k(2*numRows-1)+i以及(k+1)(2*numRows-2)-i索引处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> len=s.length();</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//        一个循环长度（Z字形两次方向变换，即向下写到numRows行方向变化为向上再写到0行的长度）</span></span><br><span class="line">    <span class="keyword">int</span> cycleLen=<span class="number">2</span>*numRows-<span class="number">2</span>;</span><br><span class="line"><span class="comment">//        0-numRows行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;len;j+=cycleLen)&#123;</span><br><span class="line">            ans.append(s.charAt(j+i));</span><br><span class="line"><span class="comment">//     当不是第0行且不是第numRows-1行且当前行下一个字符在原字符串中存在时，将当前行下一个字符加入结果串</span></span><br><span class="line"><span class="comment">//                防止遗漏中间行的字符</span></span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>&amp;&amp;i!=numRows-<span class="number">1</span>&amp;&amp;j+cycleLen-i&lt;len)</span><br><span class="line">                ans.append(s.charAt(j+cycleLen-i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——买卖股票的最佳时机</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="NO-121-买卖股票的最佳时机-简单"><a href="#NO-121-买卖股票的最佳时机-简单" class="headerlink" title="NO.121 买卖股票的最佳时机 简单 "></a>NO.121 买卖股票的最佳时机 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/09/3zzoW9.png" alt="3zzoW9.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 没什么好说的，双重循环计算所有元素两两组合相减的结果，取最大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            maxProfit=Math.max(maxProfit,prices[j]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><strong><font color=red>思路二：优化暴力法到一次遍历</font></strong> 买卖股票从第二天开始我们每天都会”后悔”：后悔没有在之前的最低点进行买入，只有这样我们的收益才会最大化。</p>
<p>由此可见，我们想要当天利益最大化，只需要在过去的某个最低点买入股票就好。所以我们只需要记录曾经出现过的最低点就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minPoint=Integer.MAX_VALUE,maxProfit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">//记录曾出现过最低点</span></span><br><span class="line">        minPoint=Math.min(prices[i],minPoint);</span><br><span class="line">        <span class="comment">//当日-曾经的最低</span></span><br><span class="line">        maxProfit=Math.max(maxProfit,prices[i]-minPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>从NO.121题不难看出：<strong><font color=red>买股票的最佳时机是曾经！股市有风险，入股需谨慎！</font></strong>(狗头)</p>
<p>单纯的解答本题是比较简单的，但是买卖股票可以算作是一个系列的经典问题，在leetcode上就有本题一系列的变种问题：买卖股票的最佳时机、买卖股票的最佳时机II、买卖股票的最佳时机III、买卖股票的最佳时机IV、买卖股票的最佳时机含冷冻期、买卖股票的最佳时机含手续费。</p>
<p>虽然这些题有难有易，但是既然是一类问题，就有这一些通用的方法。</p>
<p>这六个问题都是由第四个问题简化变种而来的，第四题相较于本题多了一个参数k，限制只能进行k次交易；第一题也就是本题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种。</p>
<p>之后记一下笔记总结一下这几个问题。</p>
<p>目前找到了”labuladong”大佬的公众号写的一篇《一个方法团灭 6 道股票问题》题解，打算先学习在总结。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——Pow(x,n)</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20Pow(x,n)/</url>
    <content><![CDATA[<h2 id="NO-50-Pow-x-n-中等"><a href="#NO-50-Pow-x-n-中等" class="headerlink" title="NO.50 Pow(x,n) 中等 "></a>NO.50 Pow(x,n) <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/07/1gKljg.png" alt="1gKljg.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 这道题暴力法是不能通过leetcode判题机，会得到一个t。但是方法本身是可以得到正确答案的，所以我们需要对他进行优化。暴力法的想法很简单的：2^3=2*2*2。</p>
<p>如果n为负，则n=-n同时x=1/x，例如2^(-3)=1/2*1/2*1/2。但是这里要注意n的取值范围，主要是 正整数和负整数的不同范围限制 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> N=n;</span><br><span class="line">    <span class="keyword">if</span> (N&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        N=-N;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        ans*=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：二分法</font></strong> 当我们得到x^(n/2)的时候，我们不需要再去乘上n/2个x了，而是x^(n/2)*x^(n/2)=x^n。</p>
<p>这个想法用递归很容易实现，但是需要注意的是n的奇偶性，如果n为奇数则需要再乘上一个x。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> half=myPow(x,n/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//奇偶性处理</span></span><br><span class="line">    <span class="keyword">double</span> rest=myPow(x,n%<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> half*half*rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——第K个排列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E7%AC%ACK%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-60-第K个排列-中等"><a href="#NO-60-第K个排列-中等" class="headerlink" title="NO.60 第K个排列 中等 "></a>NO.60 第K个排列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/08/3x0skq.png" alt="3x0skq.png"></p>
<p><strong><font color=red>思路一：逆用康托展开</font></strong> 什么是康托展开式可以先从百度了解。本文直接从示例着手。</p>
<p>利用康托展开求排列是第几个，例如”213”是n=3的全排列中的第几个？<img src="https://s2.ax1x.com/2020/03/08/3x5LgH.png" alt="3x5LgH.png"></p>
<p>其实就是找出比”213”小的排列有几个，然后+1。</p>
<p>先比较首位，比2小的只有1，1开头的排列有1*2!个。</p>
<p>第二位比1小的不存在所以有0*1!排列。</p>
<p>第三位比3小的有1和2但是前面已经用过所以有0*0!个。</p>
<p>综上所述，有2个比”213”小的排列，所以”213”排在第3位。</p>
<p><strong>本题是逆用，知道n和第k个，求排列本身。</strong></p>
<p>例如：要找n=5，k=35的排列。共有5!=120个排列，从小到大要找第35个排列。</p>
<p>从首位开始找，首位分别是1、2、3、4、5的排列分成五组，每组各有(5-1)!=24个，由于k=35，所以要找的排列在第二组中，就是首位是2开头的24个排列中，即目标排列首位是”2”。</p>
<p>再看第二位，第二位可能是1、3、4、5分成四组，每组分别有(5-2)!=6个，由于k-24=11，所以要找的排列在第二组中，即目标排列的前两位是”23”。</p>
<p>同理，第三位可能是1、4、5分成三组，每组分别有(5-3)!=2个，因为k-6=5，所以要找的排列在第三组的两个排列中，即目标排列的前三位是”235”。</p>
<p>再然后第四位可能是1、4，分两组各有(5-4)!=1个，因为k-4=1，所以在第一组，即目标排列的前四位是”2351”。</p>
<p>最后第五位只剩下4，所以目标排列是”23514”。</p>
<p>找到第35个排列。</p>
<p><strong>其实这个方法就是分组，上例中找第一位时候将有序全排列按照首位数字分为5组，看看我们要找的那个排列在第几组中从而确定了首位数字。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//所有可用数字</span></span><br><span class="line">    StringBuilder map=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)map.append(i);</span><br><span class="line">    <span class="keyword">int</span> groupId,index=n;</span><br><span class="line">    <span class="comment">//逐位确定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//确定在当前分组的第几组</span></span><br><span class="line">        groupId=(k-<span class="number">1</span>)/foc(index);</span><br><span class="line">        <span class="comment">//得到分组的数字，移除使用过的数字</span></span><br><span class="line">        ans.append(map.charAt(groupId));</span><br><span class="line">        map.deleteCharAt(groupId);</span><br><span class="line">        <span class="comment">//更新k</span></span><br><span class="line">        k-=groupId*foc(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求 i!</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">foc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        x*=i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)    题目说n的范围[1,9]，可以直接将1~9的阶乘预先保存在一个数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//0~9的阶乘,直接使用</span></span><br><span class="line">    <span class="keyword">int</span> factor[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;</span><br><span class="line">    <span class="comment">//所有可用数字</span></span><br><span class="line">    StringBuilder map=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)map.append(i);</span><br><span class="line">    <span class="keyword">int</span> groupId,index=n;</span><br><span class="line">    <span class="comment">//逐位确定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//确定在当前分组的第几组</span></span><br><span class="line">        groupId=(k-<span class="number">1</span>)/factor[index];</span><br><span class="line">        <span class="comment">//得到分组的数字，移除使用过的数字</span></span><br><span class="line">        ans.append(map.charAt(groupId));</span><br><span class="line">        map.deleteCharAt(groupId);</span><br><span class="line">        <span class="comment">//更新k</span></span><br><span class="line">        k-=groupId*factor[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>康托展开式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——解数独</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="NO-37-解数独-困难"><a href="#NO-37-解数独-困难" class="headerlink" title="NO.37 解数独 困难 "></a>NO.37 解数独 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/23/310IhV.png" alt="310IhV.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3105t0.png" alt="3105t0.png"></p>
<p><strong><font color=red>思路一：回溯法</font></strong> 就是模拟人解数独时的简单想法：</p>
<ol>
<li>人在解数独的时候要注意每一行、每一列、每一个子数独中哪些数字已经被使用过了；</li>
<li>一行一行的进行填充，填充完一行就聚焦到下一行继续填充；</li>
<li>如果一个单元格中不为空，则去下一个单元格；</li>
<li>如果一个单元格为空，我们就看一下这个单元格所属的行、列、子数独中有哪些数字没有使用过，就将未使用过的数字填入单元格，并且记录这个被填入的数字在此单元格所属的行、列、子数独中已经被使用过了；</li>
<li>如果出现因为之前填充空格时选择不佳，导致无法继续填写空格的情况，就逐步擦除之前填入的数字，并将被擦除的数字在所属的行、列、子数独中设置为未使用的状态后，重新选择下一个未使用过的数字进行填充，尝试继续完成填充；</li>
<li>如果已经填充完所有行，即成功解数独。</li>
</ol>
<p>通过描述”我”解这类数独时的朴素想法，我们大概知道编码的方法了：</p>
<ol>
<li>大方向上，我们就是对需要填写的空白格进行尝试，不断地将每个空白格填写上当前状态可用的数字。当填写逐步推进的过程中，如果出现无法满足要求的组合时，就返回并擦除填写的数字，直至得到一个完全符合要求的组合。<u>这个过程就是典型的dfs剪枝回溯的思路。</u></li>
<li>我们需要实时的记录更新每一行、每一列、每一个子数独中1~9数字的使用情况。<u>这里可以用三大小为9*9的boolean类型数组分别记录，初始化为false表示都未使用，遍历初始数独将已使用过的数字记录为true表示已使用。</u></li>
<li>回溯方法中需要按行逐步推进，所有行都填写完毕即完成解数独。<u>编写时需要时刻记录当前填写的行和被填写的列。</u></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三个数组分别记录9行、9列、9个子数独中9个数字的使用状态，finished记录是否完成解数独</span></span><br><span class="line"><span class="keyword">boolean</span>[][] rows=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>],cols=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>],blocks=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">boolean</span> finished=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//解数独方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化状态数组，遍历初始数独，将使用过的数字的状态置为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                rows[row][board[row][col]-<span class="string">'1'</span>]=</span><br><span class="line">                    cols[col][board[row][col]-<span class="string">'1'</span>]=</span><br><span class="line">                    blocks[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][board[row][col]-<span class="string">'1'</span>]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度遍历，row记录当前要填写的行，col记录当前要填写的列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0-8行都已经填写，解数独完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==<span class="number">9</span>)&#123;</span><br><span class="line">        finished=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是空白格，不需要填写，继续向后移动</span></span><br><span class="line">    <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>)&#123;</span><br><span class="line">        <span class="comment">//如果本行已经是最后一列，则继续填写下一行的第一列；否则继续当前行的下一列。</span></span><br><span class="line">        <span class="keyword">if</span> (col==<span class="number">8</span>) dfs(board,row+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> dfs(board,row,col+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//按顺序将当前行、列、子数独未使用的数字尝试填入空白格</span></span><br><span class="line">        <span class="keyword">int</span> block = row / <span class="number">3</span> * <span class="number">3</span> + col / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//如果i+1未使用，可以填入当前空白格</span></span><br><span class="line">            <span class="keyword">if</span> (!rows[row][i] &amp;&amp; !cols[col][i] &amp;&amp; !blocks[block][i])&#123;</span><br><span class="line">                board[row][col]=(<span class="keyword">char</span>)(i+<span class="string">'1'</span>);</span><br><span class="line">                <span class="comment">//更新被入数字的状态</span></span><br><span class="line">                rows[row][i]=cols[col][i]=blocks[block][i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//填写完毕当前空白格，继续填写一格</span></span><br><span class="line">                <span class="keyword">if</span> (col==<span class="number">8</span>)dfs(board,row+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> dfs(board,row,col+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果当前尝试填入的数字组合不能成功解数独(导致后序空白格无法填写)，则回溯</span></span><br><span class="line">                <span class="keyword">if</span> (!finished)&#123;</span><br><span class="line">                    <span class="comment">//擦除填入的数字，并更新被擦除数字的状态</span></span><br><span class="line">                    board[row][col]=<span class="string">'.'</span>;</span><br><span class="line">                    rows[row][i]=cols[col][i]=blocks[block][i]=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看着长，除去注释其实没多少。而且这道题思路比较简单清晰易懂。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——删除排序数组中的重复项</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="NO-26-删除排序数组中的重复项-简单"><a href="#NO-26-删除排序数组中的重复项-简单" class="headerlink" title="NO.26 删除排序数组中的重复项 简单 "></a>NO.26 删除排序数组中的重复项 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZCsTU.png" alt="lZCsTU.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/27/lZCrwT.png" alt="lZCrwT.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 题目中给了两个关键点需要特别思考”原地”和”不需要考虑数组中超出新长度后面的元素”，所谓的”原地”就是不需要创建新的数组将不重复的元素复制过去，只需要在原数组中进行”覆盖”即可；所谓”不需要考虑数组中超出新长度后面的元素”就是只需要将不重复元素都”紧凑到原数组的前面”，如：[1,1,1,2,3,3,4,6]遵循上述两个点进行”覆盖”和”紧凑”的结果[1,2,3,4,6,3,4,6]，算法的返回值为新长度5。</p>
<p>可以用两个指针i和j分别指向0号和1号元素，如果j指向的元素和i指向的元素相等就移动j指针，如果不相等则先移动i指针再让j指向的元素覆盖此时i指向的元素最后移动j指针，直至j指针遍历完所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="comment">//            如果不相等,则先移动i指针再让j指向的元素覆盖此时i指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——四数之和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-18-四数之和-中等"><a href="#NO-18-四数之和-中等" class="headerlink" title="NO.18 四数之和 中等 "></a>NO.18 四数之和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/19/QLB8Qs.png" alt="QLB8Qs.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 熟悉的配方，熟悉的味道，回想“2.两数之和”和“15.三数之和”分别是如何计算的。这里我的思路是将二者相结合形参这道“四数之和”的算法：1.因为需要用到双指针法，所以先将数组排序。2. 遍历数组每个元素nums[i]的时候计算其于target的差值temp（这里有点两数之和的味道）。3. 同时在nums[i]元素后面的部分寻找是否有三个数相加等于temp（这里就是进行双指针法解三数之和，具体思路参考<a href="https://jerrymouse1998.github.io/post/%E5%BE%92%E6%89%8B%E6%8C%96%E5%9C%B0%E7%90%83%E5%85%AD%E5%91%A8%E7%9B%AE/">徒手挖地球六周目</a>中的三数之和双指针法思路），如果找到三数和等于temp就将这三个数和nums[i]加入结果集。5. 在nums[i]元素后面的部分进行双指针法全部遍历完后，对nums[i+1]进行上述操作，直至数组中所有元素都进行完毕。</p>
<p>和”三数之和”一样需要”<strong>去重</strong>“：1. 外层for遍历每个元素nums[i]时，除了0号元素之外如果nums[i]==nums[i+1]，则需要跳过。2. 内层循环除了第一个元素之外，如果nums[j]==nums[j+1],也需要跳过。</p>
<p>可以<strong>优化</strong>的地方：1. 固定当前nums[i]元素后，最小的四数之和已经大于target，则结束循环。2.固定当前nums[i]元素后，当前最大的四数之和依然小于target，则跳过当前元素，进行下一个元素nums[i+1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">4</span>)<span class="keyword">return</span> ans;</span><br><span class="line"><span class="comment">//        排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历数组每一个元素,因为是求四数之和，所以i&lt;len-3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="comment">//            如果当前最小的四数之和已经大于target，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt; target)<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//            如果当前最大的四数之和依然小于target，则跳过当前元素，进行下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[len-<span class="number">1</span>]+nums[len-<span class="number">2</span>]+nums[len-<span class="number">3</span>]&lt; target)<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            跳过重复的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            当前数组想要组成target所需要的值</span></span><br><span class="line">            <span class="keyword">int</span> temp=target-nums[i];</span><br><span class="line">            </span><br><span class="line"><span class="comment">//            遍历i号元素后面部分的每个元素，因为是求三数之和，所以i&lt;len-2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len-<span class="number">2</span>;j++)&#123;</span><br><span class="line"><span class="comment">//                跳过重复元素</span></span><br><span class="line">                <span class="keyword">if</span> (j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//                用双指针分别指向j号元素后面部分的开始元素和结尾元素</span></span><br><span class="line">                <span class="keyword">int</span> L=j+<span class="number">1</span>,R=len-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[j]+nums[L]+nums[R];</span><br><span class="line">                    <span class="keyword">if</span> (sum==temp)&#123;</span><br><span class="line">                        ans.add(Arrays.asList(nums[i],nums[j],nums[L],nums[R]));</span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[L]==nums[L+<span class="number">1</span>])L++;</span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[R]==nums[R-<span class="number">1</span>])R--;</span><br><span class="line">                        L++;</span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;temp)&#123;</span><br><span class="line">                        L++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;temp)&#123;</span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长回文子串</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="NO-5-最长回文子串-中等"><a href="#NO-5-最长回文子串-中等" class="headerlink" title="NO.5 最长回文子串 中等 "></a>NO.5 最长回文子串 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/05/Q8ZSII.png" alt="Q8ZSII.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 用两个for循环划分出所有子串，并依次判断划分出的子串是否为回文，如果是回文并且子串长度大于ans当前记录的值，就更新ans。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String ans=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s.substring(i,j))&amp;&amp;len&lt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                ans=s.substring(i,j);</span><br><span class="line">                len=Math.max(len,ans.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)!=s.charAt(s.length()-<span class="number">1</span>-i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^3)</p>
<p><font color=red><strong>思路二：扩展中心法</strong></font> 经过对回文特点的观察发现，回文都是中心对称的。所以我们可以从中心进行展开判断，一个长度为n的字符串中有2n-1个中心（因为回文长度有可能是基数或偶数，基数回文的中心有n个，如abc中心是b；偶数回文的中心有n-1个，如abbc中心是bb）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        如果是空串，则直接返回空串表示没有回文串</span></span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.length()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line"><span class="comment">//            判断i为中心的基数回文长度</span></span><br><span class="line">            <span class="keyword">int</span> len1=expandAroundCenter(s,i,i);</span><br><span class="line"><span class="comment">//            判断i，i+1为中心的偶数回文长度</span></span><br><span class="line">            <span class="keyword">int</span> len2=expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len=Math.max(len1,len2);</span><br><span class="line"><span class="comment">//            如果新回文串的长度大于之前的回文串长度，则更新</span></span><br><span class="line">            <span class="keyword">if</span> (len&gt;end-start)&#123;</span><br><span class="line"><span class="comment">//                </span></span><br><span class="line">                start=i-(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        因为substring()方法截取的范围是[起始索引,结束索引)，所以第二个参数需要+1</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="comment">//        当左标记大于等于0,且右标记小于输入串长，且当前左右标记的字符相等时，左右标记分别中心扩展</span></span><br><span class="line">        <span class="keyword">while</span> (left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        返回以i或(i，i+1)为中心的回文串长度。</span></span><br><span class="line">        <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><font color=red><strong>思路三：最长公共子串法(LCS)</strong></font> 回文是从左向右读和从右向左读都是一样的，所以我们可以将原字符串s倒置之后获得s’，然后取s和s’的最长公共子串ans作为最长回文子串。</p>
<p>用动态规划法求最长公共子串，大概思路是：1.申请一个二维数组arr[s.length][s’.length]。2.判断每个对应位置的字符是否相等，如果相等 arr[i][j]=arr[i-1][j-1]+1；当i=0或j=0时候单独分析，如果对应位置字符相等 arr[i][j]=1。(<strong>PS：</strong>arr[i][j]保存的就是公共子串的长度。)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String origin=s;</span><br><span class="line"><span class="comment">//        倒置原字符串</span></span><br><span class="line">        String reverse=<span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line"><span class="comment">//        maxLen记录最长公共子序列，maxEnd记录最长公共子序列的结尾下标</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>,maxEnd=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        分别以原字符串长度和倒置字符串长度来表示，是为了更直观的理解该二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr=<span class="keyword">new</span> <span class="keyword">int</span>[origin.length()][reverse.length()];</span><br><span class="line"><span class="comment">//        双重循环遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;reverse.length();j++)&#123;</span><br><span class="line"><span class="comment">//                判断原字符串i位置字符和倒置字符串j位置字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (origin.charAt(i)==reverse.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;<span class="comment">//当i=0或j=0时候单独分析，如果对应位置字符相等 arr[i][j]=1</span></span><br><span class="line">                        arr[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        arr[i][j]=arr[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                如果当前公共子串长度比maxLen所记录的值更大，则更新最长公共子串的长度及其结束下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i][j]&gt;maxLen)&#123;</span><br><span class="line">                    maxLen=arr[i][j];</span><br><span class="line">                    maxEnd=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxEnd-maxLen+<span class="number">1</span>,maxEnd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>当S=”abc435cba”，S’=”abc534cba”时，上述算法依然可以计算出最长公共子串”abc”来作为最长回文子串，这显然是不对的。</font>对于这个问题的解决思路是：1.因为j一直指向倒置字符串中子串的末尾字符，可以先求出j指向的字符X倒置之前的下标beforeReverse=length-1-j。2.此时求出的beforeReverse是X在<strong>原字符串中的子串首位的下标</strong>，还需要加上当前子串的长度才是<strong>原字符串中子串末尾的下标</strong>e，即e=beforeReverse+arr[i][j]-1。3.因为i一直指向原字符串中子串的末尾字符，所以将e与i进行比较，如果相等，则说明当前找到的公共子串是回文子串。</p>
<p>例如，字符串倒置前后分别是S=”abc435cba”，S’=”abc534cba”，当i=2且j=2时，arr[2][2]=3,然后进行计算出beforeReverse=length-1-j=9-1-2=6，判断beforeReverse+arr[2][2]-1是否等于i，显然 6+3-1!=2，所以当前子串不是回文子串且不需要更新maxLen和maxEnd。</p>
<p><img src="https://s2.ax1x.com/2019/12/08/Qamn76.png" alt="Qamn76.png"></p>
<p>针对该思路，只需要在更新maxLen和maxEnd之前添加<strong>下标是否匹配的判断</strong>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String origin=s;</span><br><span class="line"><span class="comment">//        倒置原字符串</span></span><br><span class="line">        String reverse=<span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line"><span class="comment">//        maxLen记录最长公共子序列，maxEnd记录最长公共子序列的结尾下标</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>,maxEnd=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        分别以原字符串长度和倒置字符串长度来表示，是为了更直观的理解该二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr=<span class="keyword">new</span> <span class="keyword">int</span>[origin.length()][reverse.length()];</span><br><span class="line"><span class="comment">//        双重循环遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;reverse.length();j++)&#123;</span><br><span class="line"><span class="comment">//                判断原字符串i位置字符和倒置字符串j位置字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (origin.charAt(i)==reverse.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;<span class="comment">//当i=0或j=0时候单独分析，如果对应位置字符相等 arr[i][j]=1</span></span><br><span class="line">                        arr[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        arr[i][j]=arr[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                如果当前公共子串长度比maxLen所记录的值更大，则更新最长公共子串的长度及其结束下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i][j]&gt;maxLen)&#123;</span><br><span class="line">                    <span class="keyword">int</span> beforeReverse=origin.length()-<span class="number">1</span>-j;</span><br><span class="line"><span class="comment">//					  添加下标是否匹配的判断                 </span></span><br><span class="line">                    <span class="keyword">if</span> (beforeReverse+arr[i][j]-<span class="number">1</span>==i) &#123;</span><br><span class="line">                        maxLen = arr[i][j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxEnd-maxLen+<span class="number">1</span>,maxEnd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^2)</p>
<p>写到这里，利用LCS算法解决求最长回文子串的问题已经基本完成了,经过查阅资料和学习之后发现：其实可以使用一个一位数组即可，而不必使用上述的二维数组arr[][]。空间复杂度从之前的用二维数组时的O(n^2)降到了用一维数组后的O(n)。</p>
<p>例如还是上面的那个数组S=”abc435cba”，i=0，j=1、2、3、4、5、6、7、8更新了第一列；i=2j=1、2、3、4、5、6、7、8更新了第二列，以此类推直到i=8且j=8每一列都更新完毕。但是经过观察发现，每次更新时只需要参考前一列的值，更新第三列时，第一列的值就用不到了，所以只需要一个一维数组就可以了。但是，更新arr[i]的时候需要arr[i-1]的值，例如arr[3]=arr[2]+1，arr[4]=arr[3]+1，此时的arr[3]的信息已经被更新过了并不是”之前一列的信息了“，所以循环时j不能从0到8递增，应该倒过来，arr[8]=arr[7]+1、arr[7]=arr[6]+1。。。更新arr[8]时用arr[7]，用完之后才能去更新arr[7]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String origin=s;</span><br><span class="line"><span class="comment">//        倒置原字符串</span></span><br><span class="line">        String reverse=<span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line"><span class="comment">//        maxLen记录最长公共子序列，maxEnd记录最长公共子序列的结尾下标</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>,maxEnd=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        分别以原字符串长度和倒置字符串长度来表示，是为了更直观的理解该二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="comment">//        双重循环遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=reverse.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="comment">//                判断原字符串i位置字符和倒置字符串j位置字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (origin.charAt(i)==reverse.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;<span class="comment">//当i=0或j=0时候单独分析，如果对应位置字符相等 arr[j]=1</span></span><br><span class="line">                        arr[j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        arr[j]=arr[j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//之前是二维数组每一列默认值就是0，现在是一维数组所以需要手动更新为0</span></span><br><span class="line">                    arr[j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                如果当前公共子串长度比maxLen所记录的值更大，则更新最长公共子串的长度及其结束下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;maxLen)&#123;</span><br><span class="line">                    <span class="keyword">int</span> beforeReverse=origin.length()-<span class="number">1</span>-j;</span><br><span class="line">                    <span class="keyword">if</span> (beforeReverse+arr[j]-<span class="number">1</span>==i) &#123;</span><br><span class="line">                        maxLen = arr[j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxEnd-maxLen+<span class="number">1</span>,maxEnd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路四：Manacher算法</strong></font> 在扩展中心算法中，将奇数长度回文子串和偶数长度的回文子串分别进行了处理。本算法首先解决了奇数和偶数的问题，在每个字符间插入“#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入“^”和“$”，这样重心扩展的时候，判断两端字符是否相等时，如果到了边界就一定不会相等，从而结束循环（这里的“#”“^”“$”是字符串中不存在的字符）。并且，经过插入特殊字符处理后，字符串的长度永远都是奇数了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，</span><br><span class="line">	&quot;aba&quot; 扩展为 &quot;^#a#b#a#$&quot;</span><br><span class="line">	&quot;acca&quot; 扩展为 &quot;^#a#c#c#a#$&quot;</span><br><span class="line">	&quot;cbcbccde&quot; 扩展为 &quot;^#c#b#c#b#c#c#d#e#$&quot;</span><br></pre></td></tr></table></figure>

<p>字符串扩展之后，我们申请一个数组p[]保存从中心扩展的最大个数，而这个数也刚好是去掉”#“之后原子串的长度。例如下图中下标为6的字符，p[6]=5,所以它是从左边扩展5个字符，相应的右边也是扩展5个字符，也就是“#c#b#c#b#c#”。而去掉“#”恢复到原来的子串，变成“cbcbc”，它的长度刚好也是5。</p>
<p><img src="https://s2.ax1x.com/2019/12/08/QawkCQ.png" alt="QawkCQ.png"></p>
<p><strong>求原字符串下标</strong>：用p的下标i减去p[i]，再除以2，就是原字符串的开头下标了。例如，我们找到上图中p[i]最大值为5，也就是回文串的最大长度是5，对应的下标是6，所以原子串在原字符串中的开头下标是（6-5）/2=0。所以我们只需要返回原字符串的第0到第（5-1）位就可以了。</p>
<p>既然已经知道了如何利用p[]数组巧妙地取得结果子串了，那么就要进行马拉车算法最重要的步骤了，即<strong>如何求p[]数组？</strong></p>
<p>这一步是马拉车算法的精髓所在，充分利用的回文的对称性。用c表示回文子串的中心，用r表示回文子串的右边半径。所以r=c+p[i]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串，而不一定是最长的回文串。</p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0m8Ld.png" alt="Q0m8Ld.png"></p>
<p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。 我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串中心 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。</p>
<p><font color=green>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论:</font></p>
<p><font color=green><strong>情况一：超出了 R</strong></font></p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0mJeA.png" alt="Q0mJeA.png"></p>
<p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
<p><font color=green><strong>情况二：P [ i_mirror ] 遇到了原字符串的左边界</strong></font></p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0mtot.png" alt="Q0mtot.png"></p>
<p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
<p><font color=green><strong>情况三：i 等于了 R</strong></font></p>
<p>此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。</p>
<p><strong>考虑 C 和 R 的更新</strong><br>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0mYdI.png" alt="Q0mYdI.png"></p>
<p>此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        获取扩充后的字符串T</span></span><br><span class="line">        String T=preProsess(s);</span><br><span class="line">        <span class="keyword">int</span> len=T.length();</span><br><span class="line">        <span class="keyword">int</span>[] p=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        不需要判断前后边界字符“^"和“$”，所以循环范围是[1,len-1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="comment">//            第i个字符关于c对称的下标</span></span><br><span class="line">            <span class="keyword">int</span> i_mirror=<span class="number">2</span>*c-i;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;i)&#123;<span class="comment">//如果i小于对称半径r</span></span><br><span class="line">                p[i]=Math.max(r-i,p[i_mirror]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            遇到三种特殊情况时，需要退化到中心扩展法</span></span><br><span class="line">            <span class="keyword">while</span> (T.charAt(i+<span class="number">1</span>+p[i])==T.charAt(i-<span class="number">1</span>-p[i]))&#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            判断是否需要更新c和r</span></span><br><span class="line">            <span class="keyword">if</span> (i+p[i]&gt;r)&#123;</span><br><span class="line">                c=i;</span><br><span class="line">                r=p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        找出p[]数组中最大的值</span></span><br><span class="line">        <span class="keyword">int</span> currentIndex=<span class="number">0</span>,maxLen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i]&gt;maxLen)&#123;</span><br><span class="line">                currentIndex=i;</span><br><span class="line">                maxLen=p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        求子串首字符在原字符串中的下标</span></span><br><span class="line">        <span class="keyword">int</span> start=(currentIndex-maxLen)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    扩充字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">preProsess</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">"$"</span>;</span><br><span class="line">        String result=<span class="string">"^"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            result+=<span class="string">"#"</span>+s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        result+=<span class="string">"#$"</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Manacher算法</tag>
        <tag>中心扩展</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——N皇后</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h2 id="NO-51-N皇后-困难"><a href="#NO-51-N皇后-困难" class="headerlink" title="NO.51 N皇后 困难 "></a>NO.51 N皇后 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/28/3BxeVe.png" alt="3BxeVe.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/28/3Bxn5d.png" alt="3Bxn5d.png"></p>
<p>ps：皇后可以攻击同一行、同一列以及左上角、右上角、左下角、右下角这些角度方向上的任意单位。</p>
<p><strong><font color=red>思路一：回溯法</font></strong> 这道题使用回溯法的思路和<a href="http://www.m1ng.top/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%A7%A3%E6%95%B0%E7%8B%AC/" target="_blank" rel="noopener">NO.37解数独</a>类似，每次填入一个元素就会导致增加后序填写时的约束条件。尝试依次填写的过程中无法继续时，就回溯并继续尝试另一种填写序列。</p>
<p>本题深度遍历回溯方法的骨架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dfs(棋盘board,当前行row,n)&#123;</span><br><span class="line">	if(终止条件)&#123;</span><br><span class="line">		保存当前序列;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    	if(board[row][i]可以填写)&#123;</span><br><span class="line">    		当前格子board[row][i]&#x3D;1;</span><br><span class="line">    		填写下一行dfs(board,row+1,n);</span><br><span class="line">    		擦除填写，验证下一个序列board[row][i]&#x3D;0;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终止条件是什么：棋盘的0~n-1行都填写完毕，即row==n。</p>
<p>如何保存当前序列：棋盘使用int[][]数组表示，0为’.’，1为’Q’。遍历每一行转换为字符串存入list，最后list存入结果。</p>
<p>如何判断当前格子是否可以：遍历当前列上是否已经有皇后；遍历当前左上至右下对角线上是否已经有皇后；遍历当前右上至左下对角线上是否已经有皇后。这些遍历只需要检测小于当前的行，因为大于当前的行还没有填写到一定没有皇后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//棋盘,默认为0表示空，1表示皇后</span></span><br><span class="line">    <span class="keyword">int</span>[][] board=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//row当前填写得的行号</span></span><br><span class="line">    dfs(n,<span class="number">0</span>,board);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0~n-1都填写完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==n)&#123;</span><br><span class="line">        res.add(track(board,n));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsable(board,row,col))&#123;</span><br><span class="line">            board[row][col]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//填写下一行</span></span><br><span class="line">            dfs(n,row+<span class="number">1</span>,board);</span><br><span class="line">            board[row][col]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//board[row][col]是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUsable</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查列上有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查左上至右下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+row-col&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i+row-col][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查右上至左下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row+col-i&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row+col-i][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将int类型棋盘转换成输出格式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">track</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j]==<span class="number">0</span>)temp.append(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">else</span> temp.append(<span class="string">'Q'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(temp.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——不同路径</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="NO-62-不同路径-中等"><a href="#NO-62-不同路径-中等" class="headerlink" title="NO.62 不同路径 中等 "></a>NO.62 不同路径 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/10/8ioaGR.png" alt="8ioaGR.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/10/8ioUi9.png" alt="8ioUi9.png"></p>
<p><strong><font  color=red>思路一：动态规划</font></strong> 只能向下或向右，就是无法后退或者绕路且到达终点的步数是确定的。</p>
<p>dp[][]数组的含义：dp[i][j]就是到到i行j列的位置有多少种走法。</p>
<p>初始化：dp[0][0]~dp[0][n-1]即第一列和dp[0][0]~dp[0][n-1]即第一行因为只有向下或向右移动，所以都只有1走法可以到达。</p>
<p>状态转移：除了第一行、第一列，dp[i][j]=dp[i-1][j]+dp[i][j-1]，还是因为只能向下或向右移动，所以dp[i][j]的一定是从其上面的[i][j-1]或左面的[i-1][j]移动而来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——K个一组翻转链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-25-K个一组翻转链表-困难"><a href="#NO-25-K个一组翻转链表-困难" class="headerlink" title="NO.25 K个一组翻转链表 困难 "></a>NO.25 K个一组翻转链表 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/17/3C5wuV.png" alt="3C5wuV.png"></p>
<p><strong><font color=red>思路一：迭代实现</font></strong> 和<a href="https://blog.csdn.net/qq_42758551/article/details/103796292" target="_blank" rel="noopener">徒手挖地球九周目</a>中NO.24两两交换链表中的节点的迭代法思路一样，不过NO.24题中的k是2而已。</p>
<ol>
<li>哑节点dummy。pre指向待翻转子链表的前驱，end指向待翻转子链表的尾节点。然后，<font color=#3366cc>start</font>指向待翻转子链表的头节点，<font color=#3366cc>next</font>指向待翻转子链表的后继。最后断开待翻转子链表和剩余链表，翻转第一组。<img src="https://s2.ax1x.com/2020/02/17/3PuodI.png" alt="3PuodI.png"></li>
<li>反转完成之后，将<font color=#3366cc>start</font>节点和<font color=#3366cc>next</font>节点连接。移动<font color=#009966>pre</font>指向<font color=#3366cc>start</font>节点，<font color=#009966>end</font>指向<font color=#009966>pre</font>节点，检查<font color=#009966>end.next</font>不为空，所以向后移动<font color=#009966>end</font>到下一组待翻转子链表的尾节点，<font color=#009966>start</font>指向待翻转子链表的头节点，<font color=#009966>next</font>指向待翻转子链表的后继。翻转第二组。<img src="https://s2.ax1x.com/2020/02/17/3PuIeA.png" alt="3PuIeA.png"></li>
<li>第二组翻转完成，将<font color=#009966>start</font>节点和<font color=#009966>next</font>节点连接。移动<font color=#cc9900>pre</font>指向<font color=#009966>start</font>节点，<font color=#cc9900>end</font>指向<font color=#cc9900>pre</font>节点，检查<font color=#cc9900>end.next</font>不为空，所以向后移动<font color=#cc9900>end</font>，但是剩余节点不足k个。所以翻转全部，返回dummy.next。<img src="https://s2.ax1x.com/2020/02/17/3PKv9K.png" alt="3PKv9K.png"></li>
</ol>
<p>这里还有一个问题就是如何翻转子链表reverse(head)？用上述第一组子链表为例：</p>
<p>curr指向当前节点，pre指向curr之前节点，next指向curr之后节点，翻转过程比较简单，直接看图。</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3PGPHg.png" alt="3PGPHg.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/17/3PGSjf.png" alt="3PGSjf.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/17/3PG9u8.png" alt="3PG9u8.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/17/3P8zgP.png" alt="3P8zgP.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">1</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//初始化哑节点、pre、end</span></span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next=head;</span><br><span class="line">    ListNode pre=dummy,end=dummy;</span><br><span class="line">    <span class="keyword">while</span> (end.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//移动end指向待翻转子链表的尾部,如果剩余节点不足k个，则翻转完成返回head</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k&amp;&amp; end!=<span class="keyword">null</span>; i++) end=end.next;</span><br><span class="line">        <span class="keyword">if</span> (end==<span class="keyword">null</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//start指向待翻转子链表头节点，next指向未翻转部分的头节点</span></span><br><span class="line">        ListNode start=pre.next,next=end.next;</span><br><span class="line">        end.next=<span class="keyword">null</span>;</span><br><span class="line">        pre.next=reverse(start);</span><br><span class="line">        <span class="comment">//连接完成翻转部分和未翻转部分</span></span><br><span class="line">        start.next=next;</span><br><span class="line">        <span class="comment">//移动pre和end</span></span><br><span class="line">        pre=start;</span><br><span class="line">        end=pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//翻转子链表</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre=<span class="keyword">null</span>,curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next=curr.next;</span><br><span class="line">        curr.next=pre;</span><br><span class="line">        pre=curr;</span><br><span class="line">        curr=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nk)   n是节点总数。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——跳跃游戏II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
    <content><![CDATA[<h2 id="NO-45-跳跃游戏II-困难"><a href="#NO-45-跳跃游戏II-困难" class="headerlink" title="NO.45 跳跃游戏II 困难 "></a>NO.45 跳跃游戏II <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/26/3an8VP.png" alt="3an8VP.png"></p>
<p><strong><font color=red>思路一：贪心算法</font></strong> nums[i]表示的可以跳入的最大范围，如果当前nums[i]所能跳到的范围不涉及重点，那么就在当前能跳到的范围内选择一个最优的点(可以跳出更远的范围的点)，因为如果这个最优点都不能跳到终点，那么其他的点更不能跳到。</p>
<p>这种每一步都选择最优来保证最终结果的最优性的方法就是典型的贪心算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//end当前能跳到的最远点，steps跳的步数，maxposition能跳的最远的距离</span></span><br><span class="line">    <span class="keyword">int</span> end=<span class="number">0</span>,steps=<span class="number">0</span>,maxPosition=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意是：i&lt;length-1，如果最后一跳最远距离刚好到达终点会导致额外一次steps++</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//在当前可跳的范围内，寻找能跳的最远位置</span></span><br><span class="line">        maxPosition=Math.max(maxPosition,nums[i]+i);</span><br><span class="line">        <span class="comment">//到达当前跳跃最远点</span></span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            end=maxPosition;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——串联所有单词的子串</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="NO-30-串联所有单词的子串-困难"><a href="#NO-30-串联所有单词的子串-困难" class="headerlink" title="NO.30 串联所有单词的子串 困难 "></a>NO.30 串联所有单词的子串 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/19/3E2X5D.png" alt="3E2X5D.png"></p>
<p>这道题要把每个单词看成整体，每个不同的单词看作是不同的字符，单词串就看成是特殊的字符串。</p>
<p>==注意：s中的单词未必是长度相等。words中可能存在相同的单词。==</p>
<p><strong><font color=red>思路一：暴力法</font></strong> words中的单词长度都一样，大幅降低了这道题的难度，所以这个特点要充分利用。所以遍历s的每个子串，分别检查每个字串中是否符合要求。</p>
<p>用一个hashmap存储words中的每个单词及其在words中出现的次数；每遍历一个子串都要用一个hashmap存储被遍历子串中出现的words中存在的单词及其在子串中出现的次数。</p>
<p>重点是理解这个“要求”：1.words中的每个单词都<strong>必须出现一次</strong>。2.words中的每个单词<strong>必须连续出现</strong>。</p>
<p>反言之：检查每个子串的过程中，出现words中的不存在的单词则结束检查；出现与words中相等的单词，但是出现的次数超过其在words中出现的次数则结束检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (words==<span class="keyword">null</span>||words.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//单词个数、单词长度</span></span><br><span class="line">    <span class="keyword">int</span> wordNum = words.length,wordLen=words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="comment">//将words每个单词及其个数存入hashmap</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; allWords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        Integer value = allWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">        allWords.put(word,++value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历s每一个子串,剩余不足wordNum*wordLen个字符的子串不需要遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - wordNum * wordLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//将子串中出现的和words中相等的单词及其出现次数存入hashmap</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; hasWords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录字串中和words中相等单词数量</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计字串中连续和words中相等的单词</span></span><br><span class="line">        <span class="keyword">while</span> (count&lt;wordNum)&#123;</span><br><span class="line">            String word = s.substring(i + count * wordLen, i + (count + <span class="number">1</span>) * wordLen);</span><br><span class="line">            <span class="comment">//如果word匹配words中的单词，就统计其出现次数</span></span><br><span class="line">            <span class="keyword">if</span> (allWords.containsKey(word))&#123;</span><br><span class="line">                Integer value = hasWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">                hasWords.put(word,++value);</span><br><span class="line">                <span class="comment">//如果word出现次数超过words中这个单词的总数量则结束统计</span></span><br><span class="line">                <span class="keyword">if</span> (hasWords.get(word)&gt;allWords.get(word))<span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果字串中出现于words中所有单词都不匹配的word则结束统计</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加成功与words中匹配的单词数量</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count==wordNum)res.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*m)    n是s长度，m是words中单词个数。</p>
<p><strong><font color=red>思路二：滑动窗口优化暴力法</font></strong> 用循环内的map(haswords)来保存窗口中匹配的单词，再用一个指针标记窗口当前的起始位置。</p>
<p>暴力方法中有几个需要优化的地方：</p>
<ol>
<li><p>匹配成功：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3My6je.png" alt="3My6je.png"></p>
<p>判断i=0这个子串符合要求，如果继续按照思路一的方法判断。当i=3的时候，依然一次校验每个单词，但是“foofoo”这两个单词已经在i=0子串的时候校验过了。所以暴力法中的hasword这个map并不需要每次都清空，只需要移除“bar“之后，从i=9的单词开始判断就好了。</p>
</li>
<li><p>匹配失败，有不匹配的单词：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3MyycD.png" alt="3MyycD.png"></p>
<p>判断i=0子串时出现了“the”这个不匹配的单词导致匹配失败。i=3、i=6这些子串都包含“the”这个单词，所以都不能匹配成功，所以窗口直接移动到i=9继续校验即可。</p>
</li>
<li><p>匹配失败，单词匹配但是数量超出：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3Mys1O.png" alt="3Mys1O.png"></p>
<p>i=0字串中“bar”出现两次，但是words中只有一个”bar”所以匹配失败。窗口移动到i=3,移除了“foo”但是“bar”依然多出一个，所以一定不匹配。窗口移动到i=6的时候移除了“bar”，就可以按照正常流程继续判断了。</p>
</li>
</ol>
<p>不难发现，上述几种情况的描述时，不再是每次移动一个字符，而是每次移动单词长度。但是s中的单词不一定都是刚好符合wordLen，如何解决这种情况？</p>
<p>答：分成wordLen种情况，分别进行判断。分别从i=0开始每次移动一个单词长度、从i=1开始每次移动一个单词长度、从i=2开始每次移动一个单词长度、、、直至从i=wordLen-1开始每次移动一个单词长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||words==<span class="keyword">null</span>||words.length==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">int</span> wordsNum = words.length,wordLen=words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="comment">//将words中的单词及其数量存入hashmap</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; allWords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        Integer value = allWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">        allWords.put(word,value+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分成wordLen中情况，分别从0开始每次移动一个单词长度~从wordLen-1开始每次移动一个单词长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;wordLen;j++)&#123;</span><br><span class="line">        <span class="comment">//haswords存放当前子串中匹配的单词及其个数，count当前子串匹配的单词数量</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; haswords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历从j开始的每个子串，每次动一个单词长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=j;i&lt;s.length()-wordLen*wordsNum+<span class="number">1</span>;i+=wordLen)&#123;</span><br><span class="line">            <span class="comment">//防止情况三出现之后，情况一继续移除</span></span><br><span class="line">            <span class="keyword">boolean</span> hasRemoved=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (count&lt;wordsNum)&#123;</span><br><span class="line">                String curWord = s.substring(i + count * wordLen, i + (count + <span class="number">1</span>) * wordLen);</span><br><span class="line">                <span class="comment">//当前单词匹配，加入haswords</span></span><br><span class="line">                <span class="keyword">if</span> (allWords.containsKey(curWord)) &#123;</span><br><span class="line">                    Integer value = haswords.getOrDefault(curWord, <span class="number">0</span>);</span><br><span class="line">                    haswords.put(curWord,value+<span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">//情况三，当前单词匹配，但是数量超了</span></span><br><span class="line">                    <span class="keyword">if</span> (haswords.get(curWord) &gt; allWords.get(curWord)) &#123;</span><br><span class="line">                        hasRemoved=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//从i开始逐个单词，从haswords中移除，removeNum记录移除的单词个数</span></span><br><span class="line">                        <span class="keyword">int</span> removeNum=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">while</span> (haswords.get(curWord) &gt; allWords.get(curWord)) &#123;</span><br><span class="line">                            String fristWord = s.substring(i + removeNum * wordLen, i + (removeNum + <span class="number">1</span>) * wordLen);</span><br><span class="line">                            Integer v = haswords.get(fristWord);</span><br><span class="line">                            haswords.put(fristWord,v-<span class="number">1</span>);</span><br><span class="line">                            removeNum++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//移除完毕之后，更新count</span></span><br><span class="line">                        count-=removeNum;</span><br><span class="line">                        <span class="comment">//移动i的位置(注意removeNum要-1，因为跳出当前循环之后，i还要+wordLen)</span></span><br><span class="line">                        i+=(removeNum-<span class="number">1</span>)*wordLen;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况二，当前单词不匹配</span></span><br><span class="line">                    <span class="comment">//清空haswords</span></span><br><span class="line">                    haswords.clear();</span><br><span class="line">                    <span class="comment">//i移动到当前单词位置(因为跳出当前循环之后，i还要+wordLen)</span></span><br><span class="line">                    i+=count*wordLen;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况一，匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (count==wordsNum)result.add(i);</span><br><span class="line">            <span class="comment">//如果情况三没有出现</span></span><br><span class="line">            <span class="keyword">if</span> (count&gt;<span class="number">0</span>&amp;&amp;!hasRemoved)&#123;</span><br><span class="line">                <span class="comment">//移除成功匹配子串的第一个元素</span></span><br><span class="line">                String fristWord = s.substring(i, i + wordLen);</span><br><span class="line">                Integer v = haswords.get(fristWord);</span><br><span class="line">                haswords.put(fristWord,v-<span class="number">1</span>);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*wordLen)    这个时间复杂度不敢确定算的对。。。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——不同路径II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    <content><![CDATA[<h2 id="NO-63-不同路径II-中等"><a href="#NO-63-不同路径II-中等" class="headerlink" title="NO.63 不同路径II 中等 "></a>NO.63 不同路径II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/10/8iodR1.png" alt="8iodR1.png"></p>
<p><strong><font  color=red>思路一：动态规划</font></strong> 这道题和上一题作为姊妹题，没什么太大变化，只是多了障碍物这个因素。</p>
<p>dp[][]数组的含义：和上一题一样。</p>
<p>初始化：dp[0][0]~dp[0][n-1]即第一列和dp[0][0]~dp[0][n-1]即第一行因为只有向下或向右移动，所以在第一个障碍物之前的位置都是1，障碍物即障碍物之后的位置都是无法到达所以是0。</p>
<p>状态转移：如果[i][j]是障碍物则无法到达所以是0，否则依然是dp[i][j]=dp[i-1][j]+dp[i][j-1]，还是因为只能向下或向右移动，所以dp[i][j]的一定是从其上面的[i][j-1]或左面的[i-1][j]移动而来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length,n=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span>)dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j]==<span class="number">0</span>)dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j]==<span class="number">1</span>)dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——二叉树的直径</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h2 id="NO-543-二叉树的直径-简单"><a href="#NO-543-二叉树的直径-简单" class="headerlink" title="NO.543 二叉树的直径  简单 "></a>NO.543 二叉树的直径  <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/10/8iIWuT.png" alt="8iIWuT.png"></p>
<p><strong><font color=red>思路一：深度优先遍历</font></strong> 这道题比较明显，立刻就能想到深度搜索，关键是怎么找到最长的。</p>
<p>一开始就陷入了一个误区，我觉着最大直径一定有根节点，所以根节点左子树找到最深的路径leftMax、右子树找到最深路径rightMax，最后总的最深路径就是leftMax+rightMax。很朴实的想法，但是明显是错误的。如果树是空的就错了，即使树不空但是根节点的左子树或者右子树为空也可能会出错，形如下图。</p>
<p><img src="https://s2.ax1x.com/2020/03/10/8izEL9.png" alt="8izEL9.png"></p>
<p>最初的这个想法浪费了不少时间，但是通过学习别人的思路发现最初的错误方法有一小部分是正确的。</p>
<p>虽然最大直径不一定经过根节点，但是一定经过某个节点(废话)，这个某节点的左子树最深路径和右子树最深路径之和就是最大直径。</p>
<p>我们要找的是路径和而不是节点和，这一点要牢记。</p>
<p>根据这个左右子树最大深度之和的方式，深度优先遍历将所有节点的最大直径都算出来，取最大即可。递归深搜到每个叶子节点，触底返回节点左右最深的路径+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> ans;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为空，没有路径</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//深搜</span></span><br><span class="line">    <span class="keyword">int</span> leftMax=dfs(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax=dfs(root.right);</span><br><span class="line">    <span class="comment">//每个子树根的最大直径</span></span><br><span class="line">    ans=Math.max(ans,leftMax+rightMax);</span><br><span class="line">    <span class="comment">//+1因为子树的根到父节点之间有一条边</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax,rightMax)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——二进制求和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-67-二进制求和-简单"><a href="#NO-67-二进制求和-简单" class="headerlink" title="NO.67 二进制求和 简单 "></a>NO.67 二进制求和 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/16/8G8PqU.png" alt="8G8PqU.png"></p>
<p><strong><font color=red>思路一：逐位相加进位</font></strong> 这种题其实已经遇到很多了，之前的字符串相加、字符串相乘是一样的。只不过本题换成了二进制而已。</p>
<p>不需要考虑符号位，依然是逆序遍历从低位到高位逐位相加，记录进位情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>,len=Math.max(a.length(),b.length());</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=a.length()-i-<span class="number">1</span>&gt;=<span class="number">0</span>?a.charAt(a.length()-<span class="number">1</span>-i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y=b.length()-i-<span class="number">1</span>&gt;=<span class="number">0</span>?b.charAt(b.length()-<span class="number">1</span>-i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line">        carry=sum/<span class="number">2</span>;</span><br><span class="line">        sb.append(sum%<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)sb.append(carry);</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——岛屿的最大面积</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="NO-695-岛屿的最大面积-中等"><a href="#NO-695-岛屿的最大面积-中等" class="headerlink" title="NO.695 岛屿的最大面积 中等 "></a>NO.695 岛屿的最大面积 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/15/81gBKe.png" alt="81gBKe.png"></p>
<p><strong><font color=red>思路一：广度优先遍历</font></strong> 这道题给我的第一感觉和腐烂的橘子那道题很像，都是多源向外”辐射”寻找。</p>
<p>用一个和grid大小一样的boolean型数组used标识每个位置是否用过，max统计最大岛屿面积。</p>
<p>遍历矩阵，如果当前位置是陆地(1)并且没有被使用过，就从当前位置进行广搜最后更新最大岛屿面积；否则继续遍历。</p>
<p>简陋的BFS模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(队列不空)&#123;</span><br><span class="line">	node=队列.poll();</span><br><span class="line">	<span class="keyword">for</span>(node的邻接节点)&#123;</span><br><span class="line">		<span class="keyword">if</span>(邻接节点m未曾入队)&#123;</span><br><span class="line">			队列.add(m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显这是个模板题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[][] used;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.m=grid.length;</span><br><span class="line">    <span class="keyword">this</span>.n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">this</span>.used=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="comment">//遍历每个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//如果是陆地且没用过</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>&amp;&amp;!used[i][j])&#123;</span><br><span class="line">                <span class="comment">//广搜更新最大岛屿面积</span></span><br><span class="line">                max=Math.max(max,bfs(grid,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广搜</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//广搜队列</span></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);<span class="comment">//当前陆地入队</span></span><br><span class="line">    used[i][j]=<span class="keyword">true</span>;<span class="comment">//更新标记数组</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;<span class="comment">//开始就是一块陆地</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> r=curr[<span class="number">0</span>],c=curr[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断当前出队陆地的上下左右是否是陆地且没使用过</span></span><br><span class="line">        <span class="keyword">if</span> (r-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r-<span class="number">1</span>][c]==<span class="number">1</span>&amp;&amp;!used[r-<span class="number">1</span>][c])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r-<span class="number">1</span>,c&#125;);</span><br><span class="line">            used[r-<span class="number">1</span>][c]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r][c-<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;!used[r][c-<span class="number">1</span>])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c-<span class="number">1</span>&#125;);</span><br><span class="line">            used[r][c-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r+<span class="number">1</span>&lt;m&amp;&amp;grid[r+<span class="number">1</span>][c]==<span class="number">1</span>&amp;&amp;!used[r+<span class="number">1</span>][c])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>,c&#125;);</span><br><span class="line">            used[r+<span class="number">1</span>][c]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c+<span class="number">1</span>&lt;n&amp;&amp;grid[r][c+<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;!used[r][c+<span class="number">1</span>])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c+<span class="number">1</span>&#125;);</span><br><span class="line">            used[r][c+<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<p><strong>使用的这个used数组可以省略，每个使用过的陆地(1)直接置为0就可以了，我看很多人很形象地把这个叫做”沉岛思想”。用这种方式可以自行改进上一题，减少空间使用。</strong></p>
<p><strong><font color=red>思路二：深度优先遍历</font></strong> 虽然改用深度优先遍历，实际上和上文思路一样，应该叫做实现二。</p>
<p>依然是遍历判断是否为1，如果是则采用深搜统计并更新max。</p>
<p>尝试抛弃used数组，改为”沉岛思想”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">//是陆地</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//深搜并更新max</span></span><br><span class="line">                max=Math.max(max,dfs(grid,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深搜</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界都是海水</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i==grid.length||j&lt;<span class="number">0</span>||j==grid[i].length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">        grid[i][j]=<span class="number">0</span>;<span class="comment">//沉岛</span></span><br><span class="line">        <span class="comment">//上下左右四个方向深搜，别忘了开始的一块陆地</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(grid,i+<span class="number">1</span>,j)+dfs(grid,i-<span class="number">1</span>,j)+dfs(grid,i,j+<span class="number">1</span>)+dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——多数元素</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="NO-169-多数元素-简单"><a href="#NO-169-多数元素-简单" class="headerlink" title="NO.169 多数元素 简单 "></a>NO.169 多数元素 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/13/8n497q.png" alt="8n497q.png"></p>
<p><strong><font color=red>思路一：排序法</font></strong> 因为题目中说总是存在多数元素，这个多数元素的个数大于半数，所以无论是升序还是降序排序之后中间元素一定是多数元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)</p>
<p><strong><font color=red>思路二：哈希表</font></strong> 遍历一遍统计不同数字出现次数，然后遍历哈希表找出多数元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计数字出现次数</span></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        Integer value = map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">        map.put(num,value+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历map，打擂台找到多数元素</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,maxNum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; en : map.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (en.getValue()&gt;maxNum)&#123;</span><br><span class="line">            ans=en.getKey();</span><br><span class="line">            maxNum=en.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路三：摩尔投票法</font></strong> 基于题目中说的多数元素一定存在。</p>
<p>简单说就是先定一个候选人和计数器count，然后遍历过程中遇到和候选人相同的就count+1，不同则count-1，当count==0，就更换当前元素为新的候选人并将count置为1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidate=nums[<span class="number">0</span>],count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num==candidate)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)&#123;</span><br><span class="line">            candidate=num;</span><br><span class="line">            count=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
        <tag>摩尔投票算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——插入区间</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="NO-57-插入区间-困难"><a href="#NO-57-插入区间-困难" class="headerlink" title="NO.57 插入区间 困难 "></a>NO.57 插入区间 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/07/3XsAzD.png" alt="3XsAzD.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 先将intervals和新区间都输入到一个数组中，然后对数组中的区间进行合并得到结果。</p>
<p><a href="https://blog.csdn.net/qq_42758551/article/details/104662112" target="_blank" rel="noopener">徒手挖地球二五周目</a>题解中NO.56合并区间中详细描述了如何进行区间合并。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">int</span>[][] input=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//将newInterval和Intervals都输入一个数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        input[i][<span class="number">0</span>]=intervals[i][<span class="number">0</span>];</span><br><span class="line">        input[i][<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    input[n][<span class="number">0</span>]=newInterval[<span class="number">0</span>];</span><br><span class="line">    input[n][<span class="number">1</span>]=newInterval[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//合并区间</span></span><br><span class="line">    <span class="keyword">return</span> merger(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] merger(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(intervals,(o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=intervals[i][<span class="number">0</span>],right=intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;intervals.length-<span class="number">1</span>&amp;&amp;right&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            right=Math.max(right,intervals[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)    将新旧区间输入一个数组中需要遍历一次，合并区间操作需要排序是nlogn复杂度，然后合并本身需要遍历数组一次。</p>
<p><strong><font color=red>思路二：贪心算法</font></strong> 将当前的一小步进行最优处理，从而使整体最优。思路二是针对思路一进行优化。</p>
<p>本题中已经告知旧区间是有序的，所以思路一中的排序只是为了让新区间放置在末尾之后移动到有序的位置上，从而付出了nlogn的代价。</p>
<ol>
<li><p>针对这一点很容易想到，在第一次遍历旧区间合集的时候顺便进行和新区间的比较，就能直接将新区间插入到有序的位置上。如何进行比较？</p>
<p>==新区间应该放置到最后一个右边界小于新区间左边界的旧区间后面==，这样新区间放入位置之前的所有旧区间都不会和新区间重叠且不需要和新区间进行合并。</p>
</li>
<li><p>找到新区间的插入位置后先不要急于将新区间放入，因为此时新区间可能需要和放入位置及其后序连续的旧区间进行合并。什么样的旧区间会和新区间进行合并？</p>
<p>==新区间右边界&gt;=旧区间左边界==则说明新旧区间需要进行合并，例如[4,5]和[2,6]、[4,8]和[8,9]等等。。。</p>
</li>
<li><p>两个区间合并的结果是[min(新区间左,旧区间左)，max(新区间右,旧区间右)]。将合并后的新区间加入结果集。最后将剩余的旧区间加入结果集。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>,n=intervals.length;</span><br><span class="line">    <span class="comment">//找到新区间的放置位置，最后一个右边界小于新区间左边界的旧区间的后面</span></span><br><span class="line">    <span class="keyword">while</span> (index&lt;n&amp;&amp;newInterval[<span class="number">0</span>]&gt;intervals[index][<span class="number">1</span>])&#123;</span><br><span class="line">        res.add(intervals[index++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//temp记录合并后新区间的左右边界值</span></span><br><span class="line">    <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newInterval[<span class="number">0</span>],newInterval[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;n&amp;&amp;newInterval[<span class="number">1</span>]&gt;=intervals[index][<span class="number">0</span>])&#123;</span><br><span class="line">        temp[<span class="number">0</span>]=Math.min(temp[<span class="number">0</span>],intervals[index][<span class="number">0</span>]);</span><br><span class="line">        temp[<span class="number">1</span>]=Math.max(temp[<span class="number">1</span>],intervals[index][<span class="number">1</span>]);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将合并后的新区间放入结果集</span></span><br><span class="line">    res.add(temp);</span><br><span class="line">    <span class="comment">//将剩余区间放入结果集</span></span><br><span class="line">    <span class="keyword">while</span> (index&lt;n)&#123;</span><br><span class="line">        res.add(intervals[index++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——电话号码的字母组合</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="NO-17-电话号码的字母组合-中等"><a href="#NO-17-电话号码的字母组合-中等" class="headerlink" title="NO.17 电话号码的字母组合 中等 "></a>NO.17 电话号码的字母组合 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/19/QLBNwV.png" alt="QLBNwV.png"></p>
<p><font color=red><strong>思路一：回溯法</strong></font> 如果这道题加一个条件：“每次输入3位字符的字符串”。那么这道题就非常简单了，直接三层for循环就解决了。这道题棘手的地方就是如何确定循环的层数，这时候递归就派上用场了（模仿大佬的语气）！</p>
<p>例如输入”2345”这样的字符串：第一次递归处理2，然后处理完第一个字符2之后，将输入的字符改变成”345”并调用第二个递归函数；第二次递归处理3，将字符串改变成”45”后再次递归；第三次递归处理4，将字符串改变成 “5”后继续递归；第四次递归处理5，将字符串改变成””后继续递归；最后发现字符串为空了，将结果放到列表中并返回。</p>
<p>上面是从函数调用的角度去看的，而每次调用下一层递归时，都需要将本层的一些处理结果放到一个临时变量中，再传递给下一层，从这个变量层层传递的变化看，就像一棵树一样，这个算法的时间复杂度很高，是O(3^n)这个级别的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    用数组或hashmap存储数字及其对应的字符表</span></span><br><span class="line">    String[] letters=&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line"><span class="comment">//    结果集</span></span><br><span class="line">    List&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        边界处理</span></span><br><span class="line">        <span class="keyword">if</span> (digits.length()==<span class="number">0</span>||digits==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        backTrack(digits,<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(String str,String combination,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">//        递归终止条件，当index==str.length()时说明str==""</span></span><br><span class="line">        <span class="keyword">if</span> (index==str.length())&#123;</span><br><span class="line">            result.add(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        获取当前index位置的字符，此处和前文的思路中有所不同：没有采用每次将字符串切割的方法</span></span><br><span class="line"><span class="comment">//        subString()每次都会生成新的字符串，而用index方式取当前第一个字符，效率更高一点</span></span><br><span class="line">        <span class="keyword">char</span> c= str.charAt(index);</span><br><span class="line">        String letter=letters[c-<span class="string">'0'</span>];</span><br><span class="line"><span class="comment">//        遍历letter字符串，例如第一次得到的是‘2’，即遍历“abc”</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;letter.length();i++)&#123;</span><br><span class="line"><span class="comment">//            这里是比较值得思考的地方，递归调用</span></span><br><span class="line">            backTrack(str,combination+letter.charAt(i),index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(3^n)</p>
<p><font color=red><strong>思路二：队列法</strong></font> 利用队列先进先出的特点来处理该问题。</p>
<p>直接用一个例子来说明思路：假设输入的还是”23”,先将”2”对应的字符依次放入队列，队列res变为{“a”,”b”,”c”}；将此时队列中的每个字符串依次取出的同时分别和下一个输入数字所对应的字符拼接后重新放入队列，将”a”取出和第二个输入数字”3”对应的字符”def”依次拼接后重新放入队列，队列res变为{“b”,”c”,”ad”,”ae”,”af”}，将”b”取出和第二个输入数字”3”对应的字符”def”依次拼接后重新放入队列，队列res变为{“c”,”ad”,”ae”,”af”,”bd”,”be”,”bf”}，将”c”取出和第二个输入数字”3”对应的字符”def”依次拼接后重新放入队列，队列res变为{“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”}；所有输入数字遍历结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//        边界处理</span></span><br><span class="line">        <span class="keyword">if</span> (digits==<span class="keyword">null</span>||digits.length()==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">//        用数组或hashmap存储数字及其对应的字符表</span></span><br><span class="line">        String[] letters=&#123;<span class="string">""</span>,<span class="string">"#"</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line"><span class="comment">//        先往队列中加入一个空字符，防止第一次循环从队列中取出第一个元素时出现下标越界异常</span></span><br><span class="line">        res.add(<span class="string">""</span>);</span><br><span class="line"><span class="comment">//        遍历输入的字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.length();i++)&#123;</span><br><span class="line"><span class="comment">//            取出当前遍历数字对应的字符串</span></span><br><span class="line">            String letter=letters[digits.charAt(i)-<span class="string">'0'</span>];</span><br><span class="line"><span class="comment">//            获取当前队列的长度，不能在for循环中直接j&lt;res.size()，因为内层循环中队列在不断增长，导致死循环</span></span><br><span class="line">            <span class="keyword">int</span> size = res.size();</span><br><span class="line"><span class="comment">//            遍历队列中每个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line"><span class="comment">//                从队列中取出第一个元素</span></span><br><span class="line">                String temp = res.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//                遍历当前数字对应的字符串的每个字符，依次和取出的第一个元素拼接后重新放入队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;letter.length();k++)&#123;</span><br><span class="line">                    res.add(temp+letter.charAt(k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(3^n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——翻转链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-206-翻转链表-简单"><a href="#NO-206-翻转链表-简单" class="headerlink" title="NO.206 翻转链表 简单 "></a>NO.206 翻转链表 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/02/3R4HGn.png" alt="3R4HGn.png"></p>
<p>本题是K个一组翻转链表这道题的其中一步，学习完本题可以趁热打铁学习NO.25，题解参考<a href="https://blog.csdn.net/qq_42758551/article/details/104362023" target="_blank" rel="noopener">徒手挖地球十八周目</a>。</p>
<p><strong><font color=red>思路一：迭代实现</font></strong> 翻转链表需要三个”指针”：pre指向前驱、curr指向当前节点、next指向后继。</p>
<p>过程比较简单，自己模拟一遍就好了：</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3R4b2q.png" alt="3R4b2q.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/02/3R47Ps.png" alt="3R47Ps.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre=<span class="keyword">null</span>,curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!= <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next=curr.next;</span><br><span class="line">        curr.next=pre;</span><br><span class="line">        pre=curr;</span><br><span class="line">        curr=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：递归实现</font></strong> 每层递归返回已经翻转好的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre=reverseList(head.next);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——腐烂的橘子</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<h2 id="NO-994-腐烂的橘子-简单"><a href="#NO-994-腐烂的橘子-简单" class="headerlink" title="NO.994 腐烂的橘子 简单 "></a>NO.994 腐烂的橘子 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/04/3Io9V1.png" alt="3Io9V1.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IIzr9.png" alt="3IIzr9.png"></p>
<p><strong><font color=red>思路一：广度优先遍历</font></strong> 这道题可以解读为：腐烂橘子到达最远好橘子的最短路径。</p>
<p>写一个很简陋的BFS的框架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(队列不空)&#123;</span><br><span class="line">	node&#x3D;队列.poll();</span><br><span class="line">	for(node的邻接节点)&#123;</span><br><span class="line">		if(邻接节点m未曾入队)&#123;</span><br><span class="line">			队列.add(m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道了BFS，这道题就比较简单了。</p>
<ol>
<li>先遍历一遍，统计初始新鲜橘子的数量并将初始腐烂橘子入队。</li>
<li>然后BFS，同时round记录进行了多少轮次的”传染”。每轮开始都要记录当前轮次开始有多少个坏橘子n。</li>
<li>将本轮开始时的所有坏橘子都出队，并对出队节点的四个邻接节点进行判断和”传染”。</li>
<li>最后检查好橘子还有没有。</li>
</ol>
<p>只有坏橘子才会入队，所以没有框架里邻接节点m未曾入队的检查，因为入过队的都变成坏橘子了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length,col=grid[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历，统计新鲜橘子，坏橘子坐标入队</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j]==<span class="number">2</span>)queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//round传染的轮次</span></span><br><span class="line">    <span class="keyword">int</span> round=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当队列不空并且还存在好橘子就广搜BFS</span></span><br><span class="line">    <span class="keyword">while</span> (count&gt;<span class="number">0</span>&amp;&amp;!queue.isEmpty())&#123;</span><br><span class="line">        round++;</span><br><span class="line">        <span class="comment">//n记录当前坏橘子数量，防止出队入队导致不同轮次之间混乱</span></span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] rc = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r=rc[<span class="number">0</span>],c=rc[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//每个出队的坏橘子的四个正方向上邻接节点是否是好橘子，如果是就传染腐烂并入队</span></span><br><span class="line">            <span class="keyword">if</span> (r-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r-<span class="number">1</span>][c]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r-<span class="number">1</span>][c]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r-<span class="number">1</span>,c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r+<span class="number">1</span>&lt;row&amp;&amp;grid[r+<span class="number">1</span>][c]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r+<span class="number">1</span>][c]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>,c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r][c-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r][c-<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c-<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c+<span class="number">1</span>&lt;col&amp;&amp;grid[r][c+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r][c+<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count&gt;<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> round;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    n数组元素个数，整个过程遍历数组两次。</p>
<p>代码很冗长，但是思路还算清楚。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a>   </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两数之和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-1-两数之和-简单"><a href="#NO-1-两数之和-简单" class="headerlink" title="NO.1 两数之和    简单 "></a>NO.1 两数之和    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMw3c9.png" alt="QMw3c9.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font>    看到题，最先想到的思路就是<strong>暴力解法</strong>，直接两层for循环遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]==target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"no result!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><font color=red><strong>思路二：哈希表法</strong></font>    通过一个哈希表来空间换时间：1.遍历nums数组，判断每个元素和目标值的差temp是否在哈希表中。2.如果在就返回当前遍历元素的下标和哈希表中temp这个key对应的value。3.如果不在就将当前遍历元素作为key、当前遍历元素下标作为value存入哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map =<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=target-nums[i];</span><br><span class="line"><span class="comment">//          所需要的temp是否在map中，如果在就返回map中temp值对应的value(即temp值对应的下标)和i。</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(temp),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//          temp如果不在map中，就将nums[i]作为key、下标i作为value放入map中</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"no twoSum result!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两两交换链表中的节点</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="NO-24-两两交换链表中的节点-中等"><a href="#NO-24-两两交换链表中的节点-中等" class="headerlink" title="NO.24 两两交换链表中的节点 中等 "></a>NO.24 两两交换链表中的节点 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZCWlR.png" alt="lZCWlR.png"></p>
<p><font color=red><strong>思路一：迭代实现</strong></font> 用一个pre指针指向未被交换节点的前驱，交换pre后继和pre后继的后继，直到pre没有后继或者pre的后继没有后继。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode pre=dummy;</span><br><span class="line">        <span class="keyword">while</span> (pre.next!=<span class="keyword">null</span>&amp;&amp;pre.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode start=pre.next,end=pre.next.next;</span><br><span class="line"><span class="comment">//            交换两个节点，注意交换顺序，否则容易死循环</span></span><br><span class="line">            pre.next=end;</span><br><span class="line">            start.next=end.next;</span><br><span class="line">            end.next=start;</span><br><span class="line"><span class="comment">//            移动pre指针，此时已经交换过两个节点的位置</span></span><br><span class="line">            pre=start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red><strong>思路二：递归实现</strong></font> 没有节点或者只有一个节点不需要进行交换，停止递归，此时返回head节点本身。每层递归返回值是交换过之后的链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next=head.next;</span><br><span class="line">    head.next=swapPairs(next.next);</span><br><span class="line">    next.next=head;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两数相除</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h2 id="NO-29-两数相除-中等"><a href="#NO-29-两数相除-中等" class="headerlink" title="NO.29 两数相除 中等 "></a>NO.29 两数相除 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/30/llAbkQ.png" alt="llAbkQ.png"></p>
<p>看了很多人的题解，学习到了很多。但是有些题解我不敢苟同，例如用long存储变量的题解，题目明确说明：我们环境只能存储32位有符号整数；需要用乘法改变正负号的题解，第一句就说了不能用乘法。。等等</p>
<p><font color=red><strong>思路一：二分法除数翻倍</strong></font> 被除数中有N个除数，那么商就是N(用减法来实现除法，新被除数=被除数-除数&amp;商+=1)。如果每次被除数只减一个除数，虽然可以实现除法，但是效率太低，在leetcode上也会TLE。所以采用每次除数翻倍(商也不再是每次+1)的方法。</p>
<p>这道题的思路并不难，但是本题有很多细节需要注意和学习：</p>
<ol>
<li><p>商的范围需要注意，小心溢出。这里可以采用先将除数和被除数转换成负数并且用负数商来进行运算，运算结束再根据除数和被除数原本的符号决定商的符号(负号直接返回，正号需要判断符号转变后是否溢出)。</p>
</li>
<li><p>如何得到商的符号：判断除数和被除数异或之后的符号即可。</p>
</li>
<li><p>如何获得相反数：反码+1=补码。分享一篇文章，对这里有疑惑的同学可以看看——<a href="https://jerrymouse1998.github.io/post/%E8%BD%AC%E8%A1%A5%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D%E5%86%8D%E5%8A%A0%E4%B8%80/">补码(为什么按位取反再加一)</a></p>
<p>举个栗子，17/3，除数和被除数都转换为负数(反码+1=补码)，即-17/-3，先用-17-(-3)=-14，商+=-1；</p>
<p>除数翻倍-14-(-6)=-8，商+=-2；</p>
<p>除数翻倍，此时的除数-12&lt;被除数-8，所以除数重置为-3；</p>
<p>继续-8-(-3)=-5，商+=-1；</p>
<p>除数翻倍，此时的除数-6&lt;被除数-5，所以除数重置为-3；</p>
<p>继续-5-(-3)=-2，商+=-1；</p>
<p>除数翻倍，此时的除数-6&lt;被除数-2，所以除数重置为-3；</p>
<p>但是初始的除数-3&lt;被除数-2，所以计算结束。</p>
<p>最后根据除数和被除数原本的符号决定商的符号，结果应该是”正正得正”，判断此时的负数商符号转变后是否溢出，负数商不等于32位有符号整形最小值-2147483648，所以可以直接转换为正数，返回负数商的相反数。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (divisor==<span class="number">0</span>)<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//将除数和被除数异或之后，得到商的符号</span></span><br><span class="line">    <span class="keyword">boolean</span> isPositive=(dividend^divisor)&gt;=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将除数和被除数都转化为负数</span></span><br><span class="line">    <span class="keyword">if</span> (dividend&gt;<span class="number">0</span>)dividend=opposite(dividend);</span><br><span class="line">    <span class="keyword">if</span> (divisor&gt;<span class="number">0</span>)divisor=opposite(divisor);</span><br><span class="line">    <span class="comment">// 商用负数来表示，这样可以处理Integer.MIN_VALUE的情况</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dividend&lt;=divisor)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempDivisor=divisor;</span><br><span class="line">        <span class="keyword">int</span> count=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里注意需要对tempDivisor是否为负数做判断，因为tempDivisor有可能会溢出</span></span><br><span class="line">        <span class="keyword">while</span> (tempDivisor&lt;<span class="number">0</span>&amp;&amp;dividend&lt;=tempDivisor)&#123;</span><br><span class="line">            <span class="comment">//被除数-除数</span></span><br><span class="line">            dividend-=tempDivisor;</span><br><span class="line">            ans+=count;</span><br><span class="line">            <span class="comment">//除数翻倍</span></span><br><span class="line">            tempDivisor+=tempDivisor;</span><br><span class="line">            count+=count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对返回值进行处理，这里也可以使用三目运算符完成</span></span><br><span class="line">    <span class="keyword">if</span> (isPositive)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans==Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> opposite(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x的反码+1，得到x的相反数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">opposite</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logN)，除数是 1，每次减一个除数，我们将减 n 次，但因为每次除数都翻倍了，所以共减了log(n)次。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——加一</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h2 id="NO-66-加一-简单"><a href="#NO-66-加一-简单" class="headerlink" title="NO.66 加一 简单 "></a>NO.66 加一 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/15/83UxmV.png" alt="83UxmV.png"></p>
<p>这个题的题干给的很迷，不知道是不是翻译的问题。。。</p>
<p><strong><font color=red>思路一：遍历</font></strong> 很容易想到，+1的结果最大就是10，如果是10就进位当前位置剩余0。</p>
<p>只需要注意”9”、”99”、”999”。。。的全9情况就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//当前位是否是9，不是9+1返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (digits[i]!=<span class="number">9</span>)&#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前位是9，+1进位剩余0</span></span><br><span class="line">        digits[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明全是9，新建长度+1数组，最高位是1其余都是0即可</span></span><br><span class="line">    <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-23-合并K个排序链表-困难"><a href="#NO-23-合并K个排序链表-困难" class="headerlink" title="NO.23 合并K个排序链表 困难 "></a>NO.23 合并K个排序链表 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/17/3C5sN4.png" alt="3C5sN4.png"></p>
<p><strong><font color=red>思路一：逐一两两合并</font></strong> 将<a href="https://blog.csdn.net/qq_42758551/article/details/103733958" target="_blank" rel="noopener">NO.21合并两个有序链表</a>中的方法进行k-1次即可。</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3C5BHU.png" alt="3C5BHU.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists==<span class="keyword">null</span>||lists.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (lists.length&lt;<span class="number">2</span>)<span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next=lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lists.length;i++)&#123;</span><br><span class="line">        ListNode head=dummy,p=dummy.next,q=lists[i];</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q.val&lt; p.val)&#123;</span><br><span class="line">                head.next=q;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head.next=p;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q!=<span class="keyword">null</span>)head.next=q;</span><br><span class="line">        <span class="keyword">if</span> (p!=<span class="keyword">null</span>)head.next=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(Nk)   N是节点总数，k是链表数</p>
<p><strong><font color=red>思路二：分治法优化两两合并</font></strong> 每次对折合并，0号链表和length-1号链表合并保存到0、1号链表和length-2号链表合并保存到1。。。第一轮合并后，将0~k/2再次对折两两合并。。。以此类推，最后0号链表就是最终结果。</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3C5y4J.png" alt="3C5y4J.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = lists.length;</span><br><span class="line">    <span class="keyword">if</span> (lists==<span class="keyword">null</span>|| len ==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//中心对称，两两合并</span></span><br><span class="line">            lists[i]=mergeTwoList(lists[i],lists[len-<span class="number">1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        len=(len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并两个链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoList</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode head=dummy,p=l1,q=l2;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="keyword">null</span>&amp;&amp;q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val&lt;q.val)&#123;</span><br><span class="line">            head.next=p;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head.next=q;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q!=<span class="keyword">null</span>)head.next=q;</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span>)head.next=p;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(Nlogk)    N是节点总数，每次对折合并所有节点都参与了，一共对折合并了logk次。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——合并两个有序链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-21-合并两个有序链表-简单"><a href="#NO-21-合并两个有序链表-简单" class="headerlink" title="NO.21 合并两个有序链表 简单 "></a>NO.21 合并两个有序链表 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFVQZ8.png" alt="lFVQZ8.png"></p>
<p><font color=red><strong>思路一：迭代法</strong></font> 这个题目也是学校老师讲述数据结构课程时说的。1. 创建一个新的头结点dummy，用prehead指针指向新创建的dummy头结点，用p指针指向l1链表的头结点，q指针指向l2链表的头结点。2. 比较p指向的节点的值和q指向的节点的值，如果p指向的节点值小，就让prehead的next指向p所指向的节点，然后prehead和p向后移动，反之就让prehead的next指向q所指向的节点，然后prehead和q向后移动。3. 直到p或者q指针有一个为null为止，最后检查p或者q是否有不为null的指针，如果有就让prehead指向非空的p或者q。返回dummy.next即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="keyword">null</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="keyword">null</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode prehead=dummy,p=l1,q=l2;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>&amp;&amp;q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val&lt;q.val)&#123;</span><br><span class="line">                prehead.next=p;</span><br><span class="line">                prehead=prehead.next;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                prehead.next=q;</span><br><span class="line">                prehead=prehead.next;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        最后检查p或者q是否有不为null的指针</span></span><br><span class="line">        <span class="keyword">if</span> (p!=<span class="keyword">null</span>)prehead.next=p;</span><br><span class="line">        <span class="keyword">if</span> (q!=<span class="keyword">null</span>)prehead.next=q;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：递归法</strong></font> 其实递归法不能算是第二个思路，只能说是思路一的另一种实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——合并两个有序数组</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="NO-88-合并两个有序数组-简单"><a href="#NO-88-合并两个有序数组-简单" class="headerlink" title="NO.88 合并两个有序数组 简单 "></a>NO.88 合并两个有序数组 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/03/34CGVO.png" alt="34CGVO.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 没啥说的直接B合并到A后面的预留位置，然后直接API对A进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        A[m+i]=B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((m+n)*log(m+n))    排序的复杂度</p>
<p><strong><font color=red>思路二：双指针法</font></strong> 最直接想到的双指针法就是像合并两个有序链表一样双指针分别指向两个数组开头，从前向后遍历两个数组。</p>
<p>但是本题中A数组要作为最终的结果数组，所以需要将A中的m个元素保存到A2数组中，然后像上述方法一样双指针遍历A2和B数组，合并保存到A数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存nums1的m个元素</span></span><br><span class="line">    <span class="keyword">int</span>[] A2=<span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        A2[i]=nums1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双指针比较并合并保存到nums1中</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;A2.length&amp;&amp;j&lt;nums2.length)&#123;</span><br><span class="line">        nums1[index++]=(A2[i]&lt;nums2[j]?A2[i++]:nums2[j++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个数组有剩余时保存到nums1后面</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;nums2.length)nums1[index++]=nums2[j++];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;A2.length)nums1[index++]=A2[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(m)    保存nums1的m个元素。</p>
<p><strong><font color=red>思路三：逆序双指针法</font></strong> 不使用额外的数组去保存nums1的m个元素，从而优化空间。</p>
<p>方法就是：逆序！其实就是将思路二都逆向进行。</p>
<p>双指针分别指向nums1和nums2的尾部，逆序遍历，比较大的元素优先合并入结果数组；从结果数组的尾部向前保存并入的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指针都指向尾部，比较大的元素优先合并至nums1尾部</span></span><br><span class="line">    <span class="keyword">int</span> i=m-<span class="number">1</span>,j=n-<span class="number">1</span>,index=nums1.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        nums1[index--]=(nums1[i]&gt;nums2[j]?nums1[i--]:nums2[j--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否有剩余</span></span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>)nums1[index--]=nums1[i--];</span><br><span class="line">    <span class="keyword">while</span> (j&gt;=<span class="number">0</span>)nums1[index--]=nums2[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——合并区间</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="NO-56-合并区间-中等"><a href="#NO-56-合并区间-中等" class="headerlink" title="NO.56 合并区间 中等 "></a>NO.56 合并区间 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/04/3IoSbR.png" alt="3IoSbR.png"></p>
<p><strong><font color=red>思路一：排序</font></strong> 将所有区间按照左边界大小进行非递减排序。</p>
<p>什么样的区间是重叠的需要合并？</p>
<p>[1,3]、[2,6] 第1个区间的右边界大于下一个区间的左边界即发生重叠。</p>
<p>需要合并成[第一个区间的左边界,max(第一个区间的右边界,第二个区间的右边界)]这个区间加入结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (intervals==<span class="keyword">null</span>||intervals.length==<span class="number">0</span>)<span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    <span class="comment">//每个区间按照区间左边界升序排序</span></span><br><span class="line">    Arrays.sort(intervals, (o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//遍历每个区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pre = <span class="number">0</span>; pre &lt; intervals.length; pre++) &#123;</span><br><span class="line">        <span class="comment">//记录当前区间的左右边界值</span></span><br><span class="line">        <span class="keyword">int</span> left=intervals[pre][<span class="number">0</span>],right=intervals[pre][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//如果当前区间的右边界大于下一个区间的左边界，即发生重叠</span></span><br><span class="line">        <span class="keyword">while</span> (pre&lt;intervals.length-<span class="number">1</span>&amp;&amp;right&gt;=intervals[pre+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            right=Math.max(right,intervals[pre+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            pre++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*logn)    区间数组只需要遍历一次，主要是排序的时间复杂度。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——回文数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-9-回文数-简单"><a href="#NO-9-回文数-简单" class="headerlink" title="NO.9 回文数    简单 "></a>NO.9 回文数    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/15/QfCVaQ.png" alt="QfCVaQ.png"></p>
<p><font color=red><strong>思路一：字符串法</strong></font> 最简单的解法就是直接将数字转换为字符串s，然后将字符串翻转得到re，最后判断s和rs是否相等，相等则是回文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    String rs = <span class="keyword">new</span> StringBuilder(x + <span class="string">""</span>).reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> (x+<span class="string">""</span>).equals(rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：翻转一半法</strong></font> 题目要求中有说，不能将整数转化为字符串来解决这个问题。但是依然可以使用字符串法的翻转思路，将数字进行翻转也并不难，例如“1221”，我们需要将后半部分“21”翻转为“12”再和前半部分“12”作比较，相同所以“1221”是回文数。</p>
<p>算法步骤：1.如果数字是负数，那么一定不是回文数。如果数字最后一位是”0“，但数字本身并不是”0“，那么该数字也一定不是回文数。2.如何翻转数字的后半部分：例如“x=1221”，先”1221%10“得到1，然后“x/=10”使x=122， 最后”t=t*10+1”得到t=1；再次“122%10”得到2，然后“x/=10”使x=12，“最后”t=t*10+2”得到t=12。3.将数字后半部分翻转后得到的t和前半部分“12”进行比较，相等则为回文数。</p>
<p><font color=green>如何判断翻转数字的位数已经到达原数字位数的一半？</font>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p>
<p><u>参数数字x可能是偶数也可能是基数</u>，如果x是偶数，例如“1221”，只要翻转后的“21”等于前半部分“12”，x就是回文数；如果x是基数，例如“12321”，后半部分翻转得到“123”，剩余的前半部分是”12“，但是原始数字中间的这个数字”3“并不影响回文（它总是与自身相等）,所以可以直接简单的将后半部分翻转得到“123”进行“123/10=12”的操作即可，然后再与前半部分进行比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        两种不是回文数的特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>||(x!=<span class="number">0</span>&amp;&amp;x%<span class="number">10</span>==<span class="number">0</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        后半部分翻转后的数字</span></span><br><span class="line">        <span class="keyword">int</span> reversedNumber=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x&gt;reversedNumber)&#123;</span><br><span class="line">            reversedNumber=reversedNumber*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        x可能是的位数可能是偶数或基数，如果是基数直接reversedNumber/10,简单的去掉中间的数</span></span><br><span class="line">        <span class="keyword">return</span> x==reversedNumber||x==reversedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——将数组分成和相等的三个部分</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="NO-1013-将数组分成和相等的三个部分-简单"><a href="#NO-1013-将数组分成和相等的三个部分-简单" class="headerlink" title="NO.1013 将数组分成和相等的三个部分 简单 "></a>NO.1013 将数组分成和相等的三个部分 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/11/8A3zR0.png" alt="8A3zR0.png"></p>
<p><strong><font color=red>思路一：双指针法</font></strong> 一个数组能分成和相等的三部分，则这个数组元素总sum和必定是3的倍数，如不是则否定。</p>
<p>双指针头尾开始同时遍历，寻找最左部分和最右部分总和等于sum/3的位置，并且寻找过程中要给中间部分留有余地(中间部分至少是一个元素)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//元素总和必须是3的倍数</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">3</span>!=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//双指针找和等于sum/3的左右部分</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=A.length-<span class="number">1</span>,leftSum=A[<span class="number">0</span>],rightSum=A[A.length-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//+1给中间部分留有"余地"</span></span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftSum == sum / <span class="number">3</span> &amp;&amp; rightSum == sum / <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftSum != sum / <span class="number">3</span>) &#123;</span><br><span class="line">            leftSum+=A[++left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightSum != sum / <span class="number">3</span>) &#123;</span><br><span class="line">            rightSum+=A[--right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：计数器法</font></strong> 和思路一差不多，先判断元素总和是否满足条件。</p>
<p>顺序遍历，count计数器记录有多少部分的和等于sum/3。</p>
<p>如果count&gt;=3，则true。为什么是&gt;=？例如[1,-1,1,-1,1,-1,1,-1]，count==4这个数组依然符合要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//元素总和必须是3的倍数</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//顺序遍历找等于sum/3的部分</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, partialSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        partialSum += i;</span><br><span class="line">        <span class="keyword">if</span> (partialSum == sum/<span class="number">3</span>) &#123;</span><br><span class="line">            partialSum=<span class="number">0</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count&gt;=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——括号生成</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="NO-22-括号生成-中等"><a href="#NO-22-括号生成-中等" class="headerlink" title="NO.22 括号生成 中等 "></a>NO.22 括号生成 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZC6kF.png" alt="lZC6kF.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 1. 将2*n个括号的序列全部得到。2. 同时判断其是否为有效序列。如果是则加入结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="string">""</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    深度优先遍历得到所有组合序列，如果是有效序列，则加入结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,String conbination,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index==<span class="number">2</span>*n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(conbination))res.add(conbination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(index+<span class="number">1</span>,conbination+<span class="string">'('</span>,n);</span><br><span class="line">            dfs(index+<span class="number">1</span>,conbination+<span class="string">')'</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    平衡法判断括号序列是否有效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">                balance++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                balance--;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            如果balance&lt;0则说明，)出现在与其对应的(之前，或者)多于(</span></span><br><span class="line">            <span class="keyword">if</span> (balance&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(2^2n*n)</p>
<p><font color=red><strong>思路二：回溯法</strong></font> 该方法是对上面的暴力法的一个优化思路。上面的方法需要组合出所有的序列(有效的和无效的)，思路就是不生成无效的序列(或者说是”剪枝”,剪除无效无效序列)。观察有效序列的特点：1. 因为是括号’对’，所以n对括号序列中的’(‘和’)’的数量都是n个。2. ‘)’不能出现在与其成对的’(‘之前。</p>
<p>针对上述细节，思考回溯算法细节：</p>
<ol>
<li>当’(‘和’)’的数量都是n个的时候，说明已经得到括号序列。</li>
<li>‘(‘数量小于n的时候，可以向序列中继续添加’(‘。</li>
<li>‘)’数量小于n并且当前’)’数量小于当前’(‘数量时，才可以向序列中继续添加’)’。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="string">""</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l 左括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 有括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> combination 当前括号序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 输入n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,String combination,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//        当'('和')'的数量都是n个的时候，说明已经得到括号序列。</span></span><br><span class="line">        <span class="keyword">if</span> (l==n&amp;&amp;r==n)&#123;</span><br><span class="line">            res.add(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        '('数量小于n的时候，可以向序列中继续添加'('。</span></span><br><span class="line">        <span class="keyword">if</span> (l&lt;n)&#123;</span><br><span class="line">            dfs(l+<span class="number">1</span>,r,combination+<span class="string">'('</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        ')'数量小于n并且当前')'数量小于当前'('数量时，才可以向序列中继续添加')'。</span></span><br><span class="line">        <span class="keyword">if</span> (r&lt;n&amp;&amp;r&lt;l)&#123;</span><br><span class="line">            dfs(l,r+<span class="number">1</span>,combination+<span class="string">')'</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(4^n/sqrt(n))。在回溯过程中，每个有效序列最多需要n步。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——接雨水</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="NO-42-接雨水-困难"><a href="#NO-42-接雨水-困难" class="headerlink" title="NO.42 接雨水 困难 "></a>NO.42 接雨水 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/24/3Gi5ge.png" alt="3Gi5ge.png"></p>
<p><strong><font color=red>思路一：按行计算法</font></strong> 计算每一行接的水，相加得到一共接的水。</p>
<p>用一个变量temp记录第i行的水，遍历每个”墙”的高度，遇到<code>第一个大于等于i</code>的”墙”启动temp准备记录；继续遍历遇到<code>小于i</code>的”墙”<code>temp++</code>，否则遇到<code>大于等于i</code>的”墙”<code>ans加上temp并归零temp</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,maxHeight=height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h : height)<span class="keyword">if</span> (h&gt;maxHeight)maxHeight=h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= maxHeight; row++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//是否开始统计temp</span></span><br><span class="line">        <span class="keyword">boolean</span> isStart=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStart&amp;&amp;height[i]&lt;row)temp++;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;=row)&#123;</span><br><span class="line">                ans+=temp;</span><br><span class="line">                temp=<span class="number">0</span>;</span><br><span class="line">                isStart=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(maxHeight<em>n)    *</em>此方法在leetcode上会超时！**</p>
<p><strong><font color=red>思路二：按列计算法</font></strong> 计算出每一列上有多少水，相加得到一共接的水。</p>
<p>想知道第i列上是否有水，我们需要找到第i列的左边和右边最高的”墙”，因为只有形成凹点才能存水；并且”木桶效应”告诉我们存了多少水，只需要考虑第i列左边和右边找到的最高的”墙”中最矮的一个。</p>
<p>第i列的高度<code>x</code>和我们找到的左边和右边最高的”墙”中最矮的一个”墙”的高度<code>y</code>会有三种关系：</p>
<ol>
<li><code>x&lt;y</code>，第i列上存的水应该是y-x。</li>
<li><code>x&gt;y</code>，第i列上一定接不到水。</li>
<li><code>x=y</code>，第i列上依然是不能接到水。</li>
</ol>
<p>知道了这些，编码就很简单了，遍历每一列的同时找到当前列左边和右边最高的两面”墙”中最矮的一个和当前列进行比较，对上述三种情况进行处理即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; height.length; col++) &#123;</span><br><span class="line">        <span class="comment">//找到col左右最高的墙</span></span><br><span class="line">        <span class="keyword">int</span> leftMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) leftMax=Math.max(leftMax,height[i]);</span><br><span class="line">        <span class="keyword">int</span> rightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; height.length; i++) rightMax=Math.max(rightMax,height[i]);</span><br><span class="line">        <span class="comment">//如果最高的墙中最矮的一个大于col的高度，计算当前列上接的水并加入结果</span></span><br><span class="line">        <span class="keyword">if</span> (Math.min(leftMax,rightMax)&gt;height[col])ans+=Math.min(leftMax,rightMax)-height[col];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><strong><font color=red>思路三：动态规划优化按列计算法</font></strong> 思路二中每次寻找第i列的左右最高墙的时候都需要遍历一次整个数组。</p>
<p>思路三就是针对这点进行优化。空间换时间。</p>
<p>以题目中实例来演示：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3U8exO.md.png" alt="3U8exO.md.png"></p>
<p>每次寻找第i列左边做高的”墙”，只需要将”已经记录的i-1列左边最高的墙和i-1列进行比较，取大的即可”。避免了每次遍历整个数组。</p>
<p>寻找第i列右边做高的”墙”同理，只需要将”已经记录的i+1列右边最高的墙和i+1列进行比较，取大的即可”。</p>
<p>所以leftMax[i]的含义就是第i列左边最高的”墙”，rightMax[i]的含义就是第i列右边最高的”墙”(不含第i列本身)。</p>
<p>初始化：顺序遍历一次填写leftMax数组，逆序遍历一次填写rightMax数组。</p>
<p>有了leftMax和rightMax之后，然后计算每一列上接的水和思路二中方法一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算leftMax，rightMax</span></span><br><span class="line">    <span class="keyword">int</span>[] leftMax=<span class="keyword">new</span> <span class="keyword">int</span>[height.length],rightMax=<span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) leftMax[i]=Math.max(leftMax[i-<span class="number">1</span>],height[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=height.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) rightMax[i]=Math.max(rightMax[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//计算每一列上的水</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min=Math.min(leftMax[i],rightMax[i]);</span><br><span class="line">        <span class="keyword">if</span> (min&gt;height[i])&#123;</span><br><span class="line">            ans+=min-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    三次遍历</p>
<p>空间复杂度：O(n)</p>
<p><strong><font color=red>思路四：双指针优化动态规划法</font></strong> 双指针主要是对思路三中的空间复杂度进行优化。</p>
<p>上述方法中，两个数组中的每个元素在计算每一列上的水的时候只会被使用一次。所以完全可以用两个int类型的变量实现。</p>
<p>依然是用题目中的实例来演示：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3UscqI.png" alt="3UscqI.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/26/3Us6sA.png" alt="3Us6sA.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/26/3Us2Zt.md.png" alt="3Us2Zt.md.png"></p>
<p>就按照上述方式计算出每一列上的水并加入结果，直至left&gt;right结束。</p>
<p>双指针法虽然是沿用了思路二思路三的方式去找左右最高”墙”，==但是为什么计算leftMax和rightMax的位置相差这么远依然可以有效判断呢？==</p>
<p>例如，对于left墙height[left]，如果leftMax比height[left]高。那么如果rightMax比leftMax高，那么就说明left右边一定存在比height[left]高的墙，那么left列上面一定可以接到水。</p>
<p>即使rightMax对于left右边来说不是最高的墙也无所谓，因为如果不是最高的墙，那么同样存在另一个比height[left]高的墙，那么left列上同样可以接到水，且接水量同样是leftMax-height[left]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax=<span class="number">0</span>,rightMax=<span class="number">0</span>,ans=<span class="number">0</span>,left=<span class="number">1</span>,right=height.length-<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//计算更新leftMax rightMax</span></span><br><span class="line">        leftMax=Math.max(leftMax,height[left-<span class="number">1</span>]);</span><br><span class="line">        rightMax=Math.max(rightMax,height[right+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//比较leftMax和rightMax，找到较低的那一侧</span></span><br><span class="line">        <span class="keyword">if</span> (leftMax&lt;rightMax)&#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax&gt;height[left])ans+=leftMax-height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rightMax&gt;height[right])ans+=rightMax-height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——罗马数字转整数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-13-罗马数字转整数-简单"><a href="#NO-13-罗马数字转整数-简单" class="headerlink" title="NO.13 罗马数字转整数 简单 "></a>NO.13 罗马数字转整数 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/16/Q4As2Q.png" alt="Q4As2Q.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/16/Q4Ar8g.png" alt="Q4Ar8g.png"></p>
<p><font color=red><strong>思路一：哈希表</strong></font> 1.用一个hash表把所有罗马数字和阿拉伯数字相互匹配的特殊值作为键值对存储起来，例如”M,1000”、”CM,900”、”D,500”、”CD，400”。。。2.然后将字符串逐步分割并去hash表进行查询匹配，因为两位长度的罗马数字优先于一位长度的罗马数字，所以每步循环都需要先两位分割匹配再一位分割匹配。3.匹配到hash表的键之后，将对应的值加入结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        所有罗马数字和阿拉伯数字相互匹配的特殊值作为键值对存储起来</span></span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"M"</span>,<span class="number">1000</span>);</span><br><span class="line">        map.put(<span class="string">"CM"</span>,<span class="number">900</span>);</span><br><span class="line">        map.put(<span class="string">"D"</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">"CD"</span>,<span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">"C"</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">"XC"</span>,<span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">"L"</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">"XL"</span>,<span class="number">40</span>);</span><br><span class="line">        map.put(<span class="string">"X"</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">"IX"</span>,<span class="number">9</span>);</span><br><span class="line">        map.put(<span class="string">"V"</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">"IV"</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"I"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        然后将字符串逐步分割并去hash表进行查询匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length(); )&#123;</span><br><span class="line"><span class="comment">//            两位长度的罗马数字优先于一位长度的罗马数字,所以先进行两位长度罗马数字的判断</span></span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;s.length()&amp;&amp;map.containsKey(s.substring(i,i+<span class="number">2</span>)))&#123;</span><br><span class="line">                ans+=map.get(s.substring(i,i+<span class="number">2</span>));</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans+=map.get(s.substring(i,i+<span class="number">1</span>));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——零钱兑换</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="NO-322-零钱兑换-中等"><a href="#NO-322-零钱兑换-中等" class="headerlink" title="NO.322 零钱兑换 中等 "></a>NO.322 零钱兑换 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/08/3vz7RI.png" alt="3vz7RI.png"></p>
<p><strong><font color=red>思路一：深度优先遍历</font></strong> 暴力方法超时！检查所有的组合方式，找出符合要求的组合中硬币数量最少的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coins==<span class="keyword">null</span>||coins.length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    dfs(coins,amount,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans==Integer.MAX_VALUE?-<span class="number">1</span>:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深搜，count记录硬币数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果小于0，说明当前组合不对，回溯</span></span><br><span class="line">    <span class="keyword">if</span> (amount&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等于0说明当前组合正确，如果硬币数量更少，则更新结果</span></span><br><span class="line">    <span class="keyword">if</span> (amount==<span class="number">0</span>)&#123;</span><br><span class="line">        ans=Math.min(ans,count);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">        dfs(coins,amount-coins[i],count+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(amount^n) n是不同面额硬币的种类</p>
<p><strong><font color=red>思路二：动态规划</font></strong> dp数组的含义：dp[i]=x 表示至少x个硬币组成i元，即i元的最优解。</p>
<p>dp数组初始化：长度为amount+1，即0元~amount元。dp[0]=0，0元自然是不需要硬币。1~amount初始化为amount+1，因为硬币面额都是整数无论如何amount元也不会需要amount+1个硬币进行组合。</p>
<p>状态转移：无论当前目标金额是多少，都要从coins列表中取出一个面额，然后目标金额就会较少这个面额。如果dp[当前金额-取出面额]有解，则dp[当前金额]就是在其子问题dp[当前金额-取出面额]的基础上加一个硬币。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Arrays.fill(dp,amount+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//填写dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="comment">//金额i的所有子问题</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">//不存在这个子问题</span></span><br><span class="line">            <span class="keyword">if</span> (i-coin&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//在子问题的基础上加一个硬币，取最小值</span></span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查amount是否有解</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?-<span class="number">1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(amount*n)    n是不同面额种类</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——三数之和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-15-三数之和-中等"><a href="#NO-15-三数之和-中等" class="headerlink" title="NO.15 三数之和 中等 "></a>NO.15 三数之和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/17/QocMLV.png" alt="QocMLV.png"></p>
<p>这道题有一个麻烦的地方，就是需要去重，如果直接简单的三重循环暴力破解的话，除了时间复杂度问题之外还不便于去重。</p>
<p><font color=red><strong>思路一：双指针法</strong></font> 1. 首先对数组进行排序。2. 依次遍历数组元素，每遍历一个元素nums[i]时，就用左右指针指向nums[i]后面元素部分的两端，即指向nums[L]和nums[R]，判断nums[i]、nums[L]和nums[R]之和sum是否等于0，等于0则加入结果集。如果sum&gt;0，则说明需要较小的数字，即”R–”。如果sum&lt;0，则说明需要较大的数字，即”L++”。循环直至左右指针相遇，即后面元素部分已组合完毕，则本次循环结束。3. 如果遍历到某个元素nums[i]已经大于0，则三数之和必然大于0（充分利用排序后的特点，减少无用的比较），结束循环。</p>
<p>然后是该算法去重的思路：4. 如果nums[i]==nums[i-1]，就会导致结果重复，所以应该跳过。5. 如果sum==0的时候,nums[L]==num[L+1]就会导致结果重复，所以应该跳过，L++。6. 如果sum==0的时候，nums[R]=nums[R-1]就会导致结果重复，所以应该跳过，R–。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">3</span>)<span class="keyword">return</span> ans;</span><br><span class="line"><span class="comment">//        1.排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"><span class="comment">//        2. 依次遍历数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="comment">//            如果当前元素已经大于0，那么之后所有的三数之和一定都大于0。结束循环。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//            4. 如果nums[i]==nums[i-1]，就会导致结果重复，所以应该跳过。</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            用左右指针指向nums[i]后面元素部分的两端</span></span><br><span class="line">            <span class="keyword">int</span> L=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R=len-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//            循环直至左右指针相遇，即后面元素部分已组合完毕，则本次循环结束。</span></span><br><span class="line">            <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span> (sum==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//                    三数之和等于0，等于0则加入结果集。</span></span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line"><span class="comment">//                    5. 如果sum\=\=0的时候,nums[L]\=\=num[L+1]就会导致结果重复，所以应该跳过，L++。</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[L]==nums[L+<span class="number">1</span>])L++;</span><br><span class="line"><span class="comment">//                    6. 如果sum\=\=0的时候，nums[R]=nums[R-1]就会导致结果重复，所以应该跳过，R--。</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[R]==nums[R-<span class="number">1</span>])R--;</span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;<span class="comment">//如果sum&gt;0，则说明需要较小的数字，即"R--"</span></span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;<span class="number">0</span>)&#123;<span class="comment">//如果sum&lt;0，则说明需要较大的数字，即"L++"</span></span><br><span class="line">                    L++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——全排列II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97%20II/</url>
    <content><![CDATA[<h2 id="NO-47-全排列II-中等"><a href="#NO-47-全排列II-中等" class="headerlink" title="NO.47 全排列II 中等 "></a>NO.47 全排列II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10yScq.png" alt="10yScq.png"></p>
<p><font color=red><strong>思路一：深度遍历，回溯法</strong></font> 本题和前文<u>46.全排列</u>相似，区别在于本题的数组中可能包含重复元素。</p>
<p>根据上一题的经验，已经知道<strong>每一条分支路径上每个数组元素只能使用一次</strong>，这个问题已经解决了：使用一个nums.length长度的boolean类型的数组标志每个元素的使用情况，false未使用，true已使用。</p>
<p>但是仅仅依靠判断元素的使用情况是不够的，因为数组中可能存在未被使用但是值相等的元素。根据前文<u>40.组合总和II</u>中的经验，<strong>相等的元素不能作为兄弟节点，但是可以作为父子节点</strong>。于是我们就可以<u>先对nums数组排序</u>，再判断每个节点使用的元素是否和之前一个兄弟节点使用的元素相等，相等则剪枝，语句形如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前元素和之前一个兄弟节点使用的元素相等，且相等元素节点不是当前节点的父节点</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>为什么需要” &amp;&amp;!nums[i-1] “，以示例[1,1’,2]来说(只是简单画出了小部分，领会精神即可)：</p>
<p><a href="https://imgchr.com/i/1s3QlF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/05/1s3QlF.md.png" alt="1s3QlF.md.png"></a></p>
<p>剪枝的地方没什么问题，但是[ 2,1,1’ ]这个节点使用元素” 1’ “，该节点的索引是1、且等于nums[0]，如果没有” &amp;&amp;!nums[i-1] “的限制也应该被剪枝。但是这个节点应该被保留，是因为<strong>相等元素允许作为父子节点</strong>，所以” &amp;&amp;!nums[i-1] “的限制是有必要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="comment">//对数组排序，使重复元素紧凑在一起，方便后续剪枝</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">//标记每个元素的使用情况，默认值false表示未使用</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    dfs(flag,<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] flag, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成组合</span></span><br><span class="line">    <span class="keyword">if</span> (track.size()==nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">new</span> ArrayList&lt;&gt;(track)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//当前元素未被使用，防止一条路径上出现一个元素被重复使用</span></span><br><span class="line">        <span class="keyword">if</span> (!flag[i])&#123;</span><br><span class="line">            <span class="comment">//当前元素和之前一个兄弟节点使用的元素相等，且相等元素节点不是当前节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//将当前元素加入组合中，并将元素对应的标志置为true</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            dfs(flag,track);</span><br><span class="line">            <span class="comment">//每次回溯将最后加入的元素移除，并将被移除元素对应的标志置为false</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p> 本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——全排列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-46-全排列-中等"><a href="#NO-46-全排列-中等" class="headerlink" title="NO.46 全排列 中等 "></a>NO.46 全排列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10uGsf.png" alt="10uGsf.png"></p>
<p><font color=red><strong>思路一：深度优先遍历，回溯法</strong></font> 看到全排列，就想到DFS构建树。重点是<strong>每条分支路径上每个数组元素只能使用一次</strong>。可以使用一个nums.length长度的boolean类型的数组标志每个元素的使用情况，false未使用，true已使用。</p>
<p>递归前先检查当前元素是否被使用过，如果使用过就剪枝；如果未使用过就将当前元素加入集合并将对应的标志设置为true。</p>
<p>每次回溯的时候不仅要将最后加入集合的元素移除，还要将被移除元素对应的标志置为false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="comment">//标记每个元素是否被使用过，默认值false表示未使用</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    dfs(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(),flag);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LinkedList&lt;Integer&gt; combination,<span class="keyword">boolean</span>[] flag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成组合</span></span><br><span class="line">    <span class="keyword">if</span> (combination.size()==nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combination));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//当前元素未使用过，防止一条路径上出现一个元素被重复使用</span></span><br><span class="line">        <span class="keyword">if</span> (!flag[i])&#123;</span><br><span class="line">            <span class="comment">//将当前元素加入组合中，并将元素对应的标志置为true</span></span><br><span class="line">            combination.add(nums[i]);</span><br><span class="line">            flag[i]=!flag[i];</span><br><span class="line">            dfs(combination,flag);</span><br><span class="line">            <span class="comment">//每次回溯将最后加入的元素移除，并将被移除元素对应的标志置为false</span></span><br><span class="line">            flag[i]=!flag[i];</span><br><span class="line">            combination.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N*N!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——删除链表的倒数第N个节点</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="NO-19-删除链表的倒数第N个节点-中等"><a href="#NO-19-删除链表的倒数第N个节点-中等" class="headerlink" title="NO.19 删除链表的倒数第N个节点 中等 "></a>NO.19 删除链表的倒数第N个节点 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFV1Ig.png" alt="lFV1Ig.png"></p>
<p><font color=red><strong>思路一：两次遍历</strong></font> 第一次遍历得到链表的长度L，第二次遍历删除第（L-N+1）个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        依然是借助哑节点</span></span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>),q=head;</span><br><span class="line">        dummy.next=head;</span><br><span class="line"><span class="comment">//        第一次遍历获取链表长度</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        第二次遍历找到待删除节点的前一个节点</span></span><br><span class="line">        q=dummy;</span><br><span class="line">        len-=n;</span><br><span class="line">        <span class="keyword">while</span> (len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            len--;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        删除目标节点</span></span><br><span class="line">        q.next=q.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>操作执行了2L-n步，时间复杂度为O(L)。</p>
<p><font color=red><strong>思路二：双指针一次遍历</strong></font> 1. 用两个指针p、q分别指向链表的开头(哑节点)。2. 先让q指针逐步移动到距离p指针n+1的位置上，也就是上p指针和q指针间隔n个节点。3. 让p指针和q指针同时向后移动，直至q指针为null。4. 此时p指针指向的节点的下一个节点就是待删除节点，p.next=p.next.next删除即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode p=dummy;</span><br><span class="line">        ListNode q=dummy;</span><br><span class="line"><span class="comment">//        首先让q指针移动到和p指针间隔n个元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        此时让p和q保持间距的情况下，同时向后移动，直到q为null</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        删除目标节点</span></span><br><span class="line">        p.next=p.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>操作执行了L+n+1步，时间复杂度为O(L)。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——实现strStr()</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0strStr()/</url>
    <content><![CDATA[<h2 id="NO-28-实现strStr-简单"><a href="#NO-28-实现strStr-简单" class="headerlink" title="NO.28 实现strStr() 简单 "></a>NO.28 实现strStr() <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/30/llALfs.png" alt="llALfs.png"></p>
<p>吐槽一下：这道题的难度标识实在是令人纠结，虽然练习题目才是核心，但是题目的难度标识对于我这样的初学者也是不可缺少的参考标识。</p>
<p>题还没读完，脑海里跳出的第一个想法居然是直接用indexOf()。。。还好立刻就否决了这个想法，但是还是在好奇心的驱使下leetcode提交了一次这个”算法”。。。0ms 100%。。。那就等刷完这道题，读一下indexOf()的源码吧！^_^</p>
<p><font color=red><strong>思路一：双指针暴力法</strong></font> 1. 用i和j分别指向haystack字符串和needle字符串的开头。2. 如果haystack的i号字符等于needle的j号字符，则j和i都向后移动。3. 如果haystack的i号字符不等于needle的j号字符，则j回到needle字符串的开头，i也回溯之后继续比较。4. 循环直至haystack遍历完毕或者needle遍历完毕。5. 最后如果j指针没有遍历我能needle则说明haystack串不包含needle串，返回-1；反之则返回i-j。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack==<span class="keyword">null</span>||needle==<span class="keyword">null</span>)<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;haystack.length()&amp;&amp;j&lt;needle.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i=i-j;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j&lt;needle.length()?-<span class="number">1</span>:i-j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<p><font color=red><strong>思路二：Sunday法</strong></font> 该算法的思路相较于KMP十分容易理解，1. 构建一张偏移表，该表主要记录了模式串中的每一个字符，以及每个字符在模式串中出现的最右位置到尾部的距离+1，未在模式串中出现的字符对应的偏移距离都是”模式串长度+1”。2. 有了偏移表之后开始比较，用idx作为当前查询索引，每次截取目标字符串的[idx，idx+模式串长度]子串和模式串比较，如果相等则返回idx。3. 如果不相等，查看子串在目标串中的后一个字符c是否存在于偏移表中，如果存在则idx=idx+偏移表[c]；如果不存在idx=idx+模式串长度+1。循环直至idx+模式串长度&gt;目标字符串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack,String needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hLen=haystack.length(),nLen=needle.length();</span><br><span class="line">        <span class="keyword">if</span> (hLen&lt;nLen)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//        创建偏移表</span></span><br><span class="line">        Map&lt;Character,Integer&gt; offsetMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nLen;i++)&#123;</span><br><span class="line">            offsetMap.put(needle.charAt(i),nLen-i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        开始查找模式串</span></span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        循环直至idx+模式串长度&gt;目标字符串长度</span></span><br><span class="line">        <span class="keyword">while</span> (idx+nLen&lt;=hLen)&#123;</span><br><span class="line"><span class="comment">//            截取目标字符串</span></span><br><span class="line">            String cutHay = haystack.substring(idx, idx + nLen);</span><br><span class="line"><span class="comment">//            如果子串和模式串相等，则返回idx</span></span><br><span class="line">            <span class="keyword">if</span> (cutHay.equals(needle))&#123;</span><br><span class="line">                <span class="keyword">return</span> idx;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                边界处理，如果子串后面已经没有字符，即已经是最后一组子串，则搜索失败</span></span><br><span class="line">                <span class="keyword">if</span>(idx+nLen&gt;=hLen)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//                如果子串在目标串中的后一个字符c是否存在于偏移表中</span></span><br><span class="line">                <span class="keyword">if</span> (offsetMap.containsKey(haystack.charAt(idx+nLen)))&#123;</span><br><span class="line">                    idx+=offsetMap.get(haystack.charAt(idx+nLen));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    idx+=nLen+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)， 但是该算法的平均情况也可以达到O(n)。</p>
<p><font color=red><strong>思路三：KMP法</strong></font> 数据结构课的时候没学透彻，趁这次机会好好学习一下。作为一只弱鸡，就不瞎扯KMP了，直接找个”巨人肩膀”窥探一下KMP的原理。经过多方查找，最终通过<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">阮一峰的一篇文章</a>艰难入门KMP算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tarsize = needle.length();                <span class="comment">//短字符串</span></span><br><span class="line">            <span class="keyword">int</span> scrsize = haystack.length();              <span class="comment">//长字符串</span></span><br><span class="line">            <span class="keyword">if</span>(tarsize == <span class="number">0</span>)                              <span class="comment">//短字符串是0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(tarsize &gt; scrsize)                         <span class="comment">//短字符串 比 长字符串长</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tarsize == scrsize &amp;&amp; needle.equals(haystack))    <span class="comment">//两个字符串相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> start = <span class="number">0</span>;                             <span class="comment">//长字符串的和短字符串比较的第一个字符</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;                          <span class="comment">//长字符串的和短字符串正在比较的相对第一个位置</span></span><br><span class="line">            <span class="keyword">int</span>[] next = getNext(needle);       <span class="comment">//得到next数组</span></span><br><span class="line">            <span class="keyword">while</span> (start &lt;= scrsize - tarsize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.charAt(start + i) == needle.charAt(i))</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span>(i == tarsize)</span><br><span class="line">                        <span class="keyword">return</span> start;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    start = start + i - next[i];</span><br><span class="line">                    i = i &gt; <span class="number">0</span> ? next[i] : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String needle)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tarsize = needle.length();</span><br><span class="line">            <span class="keyword">int</span>[] next =  <span class="keyword">new</span> <span class="keyword">int</span>[tarsize];</span><br><span class="line">            next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tarsize &gt; <span class="number">1</span>)</span><br><span class="line">                next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; tarsize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(needle.charAt(i-<span class="number">1</span>) == needle.charAt(j))   <span class="comment">//</span></span><br><span class="line">                &#123;</span><br><span class="line">                    next[i] = j+<span class="number">1</span>;</span><br><span class="line">                    j++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    j = next[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    next[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>Sunday算法</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——搜索插入位置</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="NO-35-搜索插入位置-简单"><a href="#NO-35-搜索插入位置-简单" class="headerlink" title="NO.35 搜索插入位置 简单 "></a>NO.35 搜索插入位置 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/05/lr9R3t.png" alt="lr9R3t.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 线性查找，找到目标值或者大于目标值元素则停止。否则插入到返回nums.length。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;        </span><br><span class="line">        <span class="keyword">if</span> (nums[i]==target||nums[i]&gt;target)<span class="keyword">return</span> i;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<p><font color=red><strong>思路二：二分法</strong></font> 和普通的二分法变化不大,主要区别在于最后查找失败后不返回-1，而是返回left。</p>
<p>例[1,3,5,6]、target=4。初始化left=0、right=4-1；第一次循环4&gt;3，left=1+1；第二次循环4&lt;5，right=2-1；left&gt;right循环结束，返回left，即插入位置为2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>需要注意right的初始取值，会影响搜索区间继而影响循环终止条件、right移动。</font></p>
<p>时间复杂度：O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——数字转罗马数字</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="NO-12-数字转罗马数字-中等"><a href="#NO-12-数字转罗马数字-中等" class="headerlink" title="NO.12 数字转罗马数字 中等 "></a>NO.12 数字转罗马数字 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/15/QfXSAI.png" alt="QfXSAI.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfOxHA.png" alt="QfOxHA.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 因为题目中说了输入范围是1~3999，所以我们可以用一个二维数组列出每一位上的所有可能：</p>
<p>roman[4][10]={</p>
<p>​        {“”, “I”, “II”, “III”, “IV”, “V”, “VI”, “VII”, “VIII”, “IX”}</p>
<p>​        {“”, “X”, “XX”, “XXX”, “XL”, “L”, “LX”, “LXX”, “LXXX”, “XC”}</p>
<p>​        {“”, “C”, “CC”, “CCC”, “CD”, “D”, “DC”, “DCC”, “DCCC”, “CM”}</p>
<p>​        {“”, “M”, “MM”, “MMM”,””,””,””,””,””,””}</p>
<p>}</p>
<p>然后用一个list&lt;String&gt;存储每一位上的阿拉伯数字的罗马数字表示，最后将String拼起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String[][] roman=<span class="keyword">new</span> String[][]&#123;</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    StringBuilder result=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    result.append(roman[<span class="number">3</span>][num/<span class="number">1000</span>%<span class="number">10</span>]);<span class="comment">//最高位，千位</span></span><br><span class="line">    result.append(roman[<span class="number">2</span>][num/<span class="number">100</span>%<span class="number">10</span>]);<span class="comment">//百位</span></span><br><span class="line">    result.append(roman[<span class="number">1</span>][num/<span class="number">10</span>%<span class="number">10</span>]);<span class="comment">//十位</span></span><br><span class="line">    result.append(roman[<span class="number">0</span>][num%<span class="number">10</span>]);<span class="comment">//个位</span></span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：贪心算法</strong></font> 先用两个数组分别列出罗马数字和阿拉伯数字的所有特殊点，然后将当前的阿拉伯数字与当前最大的单位作比较，每次转换完一个当前最大单位就减去已转换的当前最大单位；然后再和当前最大的单位作比较如果已不足当前最大单位，就用仅次于当前最大单位的下一个最大单位去比较。。。直到当前的阿拉伯数字等于0。</p>
<p><strong>例如</strong>“2978”，一开始最大单位是”M”表示”1000”，就用两个M转换出2000；</p>
<p>当前阿拉伯数字剩余978，已不足当前最大单位”M”,就用仅次于当前最大单位的”CM”表示”900”去比较，用一个CM转换出900；</p>
<p>当前阿拉伯数字剩余78，已不足当前最大单位”CM”,就用仅次于当前最大单位的”D”表示”500”去比较，还是不足，再用次大的单位”CD”表示”400”去比较，还是不足，再用次大的单位”C”表示”100”去比较，还是不足，再用次大的单位”XC”表示”90”去比较，还是不足，再用次大的单位”L”表示”50”去比较，可以用一个L转换出50；</p>
<p>当前阿拉伯数字剩余28，已不足当前最大单位”L”,就用仅次于当前最大单位的”XL”表示”40”去比较，还是不足，再用次大的单位”X”表示”10”去比较，可以用两个X转换出20；</p>
<p>当前阿拉伯数字剩余8，已不足当前最大单位”X”,就用仅次于当前最大单位的”IX”表示”9”去比较，还是不足，再用次大的单位”V”表示”5”去比较，可以用一个V转换出5；</p>
<p>当前阿拉伯数字剩余3，已不足当前最大单位”V”,就用仅次于当前最大单位的”IV”表示”4”去比较，还是不足，再用次大的单位”I”表示”1”去比较，可以用三个I转换出3；</p>
<p>当前阿拉伯数字剩余0，转换结束，输出两个M、一个CM、一个L、两个XX、一个V、三个I，即“MMCMLXXVIII”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        列出所有罗马数字和阿拉伯数字的特殊点</span></span><br><span class="line">        String[] roman=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arab=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//        贪心算法</span></span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> count=num/arab[index];</span><br><span class="line">            <span class="keyword">while</span> (count--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result+=roman[index];</span><br><span class="line">            &#125;</span><br><span class="line">            num%=arab[index];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——求众数II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%B1%82%E4%BC%97%E6%95%B0II/</url>
    <content><![CDATA[<h2 id="NO-229-求众数II-中等"><a href="#NO-229-求众数II-中等" class="headerlink" title="NO.229 求众数II 中等 "></a>NO.229 求众数II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/13/8nXKh9.png" alt="8nXKh9.png"></p>
<p><strong><font color=red>思路一：摩尔投票法</font></strong> 本题是上一题169的姊妹题，本题没有说一定存在这个”较多的元素”。而且本题的众数的数量需要讨论。</p>
<p>n/k的众数最多有k-1个，本题的符合大于n/3的众数最多有3-1=2个。就像169题中要求的大于n/2，很容易就想到最多存在一个。</p>
<p>知道了本题最多存在两个符合要求的元素，那么根据摩尔头条进行改进：仍然是先定下候选人A、B，然后分别有一个计数器count1、count2。</p>
<p>遍历所有元素，如果当前元素投票给A(和A相等)则count1++，如果是投票给B则count++。</p>
<p>如果不投给A和B，检查两个计数器是否等于0，如果等于0则让被投票的num作为新的候选人且相应的计数器置为1；如果计数器都不等于0，则两个计数器都-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> candidate1=<span class="number">0</span>,candidate2=<span class="number">0</span>,count1=<span class="number">0</span>,count2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">//投给A或者B</span></span><br><span class="line">        <span class="keyword">if</span> (num==candidate1)&#123;</span><br><span class="line">            count1++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不投给A和B且A或B等于0</span></span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">            candidate1=num;</span><br><span class="line">            count1++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            candidate2=num;</span><br><span class="line">            count2++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不投给A和B且A和B不等于0</span></span><br><span class="line">        count1--;</span><br><span class="line">        count2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查A和B是否符合要求</span></span><br><span class="line">    count1=count2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">//必须是else if，防止所有元素都相等的情况</span></span><br><span class="line">        <span class="keyword">if</span> (num == candidate1)&#123;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count1&gt;nums.length/<span class="number">3</span>)res.add(candidate1);</span><br><span class="line">    <span class="keyword">if</span> (count2&gt;nums.length/<span class="number">3</span>)res.add(candidate2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    两次遍历</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>摩尔投票算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——盛最多水的容器</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%20/</url>
    <content><![CDATA[<h2 id="NO-11-盛最多水的容器-中等"><a href="#NO-11-盛最多水的容器-中等" class="headerlink" title="NO.11 盛最多水的容器 中等 "></a>NO.11 盛最多水的容器 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/15/QfYcDK.png" alt="QfYcDK.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 最简单的方法就是将所有的垂直线两两组合，每组计算出容纳的值，返回最大的值即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxarea=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;height.length;j++)</span><br><span class="line"><span class="comment">//                (j-i)一定要记得加括号。。。不要做蠢事</span></span><br><span class="line">                maxarea=Math.max(maxarea,Math.min(height[i],height[j])*(j-i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>共有n(n-1)/2种组合，时间复杂度：O(n^2)</p>
<p><font color=red><strong>思路二：双指针法</strong></font> 用两个指针分别指向数组的开头和结尾，每次较短垂直线那端的指针向较长垂直线那端移动一个下标，每次移动之后用maxarea持续存储目前为止获得的最大面积，直到每个垂直线都被访问过一次为止。</p>
<p>套用语句说烂的话：一个木桶能盛多少水，取决于最短的那根木板。双指针法的形成思路和”短板效应“差不多，<u>两根垂直线之间的面积取决于较短的那根垂直线m，所以想要得到更大的面积，较短的那根垂直线m必须要舍弃</u>，因为如果不舍弃m，高最大就是m，而随着指针的移动宽一直在减少，因此面积只会越来越小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxarea=<span class="number">0</span>,l=<span class="number">0</span>,r=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        maxarea=Math.max(maxarea,Math.min(height[l],height[r])*(r-l));</span><br><span class="line">        <span class="keyword">if</span> (height[l]&lt;height[r])&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个元素被访问一次，时间复杂度:O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——缺失的第一个正数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-41-缺失的第一个正数-困难"><a href="#NO-41-缺失的第一个正数-困难" class="headerlink" title="NO.41 缺失的第一个正数 困难 "></a>NO.41 缺失的第一个正数 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/24/38HH7d.png" alt="38HH7d.png"></p>
<p><strong><font color=red>思路一：两次遍历</font></strong> 第一次遍历将每个元素交换到其元素值对应的下标出，第二次遍历检查每个元素的值和其下标是否相等，如不相等则这个下标就是缺失的第一个正数。</p>
<ol>
<li>第一次遍历：<ul>
<li>将所有符合<code>nums[i]大于0且小于length</code>的元素交换到其值对应的下标位置，例如2应当交换到nums[2]的位置、6应当交换到nums[6]的位置。</li>
<li>如果<code>nums[i]==nums[nums[i]]</code>则不需要移动，例如nums[0]==3但是nums[3]==3就不需要移动了。</li>
<li>交换之后再检查nums[i]是否依然需要交换，如果需要交换继续交换，直至nums[i]无需交换再继续向后遍历。</li>
</ul>
</li>
<li>第二次遍历：<ul>
<li>从1开始，如果<code>nums[i]!=i</code>则i就是缺失的第一个正数。</li>
</ul>
</li>
<li>两次遍历结束后：<ul>
<li>如果没有找到缺失的第一个正数，就检查<code>nums[0]==length</code>如果相等则返回length+1，否则返回length</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i]&gt;<span class="number">0</span>&amp;&amp;nums[i]&lt;nums.length&amp;&amp;nums[i]!=nums[nums[i]])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[nums[i]];</span><br><span class="line">            nums[nums[i]]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]!=i)<span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>]==nums.length)<span class="keyword">return</span> nums.length+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    这道题所用的方法比较简单，重点要学习其中的<a href="https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/10661533?fr=aladdin" target="_blank" rel="noopener">抽屉思想</a>。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——螺旋矩阵</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="NO-54-螺旋矩阵-中等"><a href="#NO-54-螺旋矩阵-中等" class="headerlink" title="NO.54 螺旋矩阵 中等 "></a>NO.54 螺旋矩阵 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/02/3R7fAO.png" alt="3R7fAO.png"></p>
<p><strong><font color=red>思路一：按层模拟法</font></strong> 从[0][0]开始模拟顺时针一层一层的遍历所有元素。</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3WBk34.md.png" alt="3WBk34.md.png"></p>
<p>计算层数count：<code>(Min(row，col)+1)/2</code>，因为每次最多有两行两列组成，最少由一行或一列组成。</p>
<p>遍历每一层curr即<code>[0,count)</code>，每层有四次”转弯”：</p>
<ol>
<li>每一层先从左到右遍历一行，即<code>for(i=curr;i&lt;col-curr;i++)matrix[curr][i]</code>。</li>
<li>再从上到下遍历一列，即<code>for(i=curr+1;i&lt;row-curr;i++)matrix[i][col-1-curr]</code>。</li>
<li>再从右到左遍历一行，即<code>for(i=col-1-curr-1;i&gt;=curr;i--)matrix[row-1-i][i]</code>。</li>
<li>最后从下到上遍历一列，即<code>for(i=row-1-curr-1;i&gt;=curr+1;i--)matrix[i][curr]</code>。</li>
</ol>
<p><u>ps：每一层除了第一行是遍历一整行元素，其余三部分都需要注意不要重复遍历”拐点”元素。</u></p>
<p>上述是常规层(两行两列)的遍历；如果只有一行，从右向左遍历时会重复遍历；如果只有一列，从下向上遍历时会重复遍历，如何解决这个问题？</p>
<p>答：只有一行或只有一列时，不进行右向左或下向上的遍历即可。如何判断？<code>row-1-curr==curr</code>说明当前层只有一行；<code>col-1-curr==curr</code>说明当前层只有一列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length,col=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//计算有多少层</span></span><br><span class="line">    <span class="keyword">int</span> count=(Math.min(row,col)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//当前层</span></span><br><span class="line">    <span class="keyword">int</span> curr=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历每一层</span></span><br><span class="line">    <span class="keyword">for</span> (;curr&lt;count;curr++)&#123;</span><br><span class="line">        <span class="comment">//从左向右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = curr; i &lt; col - curr; i++) &#123;</span><br><span class="line">            res.add(matrix[curr][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = curr+<span class="number">1</span>; i &lt; row-curr; i++) &#123;</span><br><span class="line">            res.add(matrix[i][col-<span class="number">1</span>-curr]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>-curr-<span class="number">1</span>; i &gt;= curr&amp;&amp;(row-<span class="number">1</span>-curr!=curr); i--) &#123;</span><br><span class="line">            res.add(matrix[row-<span class="number">1</span>-curr][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>-curr-<span class="number">1</span>; i &gt;= curr+<span class="number">1</span>&amp;&amp;(col-<span class="number">1</span>-curr!=curr); i--) &#123;</span><br><span class="line">            res.add(matrix[i][curr]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——跳跃游戏</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="NO-55-跳跃游戏-中等"><a href="#NO-55-跳跃游戏-中等" class="headerlink" title="NO.55 跳跃游戏 中等 "></a>NO.55 跳跃游戏 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/03/34FoeP.png" alt="34FoeP.png"></p>
<p><strong><font color=red>思路一：贪心算法</font></strong> NO.45跳跃游戏II的姊妹题，思路一样可以结合学习，题解参考<a href="https://blog.csdn.net/qq_42758551/article/details/104562003" target="_blank" rel="noopener">徒手挖地球二三周目</a>。</p>
<p>每次都在本次跳跃范围内找到下一跳最远的位置。如果最后最远的都为都不能到结尾，则false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//end当前跳跃范围，maxPosition记录当前跳跃范围内下一跳最远的位置</span></span><br><span class="line">    <span class="keyword">int</span> end=<span class="number">0</span>,maxPosition=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//记录当前范围内下一跳最远的位置</span></span><br><span class="line">        maxPosition=Math.max(maxPosition,nums[i]+i);</span><br><span class="line">        <span class="comment">//走到当前跳跃最远点</span></span><br><span class="line">        <span class="keyword">if</span> (i==end)&#123;</span><br><span class="line">            <span class="comment">//跳到最远的位置</span></span><br><span class="line">            end=maxPosition;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end&gt;=nums.length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——通配符匹配</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="NO-44-通配符匹配-困难"><a href="#NO-44-通配符匹配-困难" class="headerlink" title="NO.44 通配符匹配 困难 "></a>NO.44 通配符匹配 <font color=#ff0099>困难</font> <a id="more"></a></h1><p><img src="https://s2.ax1x.com/2020/02/13/1O3D54.png" alt="1O3D54.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/13/1O3sPJ.png" alt="1O3sPJ.png"></p>
<p>这道题和NO.10正则表达式匹配看起来很像，正则匹配的题解可以参考<a href="https://blog.csdn.net/qq_42758551/article/details/104286793" target="_blank" rel="noopener">徒手挖地球十六周目</a>中的记录。</p>
<p>这两道题目的区别在于’*’的处理不同，正则中的星号是星号前的字符可以出现0次、1次或多次，而本题中通配符中的星号则是可以匹配任意字符。但是正则中的’.’和通配符中的’?’作用是一样的。</p>
<p>所以说这道题的难点一样是对于’*’的处理。</p>
<p><strong><font color=red>思路一：双指针贪心算法</font></strong> 重点就是我们如何充分的利用’*’。</p>
<p>我们用i和j分别标记s和p的第一个字符下标，即都初始化为0。用istart和jstart分别标记s和p中’*’匹配过的位置，即初始化为-1。</p>
<p>和普通字符串匹配的思路差不多，<code>已经匹配成功的部分就不再考虑了</code>，所以要用i和j标记当前正在比较的字符；但是<code>最近匹配过的&#39;*&#39;</code>可能会被<code>重复使用去匹配更多的字符</code>，所以我们要用istart和jstart分别标记<code>s和p中最近匹配过&#39;*&#39;的位置</code>。可以参考<a href="https://blog.csdn.net/qq_42758551/article/details/104286793" target="_blank" rel="noopener">徒手挖地球十六周目</a>NO.正则表达式匹配的思路一是如何从普通情况延伸到特殊字符的。</p>
<p>s和p匹配过程中可能会遇到的情况：</p>
<ol>
<li>如果<code>i和j标记的字符正好相等或者j字符是&#39;?&#39;</code>匹配成功，则”移除”i和j元素，即<code>自增i、j</code>。</li>
<li>否则如果<code>j字符是&#39;*&#39;</code>依然可以匹配成功，<code>则用istart和jstart分别标记i元素和j元素</code>之后<code>自增j</code>。</li>
<li>再否则如果<code>istart&gt;-1</code>说明之前匹配过’*‘，因为’*‘可以匹配多个字符，所以这里要再次利用这个最近匹配过的’*‘匹配更多的字符，<code>移动i标记istart的下一个字符，再让istart重新标记i元素</code>同时<code>移动j标记jstart的下一个字符</code>。</li>
<li>上述三种情况都不满足，则匹配失败，<code>返回false</code>。</li>
</ol>
<p>最后当s中的字符都判断完毕，则认为s为空，此时需要p为空或者p中只剩下星号的时候，才能成功匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span>||p.isEmpty())<span class="keyword">return</span> s==<span class="keyword">null</span>||s.isEmpty();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,istart=-<span class="number">1</span>,jstart=-<span class="number">1</span>,slen=s.length(),plen=p.length();</span><br><span class="line">    <span class="comment">//判断s的所有字符是否匹配</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;slen)&#123;</span><br><span class="line">        <span class="comment">//三种匹配成功情况以及匹配失败返回false</span></span><br><span class="line">        <span class="keyword">if</span> (j&lt;plen&amp;&amp;(s.charAt(i)==p.charAt(j)||p.charAt(j)==<span class="string">'?'</span>))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j&lt;plen&amp;&amp;p.charAt(j)==<span class="string">'*'</span>)&#123;</span><br><span class="line">            istart=i;</span><br><span class="line">            jstart=j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (istart&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            i=++istart;</span><br><span class="line">            j=jstart+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s中的字符都判断完毕，则认为s为空，此时需要p为空或者p中只剩下星号的时候，才能成功匹配。</span></span><br><span class="line">    <span class="comment">//如果p中剩余的都是*，则可以移除剩余的*</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;plen&amp;&amp;p.charAt(j)==<span class="string">'*'</span>)j++;</span><br><span class="line">    <span class="keyword">return</span> j==plen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(mn)      m、n分别是s和p的长度。</p>
<p><strong><font color=red>思路二：动态规划法</font></strong> 分析步骤依然按照<a href="https://blog.csdn.net/qq_42758551/article/details/104286793" target="_blank" rel="noopener">徒手挖地球十六周目</a>NO.正则表达式匹配思路二的步骤来。</p>
<p>dp数组的含义：dp[i][j]意思是s的前i个元素能否被p的前j个元素成功匹配。</p>
<p>知道了dp数组的含义之后，我们就知道了初始化细节：</p>
<ol>
<li><code>boolean类型</code>的dp数组，大小是<code>[s.length+1][p.length+1]</code>，因为存在s前0个字符和p前0个字符的情况。</li>
<li><code>dp[0][0]一定是true</code>，因为s空串和p空串是可以匹配成功的；<code>dp[1][0]~dp[s.length][0]一定都是false</code>，因为s不为空串而p为空串是不能匹配成功的。</li>
<li><code>dp[0][1]~dp[0][p.length]</code>当s为空串的时候，而p不是空串的时候，当且仅当p的j字符以及前面都为’*’才为true。</li>
<li><code>dp[s.length][p.length]</code>就得到了s和p最终的匹配情况。</li>
</ol>
<p>有了上述理解之后，就可以初始化dp数组了。</p>
<p>然后填写dp数组剩余部分即可，状态转移方程：</p>
<ol>
<li>当<code>s[i]==p[j]或者p[j]==&#39;?&#39;</code>，则<code>dp[i][j]=dp[i-1][j-1]</code>。可以理解为当前字符成功匹配后，只需要考虑之前的字符串是否匹配即可；也可以理解为当前字符匹配成功之后，”移除”当前元素(即不需要再考虑当前元素)。</li>
<li>当<code>p[j]==&#39;*&#39;</code>，则<code>dp[i][j]=dp[i-1][j]||dp[i][j-1]</code>。可以理解为当字符为’*‘的时候会出现两种情况，第一种是’<em>‘需要作为一个字母与s[i]进行匹配；第二种是’\</em>‘需要作为空字符(即不需要’*‘可以直接”移除”)，所以dp[i][j-1]；用逻辑或将两种情况连接，是因为只要有一种情况可以匹配成功则当前匹配成功，有点暴力算法的感觉。</li>
<li>最后当<code>s[i]!=p[j]&amp;&amp;p[j]!=&#39;*&#39;</code>，<code>dp[i][j]=false</code>。这步可以省略，因为dp数组元素的默认值就是false，所以不必要进行显式的赋值为false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span>||p.isEmpty())<span class="keyword">return</span> s==<span class="keyword">null</span>||s.isEmpty();</span><br><span class="line">    <span class="keyword">int</span> slen = s.length(),plen=p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[slen+<span class="number">1</span>][plen+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化dp数组,dp[1][0]~dp[s.length][0]默认值flase不需要显式初始化为false</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//dp[0][1]~dp[0][p.length]只有p的j字符以及前面所有字符都为'*'才为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=plen;j++)dp[<span class="number">0</span>][j]=p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span>&amp;&amp;dp[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//填写dp数组剩余部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> si = s.charAt(i - <span class="number">1</span>),pj=p.charAt(j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (si==pj||pj==<span class="string">'?'</span>)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pj==<span class="string">'*'</span>)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]||dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(mn)    m、n分别是s和p的长度。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——下一个排列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-31-下一个排列-中等"><a href="#NO-31-下一个排列-中等" class="headerlink" title="NO.31 下一个排列 中等 "></a>NO.31 下一个排列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/30/llAom8.png" alt="llAom8.png"></p>
<p><font color=red><strong>思路一：一次遍历法</strong></font> 经过观察发现，降序序列没有更大的排序，例如[9,4,3,2,1]、[7,5,4,2,]等等。</p>
<ol>
<li>从数组nums的最后一个元素开始，逆序遍历寻找第一个非递增元素nums[i]。例如[1,5,4,7,6,5,3,1]，逆序遍历到第一个非递增元素是4。</li>
<li>此时nums[i]元素的右边是一个递减序列，逆序遍历这个递减序列找到大于nums[i]的元素中最小的一个nums[j](此时右边这个序列是有序的，利用这一性质)。例如，上例中4右边的序列中找到5。</li>
<li>交换nums[i]和nums[j]，此时序列变为[1,5,5,7,6,4,3,1]。然而这个序列并不是我们需要的”下一个排列”，将i之后的元素序列翻转后得到[1,5,5,1,3,4,6,7]才是最终结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        逆序找到第一个非递增元素nums[i]</span></span><br><span class="line">        <span class="keyword">int</span> i=nums.length-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        如果nums本身不是递减序列，逆序找到nums[i]元素右边的递减序列中第一个大于nums[i]的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;nums[j]&lt;=nums[i])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            交换nums[i]和nums[j]</span></span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        最后翻转nums[i]右边的元素序列，得到参数数组nums的下一个更大的排列</span></span><br><span class="line">        reverse(nums,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    从start号索引开始翻转nums数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=start,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    交换nums数组的i和j号索引元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，在最坏的情况下，只需要对整个数组进行两次扫描</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——外观数列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-38-外观数列-简单"><a href="#NO-38-外观数列-简单" class="headerlink" title="NO.38 外观数列 简单 "></a>NO.38 外观数列 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/28/1Kc7Q0.png" alt="1Kc7Q0.png"></p>
<p>这道题读题花了我好一会儿，最后还是在别人的帮助下理解题意。。。这个外观数列的意思是：第一项 “1”；第二项描述第一项：1个1，“11”；第三项描述第二项：2个1，“21”；第四项描述第三项：1个2和1个1，“1211”；第五项描述第四项：1个1和1个2和2个1，“111221”。。。。</p>
<p><font color=red><strong>思路一：按序生成每个数列</strong></font> 按顺序依次生成每个“外观数列”，其实就是BF。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一项外观数列为"1"</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)<span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">    String s=<span class="string">"1"</span>;</span><br><span class="line">    <span class="comment">//按序生成n个外观数列，从第二项开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//temp是当前生成的外观数列、c初始化为前一项的第一个字符、count记录前一项连续相等的的字符</span></span><br><span class="line">        StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历前一项外观数列的每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="comment">//如果连续的字符相等，则count计数器增加</span></span><br><span class="line">            <span class="keyword">if</span> (c==s.charAt(j))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果连续字符不相等，则将连续字符数量和字符拼接至temp</span></span><br><span class="line">                temp.append(count).append(c);</span><br><span class="line">                <span class="comment">//c更新为当前遍历的字符，计数器重置为1</span></span><br><span class="line">                c=s.charAt(j);</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意，很容易遗漏的一步：将最后未拼接的字符加入temp</span></span><br><span class="line">        temp.append(count).append(c);</span><br><span class="line">        <span class="comment">//更新s</span></span><br><span class="line">        s=temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度不会算。。。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="NO-34-在排序数组中查找元素的第一个和最后一个位置-中等"><a href="#NO-34-在排序数组中查找元素的第一个和最后一个位置-中等" class="headerlink" title="NO.34 在排序数组中查找元素的第一个和最后一个位置 中等 "></a>NO.34 在排序数组中查找元素的第一个和最后一个位置 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/05/lr9WgP.png" alt="lr9WgP.png"></p>
<p>如果不要求时间复杂度，只需要分别正序遍历找左边target和逆序遍历找右边target即可。但是根据题目要求的时间复杂度O(log n)，看出这依然是一个二分查找的变种。</p>
<p><font color=red><strong>思路一：二分法再线性法</strong></font></p>
<ol>
<li>二分法找到target，如果不存在则返回[-1,-1]。</li>
<li>如果nums[mid]==target，利用数组有序的特点， 以mid为中心分别向左向右线性查找，找到最左和最右的target值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result=&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先二分法找到target的下标</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果找到target的下标mid，就以mid为中心分别向左向右线性查找</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">int</span> left_key=mid,right_key=mid;</span><br><span class="line">            <span class="comment">//向左向右线性查找，直至找到不等于target</span></span><br><span class="line">            <span class="keyword">while</span> (left_key&gt;=<span class="number">0</span>&amp;&amp;nums[left_key]==target)left_key--;</span><br><span class="line">            <span class="keyword">while</span> (right_key&lt;nums.length&amp;&amp;nums[right_key]==target)right_key++;</span><br><span class="line">            <span class="comment">//保存最左和最右的target值的下标</span></span><br><span class="line">            result[<span class="number">0</span>]=left_key+<span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>]=right_key-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//终止二分法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">           left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏情况，有序数组中元素都等于target，例如target=8，[8,8,8,8,8,8]，则线性寻找最左最右时需要遍历每个元素。所以时间复杂度是：O(n)。但是因为测试数据的关系，leetcode中这种思路也是可以通过的。</p>
<p><font color=red><strong>思路二：直接二分法分别查找</strong></font></p>
<p>嘴笨，说的比较抽象，其实根据下述方法，动笔在纸上画一画模拟一下就很清晰明了了。</p>
<ol>
<li><p>二分法查找最左target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：<u>当中间值等于target，不能直接返回，而是要收缩right减小搜索区间继续逐步锁定最左的target。</u></p>
<p>最终得到的left(因为循环终止条件时right==left，所以最终left和right是相等的)可以理解成：数组中比target小的元素的个数。所以最终进行简单的判断即可，如果’left==nums.length’说明所有的数都比target小则返回-1，如果’nums[left]==target’则nums[left]就是最左的target，否则数组中没有target返回-1。</p>
</li>
<li><p>二分法查找最右target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：<u>当中间值等于target，不能直接返回，而是要增加left减小搜索区间继续逐步锁定最右的target。</u></p>
<p>因为搜索区间是[0，nums.length)为左闭右开，所以最后判断和返回时需要对left或者right减一，防止越界。这个”减一”也可以这么理解：’if (nums[mid]==target)left=mid+1;’当while循环结束的时候nums[left]的值一定不是target，但是nums[left-1]的值有可能是，所以返回‘nums[right-1]==target?right-1:-1’即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result=&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    result[<span class="number">0</span>]=searchLeft(nums,target);</span><br><span class="line">    result[<span class="number">1</span>]=searchRight(nums,target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最左target</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchLeft</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length;</span><br><span class="line">    <span class="comment">//这里是&lt;而不是&lt;=，因为搜索区间是[0，length)，终止条件是left==right</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid =(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//因为是寻找最左target，所以这里不能直接返回，而是收缩right去锁定左侧边界</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">            <span class="comment">//这里是=mid而不是=mid-1，因为搜索区间是左闭右开</span></span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果target比所有数都大，则返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (left==nums.length)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//终止条件是left==right，所以返回left或者right都可</span></span><br><span class="line">    <span class="keyword">return</span> nums[left]==target?left:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找最右target</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRight</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length;</span><br><span class="line">    <span class="comment">//这里是&lt;而不是&lt;=，因为搜索区间是[0，length)</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//因为是寻找最右target，所以不能直接返回，而是要增大left去锁定左侧边界</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于每次收紧左侧边界都是left=mid+1（因为搜索区间是左闭右开），所以无论是left还是right都需要-1</span></span><br><span class="line">    <span class="keyword">return</span> nums[right-<span class="number">1</span>]==target?right-<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log n)</p>
<p><font color=red><strong>注意事项：</strong></font></p>
<ol>
<li><p><font color=red>二分法中比较麻烦容易出错的点就是搜索区间的确定，因为这会影响到循环条件和搜索区间端点(left和right)的移动。</font></p>
</li>
<li><p><font color=red>思路一中：left=0，right=length-1所以搜索区间是[0，length-1]左闭右闭的，所以循环终止的条件是left&gt;right即while(left&lt;=right)，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid-1排除了mid并且新的搜索区间是[0，mid-1]或者[mid+1，lenght-1]依然是左闭右闭。</font></p>
</li>
<li><p><font color=red>思路二中：left=0，right=length所以搜索区间是[0，length)左闭右开的，所以循环终止的条件是left==right所以while(left&lt;right)即可，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid排除了mid并且新的搜索区间是[0，mid)或者[mid+1，lenght)依然是左闭右闭。</font></p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
</li>
</ol>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——寻找两个有序数组的中位数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-4-寻找两个有序数组的中位数-困难"><a href="#NO-4-寻找两个有序数组的中位数-困难" class="headerlink" title="NO.4 寻找两个有序数组的中位数 困难 "></a>NO.4 寻找两个有序数组的中位数 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><a href="https://imgchr.com/i/1h9jjs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/09/1h9jjs.png" alt="1h9jjs.png"></a></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 直接合并两个有序数组，然后根据奇偶性找到中位数。但是这种笨办法不能满足时间复杂度的要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num=<span class="keyword">new</span> <span class="keyword">int</span>[nums1.length+nums2.length];</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//合并两个有序数组</span></span><br><span class="line">    <span class="keyword">while</span> (count&lt;(nums1.length+nums2.length))&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;nums1.length&amp;&amp;j&lt;nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">                num[count++]=nums1[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                num[count++]=nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i&lt;nums1.length)&#123;</span><br><span class="line">            num[count++]=nums1[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j&lt;nums2.length)&#123;</span><br><span class="line">            num[count++]=nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断合并后的数组元素个数的奇偶性</span></span><br><span class="line">    <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//注意这里是2.0，如果是2会导致结果为int类型丢失精度</span></span><br><span class="line">        <span class="keyword">return</span> (num[count/<span class="number">2</span>-<span class="number">1</span>]+num[count/<span class="number">2</span>])/<span class="number">2.0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num[count/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n+m)</p>
<p><strong><font color=red>思路二：二分法</font></strong> 根据题目中要求的时间复杂度O(log(m+n))想到要使用二分法。因此我们就不能合并两个数组了。</p>
<p><u>其实根据上一题我们就不难发现是否合并两个数组并不重要，我们知道两个数组的长度总和是count，知道中位数是第count/2个或者(num[count/2-1]+num[count/2])/2.0就够了。我们困难的是怎样在不同的数组之间进行二分法。</u></p>
<p>我们换个思考方向：我们把“找中位数”看作是”找第k小的数“的特殊情况。可以充分利用数组是有序的这一特点去找第k小的数，每次排除掉k/2个元素。</p>
<p><strong>看一个”寻找第k小的数“例子：</strong></p>
<ol>
<li>假设我们现在要从A和B两个有序数组中找第7小的数字，我们先比较两个数组的第k/2个元素的大小。3&lt;4所以A数组[1,2,3]这三个元素必然不是第7小的数字，所以排除掉。<img src="https://s2.ax1x.com/2020/02/11/1o5FLF.png" alt="1o5FLF.png"></li>
<li>已经排除了3个，所以我们现在需要在两个数组剩余的部分寻找第4小的数。同样的，我们先比较两个数组剩余元素的第k/2个元素的大小，5&gt;3所以B数组[1,3]这两个元素必然不是第4小的元素，所以排除。<img src="https://s2.ax1x.com/2020/02/11/1o5EdJ.png" alt="1o5EdJ.png"></li>
<li>我们继续在两个数组剩余部分寻找第2小的数。我们比较两个数组剩余元素的第k/2个元素，4=4去掉哪个都行，我们统一处理即可，去掉B的4元素。<img src="https://s2.ax1x.com/2020/02/11/1o4zin.png" alt="1o4zin.png"></li>
<li>此时k=1，只需要判断两个数组剩余部分的第一个元素哪个小即可，找到A数组的4就是第7小的数。<img src="https://s2.ax1x.com/2020/02/11/1o5PMT.png" alt="1o5PMT.png"></li>
</ol>
<p>按照上述例子中的算法，会出现一个问题：每次循环都需要取两个数组剩余部分的第k/2个元素进行比较，如果此时<u>某个数组剩余部分不足k/2个元素怎么办？？？</u></p>
<p><strong>再看一个例子：</strong></p>
<ol>
<li>依然是找第7小的数，但是B数组不能取到第k/2个元素，此时取出B数组的最后一个元素和A数组的第k/2个元素作比较即可。<img src="https://s2.ax1x.com/2020/02/11/1o7m7D.png" alt="1o7m7D.png"></li>
<li>此时B数组已空，所以直接返回A数组的第5个元素即可。<img src="https://s2.ax1x.com/2020/02/11/1o7e0O.png" alt="1o7e0O.png"></li>
</ol>
<p>回到本题“寻找中位数”！有了这个”寻找第k小的数“的算法，去寻找两个有序数组的中位数就容易多了。可以看到无论是找第奇数个还是找第偶数个对上述算法并无影响，最终都会因为k==1或一个数组空了，返回寻找结果。</p>
<p><strong>最终，</strong>“寻找中位数”这个算法我们就以递归的方式进行，为了防止数组长度小于k/2，所以每次比较数组的第min(k/2,数组剩余len)个元素，将小的那部分排除之后，将两个新数组继续送入递归，并将k减去排除的元素个数。递归的出口就是k==1或其中一个数组剩余长度为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = nums2.length;</span><br><span class="line">    <span class="comment">//将奇数和偶数情况统一处理，如果是奇数情况就求两次。这部分也可以用判断分别处理</span></span><br><span class="line">    <span class="keyword">int</span> Kth1=(len1+len2+<span class="number">1</span>)/<span class="number">2</span>,Kth2=(len1+len2+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//注意最后结果是double，如果/2会丢失精度</span></span><br><span class="line">    <span class="keyword">return</span> (findKth(nums1,<span class="number">0</span>,len1-<span class="number">1</span>,nums2,<span class="number">0</span>,len2-<span class="number">1</span>,Kth1)</span><br><span class="line">            +findKth(nums1,<span class="number">0</span>,len1-<span class="number">1</span>,nums2,<span class="number">0</span>,len2-<span class="number">1</span>,Kth2))/<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> start1,<span class="keyword">int</span> end1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> start2,<span class="keyword">int</span> end2,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算两个数组剩余部分长度</span></span><br><span class="line">    <span class="keyword">int</span> len1=end1-start1+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2=end2-start2+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//很巧妙的一步，让len1总是剩余长度较小的那个，如果出现为空的情况一定是len1</span></span><br><span class="line">    <span class="keyword">if</span> (len1&gt;len2)<span class="keyword">return</span> findKth(nums2,start2,end2,nums1,start1,end1,k);</span><br><span class="line">    <span class="comment">//递归的出口，当某个数组剩余长度为0或者k==1的时候</span></span><br><span class="line">    <span class="keyword">if</span> (len1==<span class="number">0</span>)<span class="keyword">return</span> nums2[start2+k-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">1</span>)<span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</span><br><span class="line">    <span class="comment">//比较两个数组剩余部分的第k/2个元素大小，如果越界则取数组最后一个元素进行比较即可</span></span><br><span class="line">    <span class="keyword">int</span> i=start1+Math.min(len1,k/<span class="number">2</span>)-<span class="number">1</span>,j=start2+ Math.min(len2,k/<span class="number">2</span>)-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//排除较小的元素部分，k减去排除元素的个数</span></span><br><span class="line">    <span class="keyword">if</span> (nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1,i+<span class="number">1</span>,end1,nums2,start2,end2,k-(i-start1+<span class="number">1</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1,start1,end1,nums2,j+<span class="number">1</span>,end2,k-(j-start2+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log(n+m))</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——整数反转</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="NO-7-整数反转-简单"><a href="#NO-7-整数反转-简单" class="headerlink" title="NO.7 整数反转 简单 "></a>NO.7 整数反转 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/10/QDB4wd.png" alt="QDB4wd.png"></p>
<p>看到题目的第一个想法：先定义一个保存结果数的变量ans，将参数x不断地对10取余，每次取余将余数加上ans*10，当x=0的时候循环结束，取得最终反转后的数ans。</p>
<p>但是这个想法有个问题就是当“ans<em>10+余数”这个操作时可能会溢出，但庆幸的是检查此操作是否会溢出并不是难事，如果”ans\</em>10+余数“会溢出，那么一定有“ans&gt;=IntMax/10”。</p>
<p>即：<u>参数x为整数</u> 1.“ans&gt;IntMax/10”一定会溢出。2.“ans==IntMax/10”由于IntMax=2^31-1=2147483647，所以此时余数如果大于7也会溢出。 <u>参数x为负数</u> 1.“ans&lt;IntMin/10”一定会溢出。2.“ans==IntMin/10”由于IntMin=-2^31=-2147483648 ,所以此时余数如果小于-8也会溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans&gt;Integer.MAX_VALUE/<span class="number">10</span>||(ans==Integer.MAX_VALUE/<span class="number">10</span>&amp;&amp;temp&gt;<span class="number">7</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans&lt;Integer.MIN_VALUE/<span class="number">10</span>||(ans==Integer.MIN_VALUE/<span class="number">10</span>&amp;&amp;temp&lt;-<span class="number">8</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans=ans*<span class="number">10</span>+temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——旋转图像</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h2 id="NO-48-旋转图像-中等"><a href="#NO-48-旋转图像-中等" class="headerlink" title="NO.48 旋转图像 中等 "></a>NO.48 旋转图像 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/07/1gK3uQ.png" alt="1gK3uQ.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/07/1gKQgS.png" alt="1gKQgS.png"></p>
<p><strong><font color=red>思路一：先转置矩阵，再列对换</font></strong> 很好理解先将图像矩阵转置，再将转置之后的图像矩阵列对换就得到了顺时针旋转90°的效果。把示例在纸上模拟一下就很清楚了：</p>
<p><a href="https://imgchr.com/i/1RJS61" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/08/1RJS61.png" alt="1RJS61.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//转置矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;matrix[i].length;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[j][i];</span><br><span class="line">            matrix[j][i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//列对换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix.length;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=matrix[j][i];</span><br><span class="line">            matrix[j][i]=matrix[j][matrix.length-<span class="number">1</span>-i];</span><br><span class="line">            matrix[j][matrix.length-<span class="number">1</span>-i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——搜索旋转排序数组</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="NO-33-搜索旋转排序数组-中等"><a href="#NO-33-搜索旋转排序数组-中等" class="headerlink" title="NO.33 搜索旋转排序数组 中等 "></a>NO.33 搜索旋转排序数组 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/05/lr9fjf.png" alt="lr9fjf.png"></p>
<p>根据题目的时间复杂度O(log n)，可以排除遍历的想法(遍历的时间复杂度O(n))，需要用二分查找。</p>
<p><font color=red><strong>思路一：二分法</strong></font> 二分查找一个很关键的点就是数组必须是有序的，本题的思路就是先找到有序的那一半，然后进行二分。思路的关键点就是找到有序的那一半，经过观察，数组中间元素左边部分或者右边部分必然有一半是有序的。</p>
<p>mid元素&gt;start元素时左半部分是有序的；否则，右半部分是有序的。如果target不在有序的那半边，则继续二分，并且继续判断剩余部分元素的有序的一半(判断方法一样)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//        开始二分</span></span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end)&#123;</span><br><span class="line"><span class="comment">//            得到中间元素的下标</span></span><br><span class="line">            <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//            如果中间元素等于target，返回mid</span></span><br><span class="line">            <span class="keyword">if</span> (target==nums[mid])<span class="keyword">return</span> mid;</span><br><span class="line"><span class="comment">//            如果中间元素大于第一个元素，说明前半部分是有序的,注意这里是&gt;=</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=nums[start])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target&gt;=nums[start]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    end=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    start=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//否则就是后半部分是有序的</span></span><br><span class="line">                <span class="keyword">if</span> (target&lt;=nums[end]&amp;&amp;target&gt;nums[mid])&#123;</span><br><span class="line">                    start=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    end=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5II/</url>
    <content><![CDATA[<h2 id="NO-59-旋转矩阵II-中等"><a href="#NO-59-旋转矩阵II-中等" class="headerlink" title="NO.59 旋转矩阵II 中等 "></a>NO.59 旋转矩阵II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/07/3XskRO.png" alt="3XskRO.png"></p>
<p><strong><font color=red>思路一：按层模拟法</font></strong> 和<a href="https://blog.csdn.net/qq_42758551/article/details/104618018" target="_blank" rel="noopener">徒手挖地球二四周目</a>的NO.54螺旋矩阵的处理方法类似，一层一层遍历，从左到右、由上到下、由右到左、由下到上从1开始每次自增1进行填充。</p>
<p>既然是四次方向变化，那么就需要四个”标记”分别标识上面一行，右边一列，下边一行，左边一列填充到的位置，标识分别叫做t，r，b，l。</p>
<p>有了标识之后从左向右就可以写作<code>for(i=l;i&lt;=r;i++)</code>，即从左开始到右结束；遍历完上面这一行就将标识t++，即t行填充完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">1</span>,t=<span class="number">0</span>,r=n-<span class="number">1</span>,b=n-<span class="number">1</span>,l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num&lt;=n*n)&#123;</span><br><span class="line">        <span class="comment">//从左到右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) res[t][i]=num++;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="comment">//从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b; i++) res[i][r]=num++;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="comment">//从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--) res[b][i]=num++;</span><br><span class="line">        b--;</span><br><span class="line">        <span class="comment">//从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t; i--) res[i][l]=num++;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——旋转链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-61-旋转链表-中等"><a href="#NO-61-旋转链表-中等" class="headerlink" title="NO.61 旋转链表 中等 "></a>NO.61 旋转链表 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/09/3zzHQ1.png" alt="3zzHQ1.png"></p>
<p><strong><font color=red>思路一：成环再断</font></strong> 先将链表首尾相连形成环，然后找到旋转后的新链表的新头节点和尾节点，从两者之间断开形成需要的结果。</p>
<p><img src="https://s2.ax1x.com/2020/03/09/8prla4.png" alt="8prla4.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/09/8prurT.png" alt="8prurT.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//标记初始链表的结尾，n记录节点数</span></span><br><span class="line">    ListNode oldTail=head;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (oldTail.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        oldTail=oldTail.next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表成环</span></span><br><span class="line">    oldTail.next=head;</span><br><span class="line">    <span class="comment">//旋转之后的新结尾</span></span><br><span class="line">    ListNode newTail=head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - k % n; i++) &#123;</span><br><span class="line">        newTail=newTail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新头节点</span></span><br><span class="line">    ListNode newHead=newTail.next;</span><br><span class="line">    <span class="comment">//新尾节点和新头节点之间断开</span></span><br><span class="line">    newTail.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——无重复字符的最长子串</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="NO-3-无重复字符的最长子串-中等"><a href="#NO-3-无重复字符的最长子串-中等" class="headerlink" title="NO.3 无重复字符的最长子串 中等 "></a>NO.3 无重复字符的最长子串 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/05/Q8Z9it.png" alt="Q8Z9it.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 先双层for循环划分出所有子串并依次进行是否含有重复子符的判断，如果不含重复字符且子串长度大于当前count所记录的子串长度值，就更新count：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        用两个for循环枚举所有子串。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=s.length();j++)&#123;</span><br><span class="line"><span class="comment">//                调用allUnique方法校验子串中是否都是唯一的字符。</span></span><br><span class="line">                <span class="keyword">if</span> (allUnique(s,i,j))</span><br><span class="line">                    count=Math.max(count,j-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    校验子串中是否都是唯一的字符。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Set set=<span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (;start&lt;end;start++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(s.charAt(start)))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            set.add(s.charAt(start));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)</p>
<p><font color=red><strong>思路二：滑动窗口法</strong></font> 滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)[i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)[i,j) 向右滑动 11 个元素，则它将变为 [i+1, j+1)[i+1,j+1)（左闭，右开）。</p>
<p>1.用一个hashset作为滑动窗口来存储当前窗口 [i , j)。2.检查j索引处的元素是否在已经在滑动窗口set中？3.如果已存在，就将i索引处的元素从滑动窗口中移除，并将i向右滑动一步。4.set中如果不存在j索引元素的重复元素，就将j元素放入滑动窗口中，并将j向右滑动一步，并更新count。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">          Set set=<span class="keyword">new</span> HashSet();</span><br><span class="line">          <span class="keyword">int</span> count=<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (i&lt;s.length()&amp;&amp;j&lt;s.length())&#123;</span><br><span class="line">  <span class="comment">//            如果s.charAt(j))已经在set中，</span></span><br><span class="line">              <span class="keyword">if</span> (set.contains(s.charAt(j)))&#123;</span><br><span class="line"><span class="comment">//                将i元素从滑动窗口中移除，并将i向右滑动一步。                  </span></span><br><span class="line">                  set.remove(s.charAt(i++));</span><br><span class="line">              &#125;<span class="keyword">else</span> &#123;    <span class="comment">//s.charAt(j))不在set中，</span></span><br><span class="line"><span class="comment">//                将j元素放入滑动窗口中，并将j向右滑动一步，               </span></span><br><span class="line">                  set.add(s.charAt(j++));</span><br><span class="line"><span class="comment">//                更新count。            </span></span><br><span class="line">                  count = Math.max(j-i,count);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red>优化滑动窗口法：</font>上述方法最坏情况需要执行2n次，我们可以将它减少为执行n次。上述方法中滑动窗口当第j个元素在窗口中发生重复时，<u>就删除第i个元素并且将i向前移动一步</u>，有时候需要i多次移动之后才能使第j个元素不重复。我们可以使用<strong>hashmap</strong>代替hashset，就可以<u>将元素及其下标组成k-v对存入hashmap</u>，当发生第j个元素重复时，就<u>可以一次将i移动到位</u>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,i=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=s.charAt(j);</span><br><span class="line"><span class="comment">//          无论是否更新start，都会更新其map数据结构和结果ans。</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line"><span class="comment">//              移动到集合中重复字符下标的下一位。</span></span><br><span class="line">                i=Math.max(i,map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c,j);</span><br><span class="line">            count=Math.max(j-i+<span class="number">1</span>,count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路三：预测字符集法</strong></font> 就题说题，针对这道题有一种思路：假设字符集较小（只有字母和符号等等，不含中文等等），我们可以用一个整数数组作为直接的访问表来代替map。例如：<strong>假设</strong>参数字符集只含有字母’a’-‘z’或’A’-‘Z’，就用一个int[24]来包含所有字符集；<strong>假设</strong>参数字符集只含有ASCII，就用一个int[128]来包含所有字符集；<strong>假设</strong>参数字符集只含有扩展ASCII，就用一个int[256]来包含所有字符集。</p>
<p>针对这道题，我们假设字符集只含有ASCII：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        数组作为直接访问表代替map。</span></span><br><span class="line">        <span class="keyword">int</span>[] index=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,i=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line"><span class="comment">//            如果index[s.charAt(j)]的值大于i，则说明当前窗口中元素与第j个字符重复了，</span></span><br><span class="line"><span class="comment">//            就让i=index[s.charAt(j)]，使窗口一次性移动到不含重复元素的位置。</span></span><br><span class="line">            i=Math.max(i,index[s.charAt(j)]);</span><br><span class="line"><span class="comment">//            记录窗口中元素个数,如果不重复元素个数大于之前的记录值,就更新count。</span></span><br><span class="line">            count=Math.max(count,j-i+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//            使当前元素作为数组下标并将该元素的下标+1更新至数组,形成类似于hashmap中k-v对的形式。</span></span><br><span class="line">            index[s.charAt(j)]=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效数独</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="NO-36-有效数独-中等"><a href="#NO-36-有效数独-中等" class="headerlink" title="NO.36 有效数独 中等 "></a>NO.36 有效数独 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/28/1KcHyV.png" alt="1KcHyV.png"></p>
<p><img src="https://s2.ax1x.com/2020/01/28/1Kcozq.png" alt="1Kcozq.png"></p>
<p><img src="https://s2.ax1x.com/2020/01/28/1KcIWn.png" alt="1KcIWn.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 依次遍历完每一行，每一列，每一个一个子数独。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board==<span class="keyword">null</span>||board.length&lt;<span class="number">9</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历每一行判断是否有重复</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//遍历完一行之后清空set</span></span><br><span class="line">            set.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//如果这个元素是1-9，则判断是否重复元素</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j]&gt;=<span class="string">'1'</span>&amp;&amp;board[i][j]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (set.contains(board[i][j]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        set.add(board[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历每一列判断是否有重复元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            set.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j]&gt;=<span class="string">'1'</span>&amp;&amp;board[i][j]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (set.contains(board[i][j]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        set.add(board[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历每一个3*3矩阵是否有重复元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;<span class="number">3</span>;m++)&#123;</span><br><span class="line">                set.clear();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i+(<span class="number">3</span>*m)][j+(<span class="number">3</span>*k)]&gt;=<span class="string">'1'</span>&amp;&amp;board[i+(<span class="number">3</span>*m)][j+(<span class="number">3</span>*k)]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span> (set.contains(board[i+(<span class="number">3</span>*m)][j+(<span class="number">3</span>*k)]))&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                set.add(board[i+(<span class="number">3</span>*m)][j+(<span class="number">3</span>*k)]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：对所有元素进行三次遍历，O(3n)，在这个题目的约束下(都是9*9的数独)，对81个元素三次遍历，时间复杂度可以看做常数次，即O(1)。</p>
<p><font color=red><strong>思路二：优化暴力法，一次遍历</strong></font> 空间换时间，定义27个数组(9行+9列+9个子数独)。只需要遍历一次，将每个元素与其对应的行数组、列数组、子数独数组中判断是否出现重复即可。</p>
<p><img src="https://s2.ax1x.com/2020/01/31/13aMLD.gif" alt="13aMLD.gif"></p>
<p>判断元素所属的行和列是很容易的，如何判断每个元素属于第几个子数独需要思考：<font color=red><strong>box_index=(i/3)*3+j/3</strong></font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用三个二维数组分别分别记录9行、9列、9个子数独中的元素，用来判断是否重复</span></span><br><span class="line">        <span class="keyword">int</span>[][] rows=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] cols=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] boxes=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">//遍历数独中每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">                <span class="comment">//如果被遍历元素是数字，则添加到其对应的数组中进行记录</span></span><br><span class="line">                <span class="keyword">if</span> (c&gt;=<span class="string">'1'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> box_index=(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>;</span><br><span class="line">                    rows[i][c-<span class="string">'0'</span>-<span class="number">1</span>]++;</span><br><span class="line">                    cols[j][c-<span class="string">'0'</span>-<span class="number">1</span>]++;</span><br><span class="line">                    boxes[box_index][c-<span class="string">'0'</span>-<span class="number">1</span>]++;</span><br><span class="line">                    <span class="comment">//判断是否出现重复</span></span><br><span class="line">                    <span class="keyword">if</span> (rows[i][c-<span class="string">'0'</span>-<span class="number">1</span>]&gt;<span class="number">1</span>||cols[j][c-<span class="string">'0'</span>-<span class="number">1</span>]&gt;<span class="number">1</span>||boxes[box_index][c-<span class="string">'0'</span>-<span class="number">1</span>]&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：数独中9<em>9个元素遍历一次，O(n)，但是在这个题目的约束下(都是9\</em>9的数独)，对81个元素一次遍历，时间复杂度可以看做常数次，即O(1)。</p>
<p><font color=red><strong>思路三：一次遍历，移位编码，位图法</strong></font> 思路二相对于思路一虽然只需要一次遍历，但是空间上付出的“代价”让人不爽，可以借助位图进行优化。这里就不赘述各种算术运算符的作用了，有需要的请百度，都比我说得好。</p>
<p>很容易发现，导致空间浪费的原因是我们申请了int(32位)类型的数组，但是每个元素最大只需要表示到2，也就是每个元素<u>数值部分</u>实际上只需要2位即可。那么我们很容易想到：申请byte(8位)类型就好了。这确实是一种方法，但是我们使用<strong>位图</strong>这种数据结构来完成，节省空间的同时，还可以使算法的速度得到优化。</p>
<p>我们需要申请一个int类型的数组map，但是我们将每个32位元素的<u>前0-8位分别表示同一数字出现在第几行中，9-17位分别表示同一数字出现在第几列中，18-26位分别表示数字出现在第几个子数独中，对应位上0表示该数字未出现过，1表示该数字出现过。</u><font>上述情况可以使用<strong>左移运算</strong>来实现，还需要使用<strong>按位与运算</strong>实现判断某行、某列、某子数独是否存在重复情况，使用<strong>按位或运算</strong>将数字加入对应的数组元素。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] map=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="number">9</span>;row++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="number">9</span>;col++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[row][col];</span><br><span class="line">            <span class="keyword">if</span> (c!=<span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="comment">//0-8位表示行号，9-17位表示列号，18-26位表示第几个子数独</span></span><br><span class="line">                <span class="keyword">int</span> index=<span class="number">1</span>&lt;&lt;(<span class="number">0</span>+row)|<span class="number">1</span>&lt;&lt;(<span class="number">9</span>+col)|<span class="number">1</span>&lt;&lt;(<span class="number">18</span>+row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>);</span><br><span class="line">                <span class="comment">//按位与等于0说明该数字不曾在同一行、列、子数独中出现过</span></span><br><span class="line">                <span class="keyword">if</span> ((map[c-<span class="string">'0'</span>-<span class="number">1</span>]&amp;index)==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//按位或将数字加入数组对应元素</span></span><br><span class="line">                    map[c-<span class="string">'0'</span>-<span class="number">1</span>]|=index;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：数独中9<em>9个元素遍历一次，O(n)，但是在这个题目的约束下(都是9\</em>9的数独)，对81个元素一次遍历，时间复杂度可以看做常数次，即O(1)。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>位图</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——用队列实现栈</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h2 id="NO-225-用队列实现栈-简单"><a href="#NO-225-用队列实现栈-简单" class="headerlink" title="NO.225 用队列实现栈 简单 "></a>NO.225 用队列实现栈 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/01/3g45b4.png" alt="3g45b4.png"></p>
<p><strong><font color=red>思路一：使用队列API</font></strong> 其实没有太搞明白这个题目的意思。。。leetcode打卡活动第一天题目。</p>
<p>主要是push()方法每次将新加入元素x之前的元素都按序出队并重新入队，这样新元素x就在队头。</p>
<p>然后pop()、top()、empty()直接调用队列API就好。。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; queue.size(); i++) &#123;</span><br><span class="line">            queue.add(queue.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：push()是O(n)，其余三个方法时O(1)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——移除元素</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="NO-27-移除元素-简单"><a href="#NO-27-移除元素-简单" class="headerlink" title="NO.27 移除元素 简单 "></a>NO.27 移除元素 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/29/lK1La6.png" alt="lK1La6.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/29/lK1qVx.png" alt="lK1qVx.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 这道题和第26题如出一辙，题目中的关键点也一样。算法的区别在于对数组第一个元素的处理，26题中第一个元素是不需要”覆盖”的，但是本题的第一个元素有可能需要进行”覆盖”。</p>
<p>用两个指针i和j同时指向0号元素，如果j号指针不等于val，就先将j号元素”覆盖”i号元素再移动i指针，如果j号元素等于val则移动j指针，循环直至j指针遍历完所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line"><span class="comment">//            如果j号指针不等于val，就先将j号元素"覆盖"i号元素再移动i指针</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j]!=val)&#123;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red><strong>思路二：优化双指针法</strong></font> 思路一有一个很明显的弊端，当数组元素和val相等的元素很少时，依然需要移动很多数组元素，例如{[1,2,3,4,5]，val=4}这组输入中”1,2,3”并不需要移动，但是依然会进行自身赋值操作；亦或是{[1,2,3,4,5]，val=1}只需要将5覆盖到1的位置即可，但是思路一的算法并不是这样的。</p>
<p>真对上述出现的问题，对思路一进行优化：1. 双指针i和j分别等于0和nums.length。2. 当i指向的元素等于val时，就先让j-1指向的元素覆盖i指向的元素再进行j–移动。3. 如果i指向元素不等于val，就进行i++移动。4. 循环直至i&gt;=j。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]==val)&#123;</span><br><span class="line">            nums[i]=nums[j-<span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，i和j最多遍历j步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字符串的最大公因子</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</url>
    <content><![CDATA[<h2 id="NO-1071-字符串的最大公因子-简单"><a href="#NO-1071-字符串的最大公因子-简单" class="headerlink" title="NO.1071 字符串的最大公因子 简单 "></a>NO.1071 字符串的最大公因子 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/12/8Z46zj.png" alt="8Z46zj.png"></p>
<h3 id="思路一：辗转相除"><a href="#思路一：辗转相除" class="headerlink" title="思路一：辗转相除"></a><strong><font  color=red>思路一：辗转相除</font></strong></h3><p>提示很重要:1&lt;=length</p>
<p>如果两个字符串存在最大公因子X，那么str1就是m个X连接组成的，同样str2就是n个X连接组成的。</p>
<p>即m+n=n+m是两个字符串存在最大公因子的充要条件。</p>
<p>如果确定两个字符串存在最大公因子，就知道两个字符串分别是m或n个X连接组成的。只需要求出两个字符串长度之间的最大公约数即可。</p>
<p>求最大公约数自然是用辗转相除法(欧几里得算法)，具体做法就是： 用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。举例：</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8Zq7se.png" alt="8Zq7se.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否存在最大公因子</span></span><br><span class="line">    <span class="keyword">if</span> (!(str1+str2).equals(str2+str1))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//求最大公因子长度</span></span><br><span class="line">    <span class="keyword">int</span> maxLen=GCD(str1.length(),str2.length());</span><br><span class="line">    <span class="keyword">return</span> str1.substring(<span class="number">0</span>,maxLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求辗转相除法求最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:GCD(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)    字符串拼接后比较O(n),辗转相除法O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字符串相乘</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h2 id="NO-43-字符串相乘-中等"><a href="#NO-43-字符串相乘-中等" class="headerlink" title="NO.43 字符串相乘 中等 "></a>NO.43 字符串相乘 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10uteS.png" alt="10uteS.png"></p>
<p><font color=red><strong>思路一：竖式法</strong></font> 想一想竖式是怎么一步一步进行的，模拟这个过程。两个步骤：</p>
<ol>
<li><u><strong>逆序</strong>(从低位向高位)遍历</u>乘数num2的每个元素，依次与num1相乘。这个过程中需要注意除了num2的第一个元素(个位数)其他元素都需要在低位补充相应数量的0。<strong>每次相乘的结果temp是逆序的。</strong></li>
<li>将num2的每个元素与num1相乘得到的结果temp和ans相加，此时是<u>顺序遍历</u>两个参数。</li>
</ol>
<p>遍历结束之后返回逆序结果的翻转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1==<span class="keyword">null</span>||num2==<span class="keyword">null</span>||num1.equals(<span class="string">"0"</span>)||num2.equals(<span class="string">"0"</span>)||num1.equals(<span class="string">""</span>)||num2.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//遍历num2的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num2.length();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = num2.charAt(num2.length()-i-<span class="number">1</span>)-<span class="string">'0'</span>,carry=<span class="number">0</span>;</span><br><span class="line">        StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//除了第一次个位数，其他位需要在低位补相应数量的0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)temp.append(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//依次与num1的每个元素相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num1.length();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = num1.charAt(num1.length()-j-<span class="number">1</span>)-<span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//注意加上进位值</span></span><br><span class="line">            <span class="keyword">int</span> sum=x*y+carry;</span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line">            temp.append(sum%<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意检查进位值，不要遗漏</span></span><br><span class="line">        <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)temp.append(carry);</span><br><span class="line">        <span class="comment">//将每位上的乘法结果和ans相加</span></span><br><span class="line">        ans=sum(ans,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后需要将ans翻转，变成正确顺序</span></span><br><span class="line">    <span class="keyword">return</span> ans.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将两个字符串相加</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">sum</span><span class="params">(StringBuilder num1, StringBuilder num2)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>,len=Math.max(num1.length(),num2.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//两个字符串长度不相等的时候，短的那个在高位补0</span></span><br><span class="line">        <span class="keyword">int</span> x=i&lt;num1.length()?num1.charAt(i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y=i&lt;num2.length()?num2.charAt(i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意加上进位</span></span><br><span class="line">        <span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line">        carry=sum/<span class="number">10</span>;</span><br><span class="line">        ans.append(sum%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束也要检查进位，防止遗漏</span></span><br><span class="line">    <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)ans.append(carry);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(MN)</p>
<p><font color=red><strong>思路二：优化竖式法</strong></font> 该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：</p>
<ol>
<li>乘数 num1 位数为 MM，被乘数 num2 位数为 NN， num1 x num2 结果 res 最大总位数为 M+N。</li>
<li>num1[i] x num2[j] 的结果为 tmp(位数为两位，”0x”,”xy”的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/06/166SQe.png" alt="166SQe.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1==<span class="keyword">null</span>||num2==<span class="keyword">null</span>||num1.equals(<span class="string">"0"</span>)||num2.equals(<span class="string">"0"</span>)||num1.equals(<span class="string">""</span>)||num2.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="comment">//两数相乘积最多为M+N位</span></span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[num1.length()+num2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=num1.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=num2.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> sum=x*y+res[i+j+<span class="number">1</span>];</span><br><span class="line">                res[i+j+<span class="number">1</span>]=sum%<span class="number">10</span>;</span><br><span class="line">                res[i+j]+=sum/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="comment">//积的最高位可能为零，省去不要</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;res[<span class="number">0</span>]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            ans.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(MN)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字符串转换整数 (atoi)</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)%20/</url>
    <content><![CDATA[<h2 id="NO-8-字符串转换整数-atoi-中等"><a href="#NO-8-字符串转换整数-atoi-中等" class="headerlink" title="NO.8 字符串转换整数 (atoi) 中等 "></a>NO.8 字符串转换整数 (atoi) <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/13/QgMsVP.png" alt="QgMsVP.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/13/QgMDbt.png" alt="QgMDbt.png"></p>
<p><font color=red><strong>思路一：三步串行法</strong></font> 瞎起了一个名字，其实就是简单的三个步骤逐一进行即可：1.跳过所有空格。2.确定正负号。3.找出连续的数字并进行溢出判断。</p>
<p>判断每个字符是否是数字时，.<strong>第一个</strong>字符可以是‘+’或‘-’，其余字符都必须是数字，循环才能继续。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        如果字符串为空直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        1.去掉所有空格</span></span><br><span class="line">        String s = str.trim();</span><br><span class="line"><span class="comment">//        如果去掉空格之后字符串为空，就返回0</span></span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        2.判断正负号</span></span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)flag=-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//        3.找出连续的数字</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;<span class="comment">//数字</span></span><br><span class="line">    <span class="comment">//            溢出判断</span></span><br><span class="line">                <span class="keyword">if</span> (flag==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (ans&gt;Integer.MAX_VALUE/<span class="number">10</span>||(ans==Integer.MAX_VALUE/<span class="number">10</span>&amp;&amp;c-<span class="string">'0'</span>&gt;<span class="number">7</span>))</span><br><span class="line">                        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ans*flag&lt;Integer.MIN_VALUE/<span class="number">10</span>||(ans*flag==Integer.MIN_VALUE/<span class="number">10</span>&amp;&amp;c-<span class="string">'0'</span>&gt;<span class="number">8</span>))</span><br><span class="line">                        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                ans=ans*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((c==<span class="string">'-'</span>||c==<span class="string">'+'</span>)&amp;&amp;i&lt;<span class="number">1</span>)&#123;<span class="comment">//第一个字符c不是数字，但c可以是正负号</span></span><br><span class="line"><span class="comment">//             空方法体，什么也不操作，进入第二次循环</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//既不是数字，也不是第一个正负号字符，直接结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最坏情况每个字符访问一次，所以时间复杂度是：O(n)</p>
<p><font color=red><strong>思路二：正则表达式法</strong></font> 这道题在leetcode上解答很少，因为题比较简单，大神都不屑于留恋。。</p>
<p>最简单的方法直接用正则，贴一个别人的python解法，一行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max(min(int(*re.findall(<span class="string">'^[\+\-]?\d+'</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), <span class="number">-2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最后一个单词的长度</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="NO-58-最后一个单词的长度-简单"><a href="#NO-58-最后一个单词的长度-简单" class="headerlink" title="NO.58 最后一个单词的长度 简单 "></a>NO.58 最后一个单词的长度 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/06/3qBaB6.png" alt="3qBaB6.png"></p>
<h3 id="思路一：逆序"><a href="#思路一：逆序" class="headerlink" title="思路一：逆序"></a><strong><font color=red>思路一：逆序</font></strong></h3><p>没什么好说的，从后往前找。注意trim()去空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    String str = s.trim();</span><br><span class="line">    <span class="keyword">int</span> i=str.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i)==<span class="string">' '</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.length()-i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字母异位词分组</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h2 id="NO-49-字母异位词分组-中等"><a href="#NO-49-字母异位词分组-中等" class="headerlink" title="NO.49 字母异位词分组 中等 "></a>NO.49 字母异位词分组 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/07/1gKM38.png" alt="1gKM38.png"></p>
<p><strong><font color=red>思路一：算术基本定理法</font></strong> 这是一个非常巧妙的方法。</p>
<p>算术基本定理(唯一分解定理)： 任何一个大于 1 的自然数都可以分解成一些素数的乘积；并且在不计次序的情况下，这种分解方式是唯一的。 ——欧几里得</p>
<ol>
<li>先申请一个包含26个不重复素数的数组prime[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103 ]，一个HashMap&lt;Interger,List&lt;String&gt;&gt;。</li>
<li>将字符串的每个字符减去’a’映射出对应的素数，将字符串和其映射出的素数的乘积作为键值对保存到哈希表中，最后哈希表中的所有List&lt;String&gt;作为结果集即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//26个字母分别对应一个素数</span></span><br><span class="line">    <span class="keyword">int</span>[] prime=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span>&#125;;</span><br><span class="line">    HashMap&lt;Integer,List&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> key=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs[i].length();j++)&#123;</span><br><span class="line">            <span class="comment">//字符串的每个字符对应的素数的乘积key</span></span><br><span class="line">            key*=prime[strs[i].charAt(j)-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            map.get(key).add(strs[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(key,<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            map.get(key).add(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>ps：此方法有一个严重的问题，key很容易发生溢出。</u></strong>最直接的解决方法就是采用大数类型的key。</p>
<p>时间复杂度：O(n*k)，k是字符串的最大长度</p>
<p><strong><font color=red>思路二：排序数组分类法</font></strong> 申请一个HashMap&lt;String,List&gt;，将每个字符串中的字符按照字典顺序排序后作为key、字符串本身作为value中的集合的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历每个字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">        <span class="comment">//将么个字符串中的字符按字典排序后作为key</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = strs[i].toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        String key = String.valueOf(chars);</span><br><span class="line">        <span class="comment">//key作为key，strs[i]作为value集合中的元素</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))map.put(key,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        map.get(key).add(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*klogk) n为元素个数，k为最长字符串长度，klogk是排序的时间复杂度</p>
<p><strong><font color=red>思路三：字符计数分类法</font></strong> 和思路三差不多的想法，申请一个HashMap&lt;String,List&gt;，将每个字符串中字符出现的字数统计之后转换成”n#n#n#n#….”形式的字符串作为key。例如abc转换为”1#1#1#0#0#…”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">        <span class="comment">//统计字符串中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs[i].length();j++)&#123;</span><br><span class="line">            count[strs[i].charAt(j)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将计数器转换成n#n#n#n#格式</span></span><br><span class="line">        String key=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;count.length;k++)&#123;</span><br><span class="line">            key+=count[k]+<span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))map.put(key,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        map.get(key).add(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nk)，k是最长字符串的长度</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>算术基本定理法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最大子序和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%20/</url>
    <content><![CDATA[<h2 id="NO-53-最大子序和-简单"><a href="#NO-53-最大子序和-简单" class="headerlink" title="NO.53 最大子序和 简单 "></a>NO.53 最大子序和 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/01/3g44rF.png" alt="3g44rF.png"></p>
<p><strong><font color=red>思路一：动态规划法</font></strong> 分析dp那就要先分析dp[i]的含义：以第i元素结尾的最大序列和。</p>
<p>初始化：dp[0]以第0号元素结尾的序列只有nums[0]本身，所以<code>dp[0]=nums[0]</code>。</p>
<p>转移方程：<code>dp[i]=Max(dp[i-1]+nums[i],nums[i])</code>，因为dp[i-1]是以i-1为结尾的序列和中的最大值，所以我们想找nums[i]结尾的最大序列和只需要比较”前一个最大序列和+nums[i]”和”nums[i]”。举个例子：</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3g4oVJ.md.png" alt="3g4oVJ.md.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//填写dp数组同时用max记录当前最大的序列和</span></span><br><span class="line">    <span class="keyword">int</span> max=dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i]=Math.max(nums[i],dp[i-<span class="number">1</span>]+nums[i]);</span><br><span class="line">        max=Math.max(max,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过思考不难发现，并不需要开辟一个数组来保存每一个子序和。每次填写只需要关心上一次状态值即可，且每个状态值只需要使用一次。所以我们可以用一个int变量代替dp数组即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> dp=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//更新当前i结尾的最大序列和同时用max记录最大的序列和</span></span><br><span class="line">    <span class="keyword">int</span> max=dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp=Math.max(nums[i],dp+nums[i]);</span><br><span class="line">        max=Math.max(max,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最小路径和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-64-最小路径和-中等"><a href="#NO-64-最小路径和-中等" class="headerlink" title="NO.64 最小路径和 中等 "></a>NO.64 最小路径和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/12/8Z4gQs.png" alt="8Z4gQs.png"></p>
<p><strong><font  color=red>思路一：动态规划</font></strong> 我们要找最小路径和，一定是走数值较小的位置并且不往回走不绕路，又因为是从左上走到右下，所以每次都向右或者向下移动。</p>
<p>dp数组的含义：dp[i][j]走到[i][j]位置的最小路径和。</p>
<p>初始化：dp[0][0]=[0][0]</p>
<p>状态转移：dp[i][j]=Min(dp[i-1][j]+dp[i][j-1])+[i][j]，因为每次只能向右或向下移动，所以[i][j]选择上方[i-1][j]或者左方[i][j-1]较小的路径走过来加上当前位置本身的值。要注意第一行没有上方、第一列没有左方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length,col=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="comment">//第一行</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;j!=<span class="number">0</span>)dp[i][j]=dp[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">            <span class="comment">//第一列</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)dp[i][j]=dp[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">            <span class="comment">//中间部分</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j!=<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            <span class="comment">//第一个元素[0][0]</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(row<em>col)    空间复杂度：O(row\</em>col)</p>
<p><strong><font  color=red>优化空间复杂度</font></strong> 直接在grid数组自身每个位置记录对应的最小路径和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length,col=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="comment">//第一行</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;j!=<span class="number">0</span>)grid[i][j]=grid[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">            <span class="comment">//第一列</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)grid[i][j]=grid[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">            <span class="comment">//中间部分</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j!=<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)grid[i][j]=Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            <span class="comment">//第一个元素[0][0]</span></span><br><span class="line">            <span class="keyword">else</span> grid[i][j]=grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(row*col)    空间复杂度：O(1)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-16-最接近的三数之和-中等"><a href="#NO-16-最接近的三数之和-中等" class="headerlink" title="NO.16 最接近的三数之和 中等 "></a>NO.16 最接近的三数之和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/18/QHphH1.png" alt="QHphH1.png"></p>
<h3 id="思路一：暴力破解法"><a href="#思路一：暴力破解法" class="headerlink" title="思路一：暴力破解法"></a><font color=red><strong>思路一：暴力破解法</strong></font></h3><p>用list保存所有的三数之和的情况，然后找出最接近target的数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    	<span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">3</span>)<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"error of argument!"</span>);</span><br><span class="line"><span class="comment">//        用list保存所有的三数之和</span></span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;len;k++)&#123;</span><br><span class="line">                    list.add(nums[i]+nums[j]+nums[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        遍历list找出最接近target的数</span></span><br><span class="line">        <span class="keyword">int</span> ans=list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(target-ans)&gt;Math.abs(target-i))</span><br><span class="line">                    ans=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)</p>
<h3 id="思路二：双指针法"><a href="#思路二：双指针法" class="headerlink" title="思路二：双指针法"></a><font color=red><strong>思路二：双指针法</strong></font></h3><p>和第15题的双指针法思路类似，本题免去了去重的操作。1. 先对数组排序，时间复杂度O(nlogn)。2. 依次遍历每个元素nums[i]。3. 然后用前后指针L=i+1和R=nums.length-1分别指向nums[i]后面部分的开头nums[L]和结尾nums[R]。4. 得到sum=nums[i]+nums[L]+nums[R]，如果sum更接近target，就更新ans。5. 如果sum==target，就已经找到最接近target的三数之和，返回sum；如果sum&gt;target，说明需要小一点的数来组合，即R–；如果sum&lt;target，说明需要大一点的数来组合，即L++。6. 如果没有得到sum==target，那么每次双指针都需要遍历所有”后面所有元素”，即while(L&lt;R)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len= nums.length,ans=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">3</span>)<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"error of argument!"</span>);</span><br><span class="line"><span class="comment">//        对数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"><span class="comment">//        依次遍历每个元素nums[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="comment">//            然后用前后指针L和R分别指向nums[i]后面部分的开头和结尾</span></span><br><span class="line">            <span class="keyword">int</span> L=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R=len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[L]+nums[R];</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(target-ans)&gt;Math.abs(target-sum))&#123;</span><br><span class="line">                    ans=sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum==target)&#123;<span class="comment">//如果sum==target，那就已经找到最接近target的三数之和</span></span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;target)&#123;<span class="comment">//如果sum&lt;target，说明需要大一点的数来组合，即L++</span></span><br><span class="line">                    L++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;target)&#123;<span class="comment">//如果sum&lt;target，说明需要小一点的数来组合，即R--；</span></span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)       整个遍历过程，固定值为 n 次，双指针为 n 次。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长上升子序列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-65-最长上升子序列-中等"><a href="#NO-65-最长上升子序列-中等" class="headerlink" title="NO.65 最长上升子序列 中等 "></a>NO.65 最长上升子序列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8QQPq1.png" alt="8QQPq1.png"></p>
<p>刚看到题，我以为寻找的这个上升子序列需要是连续的递增元素，所以我想双指针。发现行不通，重新审题发现，示例中的子序列元素不是连续的。。。</p>
<h3 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a><strong><font color=red>思路一：动态规划</font></strong></h3><p>dp数组含义：dp[i]nums前i个元素中最长上升子序列的长度。</p>
<p>初始化：初始状态全部为1，因为每个元素自身至少是长度为1子序列。</p>
<p>状态转移：填写dp[i]时遍历j∈[0,i，</p>
<p>如果i元素&gt;j元素则当前元素i可以接在j元素之后作为上升子序列dp[i]=Max(dp[i],dp[j]+1)；</p>
<p>否则i元素&lt;=j元素当前元素i不能拼接在j元素之后就忽略。</p>
<p>每次填写完dp[i]更新当前最长上升子序列长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">//如果i元素&gt;j元素，则i可以接在j元素后面作为上升子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[j])dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最大长度</span></span><br><span class="line">        maxLen=Math.max(maxLen,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h3 id="思路二：TreeSet"><a href="#思路二：TreeSet" class="headerlink" title="思路二：TreeSet"></a><strong><font color=red>思路二：TreeSet</font></strong></h3><p>JAVA Api中的TreeSet有ceiling(x)方法，取大于x的数，如果不存在则返回null。(此方法时间复杂度O(logn)，但是最坏情况下会退化到O(n))</p>
<p>按序遍历nums，到TreeSet中取大于num的数x，如果存在x则删除x并将num加入set，如果不存在就是所有的数都小于num就将num加入set。</p>
<p>最后返回set的大小即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TreeSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        Integer x = set.ceiling(num);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.remove(x);</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏时间复杂度仍然是：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长公共前缀</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h2 id="NO-14-最长公共前缀-简单"><a href="#NO-14-最长公共前缀-简单" class="headerlink" title="NO.14 最长公共前缀 简单 "></a>NO.14 最长公共前缀 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/20/QX69xS.png" alt="QX69xS.png"></p>
<p><font color=red><strong>思路一：依次LCP法</strong></font>假设输入数组为[“leetcode”,”leetcodes”,”leetgo”,”letsgo”]：1. 我们先让0号元素和1号元素求公共前缀 LCP(0号元素，1号元素)求出最长公共前缀prefix=”leetcode”。2. 然后prefix=LCP[prefix，2号元素]求出prefix=leet。3. prefix=LCP[prefix，3号元素]求出prefix=le。求出最终的答案”le”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        如果数组元素个数为0，返回""</span></span><br><span class="line">        <span class="keyword">if</span> (strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="comment">//        假设最长公共前缀是数组第一个元素</span></span><br><span class="line">        String prefix=strs[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//        从前向后数组元素依次和当前最长公共前缀比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前被比较的元素不含有当前最长前缀，就将当前最长前缀从后面减少一位</span></span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(prefix)!=<span class="number">0</span>)&#123;</span><br><span class="line">                prefix=prefix.substring(<span class="number">0</span>,prefix.length()-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//                如果当前最长前缀已经为空，则说明数组中的元素没有公共前缀，直接返回""</span></span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty())<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(s)  s是数组中每个字符串的字符个数之和</p>
<p>空间复杂度:O(1)</p>
<p><font color=red><strong>思路二：优化依次LCP法</strong></font> 上述方法中，无论数组每个元素的长短我们都需要从第一个数组元素比较到最后一个数组元素，所以有一个明显的问题：如果数组中最后一个元素非常短，但是我们仍然需要比较s次。</p>
<p>可以将思路一的算法改为从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。 </p>
<p>依然假设输入数组为[“leetcode”,”leetcodes”,”leetgo”,”letsgo”]：1. 第一次循环i=0先用0号元素的第一个字符”l”，去和1号元素的第一个字符比较，相等；继续去和第2号元素的第一个字符比较，相等；继续去和第3号元素的第一个字符比较，相等；2. 第二次循环i=1再用0号元素的第二个字符”e”，去和1号元素的第二个字符比较，相等；继续去和第2号元素的第二个字符比较，相等；继续去和第3号元素的第二个字符比较，相等；3. 第三次循环i=2再用0号元素的第三个字符”e”，去和1号元素的第三个字符比较，相等；继续去和第2号元素的第三个字符比较，相等；继续去和第3号元素的第三个字符比较，不相等，则返回数组0号元素[0,i)字符，即”le”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="comment">//        将数组的0号元素的每个字符逐一取出进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs[<span class="number">0</span>].length();i++)&#123;</span><br><span class="line"><span class="comment">//            取出数组0号元素的i号字符</span></span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line"><span class="comment">//            将c和数组的每个元素的i号字符进行比较</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;strs.length;j++)&#123;</span><br><span class="line"><span class="comment">//                如果某个元素的所有字符都已比较完毕（即最短的元素）或者某个元素的第i个字符和c不相等</span></span><br><span class="line">                <span class="keyword">if</span> (i==strs[j].length()||strs[j].charAt(i)!=c)&#123;</span><br><span class="line"><span class="comment">//                    则0号元素的[0，i)号字符就是公共前缀</span></span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(s)  s是数组中每个字符串的字符个数之和。在最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 n*minLen 次比较，其中minLen是数组中最短字符串的长度。</p>
<p>空间复杂度:O(1)</p>
<p><font color=red><strong>思路三：分治法</strong></font> 其实这方法也是上述的依次LCP法的一种优化方法，LCP(s1,s2,…,sn)=LCP(LCP(s1,s2,…,smid),LCP(smid+1,smid+2,…sn))。</p>
<p>先将数组元素分成两部分，分别求LCP得到lcpLeft和lcpRight，最后求LCP(lcpLeft，lcpRight)得到prefix。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;    </span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span> , strs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">        String lcpRight =  longestCommonPrefix(strs, mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">commonPrefix</span><span class="params">(String left,String right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(left.length(), right.length());       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">            <span class="keyword">return</span> left.substring(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.substring(<span class="number">0</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(S)，S是所有字符串中字符数量的总和，S=m∗n。</p>
<p>空间复杂度：O(m*log(n))</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>分治算法</tag>
        <tag>LCP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="NO-32-最长有效括号-困难"><a href="#NO-32-最长有效括号-困难" class="headerlink" title="NO.32 最长有效括号 困难 "></a>NO.32 最长有效括号 <font color=#ff0099>困难</font> <a id="more"></a></h1><p><img src="https://s2.ax1x.com/2020/02/22/3QkcHf.png" alt="3QkcHf.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 遍历所有偶数长度的子串，得到最长的有效括号序列。但是此方法会超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//只要偶数长度的，奇数长度一定无效</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;=s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(s.substring(i,j)))&#123;</span><br><span class="line">                maxLen=Math.max(maxLen,j-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断括号序列是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">            stack.push(<span class="string">'('</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)</p>
<p><strong><font color=red>思路二：优化暴力法</font></strong> 简单的优化上面的方法，暴力法会有很多可以避免的判断，例如我们判断下标为0长度是2的序列是有效的，接下来判断长度为4、为6。。。的序列的时候，依然要从0开始判断，实际上并不需要，因为每个序列的前一个序列已经判断过之前的部分是有效的了。</p>
<p>因为题目中说只有’(‘和’)’两种字符，所以我们用1表示’(‘、用-1表示’)’。用count记录每个序列的和，如果小于0则说明’)’过多了当前序列无效，如果最终count等于0，则说明当前序列有效，更新有效序列长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="comment">// ( +1,) -1</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j)==<span class="string">'('</span>)count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">            <span class="comment">//小于0说明 )比(多，无效序列</span></span><br><span class="line">            <span class="keyword">if</span> (count&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//有效序列，更新maxLen</span></span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">0</span>)maxLen=Math.max(maxLen,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><strong><font color=red>思路三：动态规划</font></strong> dp数组的含义：dp[i]以下标为i结尾的有效序列的最大长度。</p>
<p>初始化：dp数组元素都初始化为0。</p>
<p>填写dp数组，状态转移方程：</p>
<ol>
<li><p>如果i是’(‘，以左括号结尾的序列一定是无效序列，所以<code>依然为0</code>。</p>
</li>
<li><p>如果i是’)’，以有括号结尾的序列分两种情况：</p>
<ul>
<li><p>如果i-1是’(‘，组成形如”()”。<code>dp[i]=dp[i-2]+2</code>，意思是在前一个有效序列的长度基础上加上当前结尾长度为2的”()”。</p>
<p>例如，dp[2]=dp[2-2]+2=2、dp[4]=dp[4-2]+2=4</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31i82j.png" alt="31i82j.png"></p>
</li>
<li><p>如果i-1是’)’，组成形如”))”。需要检查<code>i-dp[i-1]-1</code>是否为’(‘，意思是检查i的前一个有效序列之前是否为’(‘。<u>如果是左括号</u>，则可以和i组成”()”，则<code>dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2</code>意思是<code>i之前的有效序列长度</code>加上<code>与i进行匹配的左括号前面的有效序列长度</code>加上<code>新增的序列长度2</code>。<u>如果不是左括号</u>，则无法与i进行匹配，即当前i结尾的是无效序列，<code>依然为0</code>。</p>
<p>例如，dp[6]=dp[6-1]+dp[6-dp[6-1]-2]+2=6</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31AOdx.png" alt="31AOdx.png"></p>
</li>
</ul>
</li>
</ol>
<p>==实现的时候要注意判断下标越界。==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    <span class="comment">//遍历每个字符并填写dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="comment">//如果i是')'，分两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="comment">//情况一，i-1是'('。则可以和i有效组合。</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>)==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i-<span class="number">2</span>&gt;=<span class="number">0</span>) dp[i]=dp[i-<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i]=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//情况二，i-1是')'</span></span><br><span class="line">                <span class="comment">//如果i之前的有效序列之前是个左括号，则可以和i有效组合。否则i结尾的序列无效</span></span><br><span class="line">                <span class="keyword">if</span> (i-dp[i-<span class="number">1</span>]-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;s.charAt(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)==<span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i-dp[i-<span class="number">1</span>]-<span class="number">2</span>&gt;=<span class="number">0</span>)dp[i]=dp[i-<span class="number">1</span>]+dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新maxLen</span></span><br><span class="line">        maxLen=Math.max(maxLen,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    大量的if else可以用三元运算符优化。</p>
<p>空间复杂度：O(n)</p>
<p>   <strong><font color=red>思路四：两次遍历</font></strong> 到这里，这个找最长有效括号的算法已经从n^3优化到了n。但是通过学习大佬的题解，发现另一种解法，时间复杂度是O(n)的同时将空间复杂度降至了常数。</p>
<p>先顺序扫描一遍，同时用left和right保存左右括号的个数：</p>
<ul>
<li>如果left&gt;right，则继续扫描。</li>
<li>如果left&lt;right，则一定是无效序列，归零left、right。</li>
<li>如果left==right，则是有效序列，更新maxLen。</li>
</ul>
<p>归零left、right。再逆序扫描一遍，同样的校验方法(逆序遍历则是left&gt;right无效)。</p>
<p>最终得到maxLen。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//正序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//统计左右括号数量</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右括号数量相等，则有效序列，更新maxLen</span></span><br><span class="line">        <span class="keyword">if</span> (left==right)&#123;</span><br><span class="line">            maxLen=Math.max(maxLen,right+left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (left&lt;right)&#123;<span class="comment">//右括号多于左括号，无效序列，重置计数</span></span><br><span class="line">            left=<span class="number">0</span>;</span><br><span class="line">            right=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left=<span class="number">0</span>;</span><br><span class="line">    right=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//逆序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//统计数量</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左右括号数量相等，有效序列，更新maxLen</span></span><br><span class="line">        <span class="keyword">if</span> (left==right)&#123;</span><br><span class="line">            maxLen=Math.max(maxLen,right+left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (left&gt;right)&#123;<span class="comment">//如果左括号多于有括号，无效序列，重置计数</span></span><br><span class="line">            left=<span class="number">0</span>;</span><br><span class="line">            right=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    </p>
<p>空间复杂度：O(1)</p>
<p>最开始很迷惑为什么两次遍历可以得到正确的maxLen，后来在纸上写了几种不同情况的括号序列模拟了一下，不由得感叹：妙啊！牛逼的算法就是简单！有效！</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——组合总和II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/</url>
    <content><![CDATA[<h2 id="NO-40-组合总和-II-中等"><a href="#NO-40-组合总和-II-中等" class="headerlink" title="NO.40 组合总和 II 中等 "></a>NO.40 组合总和 II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10uUoQ.png" alt="10uUoQ.png"></p>
<p>本题和<a href="https://blog.csdn.net/qq_42758551/article/details/104161792" target="_blank" rel="noopener">徒手挖地球十二周目</a>中<u>组合总和</u>的思路一样只是少量变化，区别在于本题candidate数组中的元素不能重复使用(只能使用一次)，本题数组中有重复元素。</p>
<p><font color=red><strong>思路一：深度优先遍历，回溯法</strong></font> 从39题组合总和的基础上进行分析改进：</p>
<ol>
<li>本题数组中的每个元素不能重复使用，但是数组中存在重复元素(每个相等元素都可以使用一次)</li>
<li>每个节点的孩子应该使用下一个元素开始，即不再是index而是index+1；</li>
<li>本题数组中存在重复元素，所以仅仅采用<u>”每个孩子从下一个元素(index+1)开始”</u>是不够的，因为index之后的元素依然可能重复，因此我们不能让<strong>相等元素不能作为兄弟节点，但是可以作为父子</strong>。根据这个发现，我们可以先将candidates排序，然后每次搜索时如果本节点和前面的兄弟节点相等，则剪枝。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] candidates;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">this</span>.candidates=candidates;</span><br><span class="line">    <span class="comment">//排序，将重复元素紧凑在一起</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    dfs(target,<span class="number">0</span>,<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> index, LinkedList&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//说明找到符合要求的路径</span></span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(ans));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">        <span class="comment">//本节点和前面的兄弟节点相等,则小剪枝，跳过这条路径</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果减数大于目标值则差为负数，不符合结果，且后续元素都大于目标值，大剪枝，结束后序搜索</span></span><br><span class="line">        <span class="keyword">if</span> (target&lt;candidates[i]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(candidates[i]);</span><br><span class="line">        <span class="comment">//不能重复使用同一元素，所以下次搜索起点从index+1开始</span></span><br><span class="line">        dfs(target-candidates[i],i+<span class="number">1</span>,ans);</span><br><span class="line">        <span class="comment">//每次回溯移除最后一次添加的元素</span></span><br><span class="line">        ans.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="NO-10-正则表达式匹配-困难"><a href="#NO-10-正则表达式匹配-困难" class="headerlink" title="NO.10 正则表达式匹配 困难 "></a>NO.10 正则表达式匹配 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/11/1TQmNV.png" alt="1TQmNV.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/11/1TQeA0.png" alt="1TQeA0.png"></p>
<p><strong><font color=red>思路一：回溯法</font></strong> 这种匹配思路其实就是不断地减掉s和p的可以匹配首部，直至一个或两个字符串被减为空的时候，根据最终情况来得出结论。</p>
<p>如果只是两个普通字符串进行匹配，按序遍历比较即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( s.charAt(i) == p.charAt(i) )</span><br></pre></td></tr></table></figure>

<p>如果正则表达式字符串p只有一种”.”一种特殊标记，依然是按序遍历比较即可 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( s.charAt(i) == p.charAt(i) || p.charAt(i) == <span class="string">'.'</span> )</span><br></pre></td></tr></table></figure>

<p>上述两种情况实现时还需要判断字符串长度和字符串判空的操作。</p>
<p>但是，”*“这个特殊字符需要特殊处理，<u>当p的第i个元素的下一个元素是星号时</u>会有两种情况：</p>
<ol>
<li>i元素需要出现0次，<u>我们就保持s不变，将p的减掉两个元素，调用isMatch。</u>例如s：bc、p：a<em>bc，我们就保持s不变，减掉p的”a\</em>“，调用isMatch(s:bc,p:bc)。</li>
<li>i元素需要出现一次或更多次，<u>先比较i元素和s首元素，相等则保持p不变，s减掉首元素，调用isMatch。</u>例如s：aabb、p：a<em>bb，就保持p不变，减掉s的首元素，调用isMatch(s:abb,p:a\</em>bb)。</li>
</ol>
<p>此时存在一些需要思考的情况，例如s：abb、p：a*abb，会用两种方式处理：</p>
<ol>
<li>按照上述第二种情况比较i元素和s首元素，发现相等就会减掉s的首字符，调用isMatch(s:bb,p:a*abb)。在按照上述第一种情况减去p的两个元素，调用isMatch(s:bb,p:abb)，最终导致false。</li>
<li>直接按照上述第一种情况减去p的两个元素，调用isMatch(s:abb,p:abb)，最终导致true。</li>
</ol>
<p>所以说这算是一种暴力方法，会将所有的情况走一边，看看是否存在可以匹配的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果正则串p为空字符串s也为空这匹配成功，如果正则串p为空但是s不是空则说明匹配失败</span></span><br><span class="line">    <span class="keyword">if</span> (p.isEmpty())<span class="keyword">return</span> s.isEmpty();</span><br><span class="line">    <span class="comment">//判断s和p的首字符是否匹配，注意要先判断s不为空</span></span><br><span class="line">    <span class="keyword">boolean</span> headMatched=!s.isEmpty()&amp;&amp;(s.charAt(<span class="number">0</span>)==p.charAt(<span class="number">0</span>)||p.charAt(<span class="number">0</span>)==<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (p.length()&gt;=<span class="number">2</span>&amp;&amp;p.charAt(<span class="number">1</span>)==<span class="string">'*'</span>)&#123;<span class="comment">//如果p的第一个元素的下一个元素是*</span></span><br><span class="line">        <span class="comment">//则分别对两种情况进行判断</span></span><br><span class="line">        <span class="keyword">return</span> isMatch(s,p.substring(<span class="number">2</span>))||</span><br><span class="line">            (headMatched&amp;&amp;isMatch(s.substring(<span class="number">1</span>),p));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (headMatched)&#123;<span class="comment">//否则，如果s和p的首字符相等</span></span><br><span class="line">        <span class="keyword">return</span> isMatch(s.substring(<span class="number">1</span>),p.substring(<span class="number">1</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((n+m)*2^(n+m/2)) n和m分别是s和p的长度</p>
<p><strong><font color=red>思路二：动态规划法</font></strong> 本题的dp数组的含义就是：dp[i][j]就是s的前i个元素是否可以被p的前j个元素所匹配。</p>
<p>我们知道了dp数组的含义之后就知道了dp数组的几个细节：</p>
<ol>
<li>dp[0][0]一定是true，因为s为空且p也为空的时候一定是匹配的；dp[1][0]一定是false，因为s有一个字符但是p为空的时候一定是不匹配的。</li>
<li>这个boolean类型的dp数组的大小应该是dp[s.length+1][p.length+1]，因为我们不仅仅要分别取出s和p的所有元素，还要表示分别取s和p的0个元素时候(都为空)的情况。</li>
<li>当写到dp[s.length][p.length]的时候，我们就得到了最终s和p的匹配情况。</li>
<li>dp[1][0]~dp[s.length][0]这一列都是false，因为s不为空但是p为空一定不能匹配。</li>
</ol>
<p>所以创建好dp数组之后，初始化dp[0][0]=true、dp[0][1]=false、dp[1][0]~dp[s.length][0]都是false。然后将第一行即dp[0][2]到dp[0][p.length]的元素初始化。</p>
<p>第一行初始化思路：如果不为空的p想要匹配上为空的s，因为此时p已经不为空，则需要p是”a*“、”b*“、”c*“。。。这种形式的才能匹配上。</p>
<p>然后填写数组的其余部分，这个过程中如果p.charAt(j)==’*&#39;依然是遵循上题中的两种情况；否则就判断两个字符串的i和j号字符是否相等，相等则分别减除当前字符继续判断，不相等则直接等于false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要分别取出s和p为空的情况，所以dp数组大小+1</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化dp[0][0]=true,dp[0][1]和dp[1][0]~dp[s.length][0]默认值为false所以不需要显式初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//填写第一行dp[0][2]~dp[0][p.length]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=p.length();k++)&#123;</span><br><span class="line">        <span class="comment">//p字符串的第2个字符是否等于'*',此时j元素需要0个，所以s不变p减除两个字符</span></span><br><span class="line">        dp[<span class="number">0</span>][k]=p.charAt(k-<span class="number">1</span>)==<span class="string">'*'</span>&amp;&amp;dp[<span class="number">0</span>][k-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填写dp数组剩余部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p.length();j++)&#123;</span><br><span class="line">            <span class="comment">//p第j个字符是否为*</span></span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="comment">//两种情况:1.s不变[i+1],p移除两个元素[j+1-2]。</span></span><br><span class="line">                <span class="comment">// 2.比较s的i元素和p的j-1(因为此时j元素为*)元素,相等则移除首元素[i+1-1],p不变。</span></span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]||</span><br><span class="line">                    (dp[i][j+<span class="number">1</span>]&amp;&amp;headMatched(s,p,i,j-<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//s的i元素和p的j元素是否相等,相等则移除s的i元素[i+1-1]和p的j元素[j+1-1]</span></span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]&amp;&amp;headMatched(s,p,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断s第i个字符和p第j个字符是否匹配</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">headMatched</span><span class="params">(String s,String p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.charAt(i)==p.charAt(j)||p.charAt(j)==<span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*m) n和m分别是s和p的长度</p>
<p>有了第一题总结的”经验”之后，这道题逻辑上不难理解，但是细节上尤其各种下标值非常的恶心。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>回溯</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——组合总数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-39-组合总数-中等"><a href="#NO-39-组合总数-中等" class="headerlink" title="NO.39 组合总数 中等 "></a>NO.39 组合总数 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/28/1Kc5Js.png" alt="1Kc5Js.png"></p>
<p><font color=red><strong>思路一：深度遍历，回溯法</strong></font> 深度遍历得到”全排列“的过程中回溯剪枝。目标值作为根节点，每个分做减法，如果目标值被减为0则结算此分支路径上的减数集合，如果目标值被减为负数则剪枝即可。</p>
<p>去重：每个分支节点上的减数的下标不能比本分支上一层节点的减数的下标小。即，上层节点的减数下标为3，则同分支下一层节点的减数下标要从3开始。(这样每个分支就不会重复使用之前使用过的元素)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">    dfs(target,<span class="number">0</span>,<span class="keyword">new</span> Stack&lt;Integer&gt;(),candidates);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> index, Stack&lt;Integer&gt; pre, <span class="keyword">int</span>[] candidates)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等于零说明结果符合要求</span></span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(pre));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历，index为本分支上一节点的减数的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">        <span class="comment">//如果减数大于目标值，则差为负数，不符合结果</span></span><br><span class="line">        <span class="keyword">if</span> (candidates[i]&lt;=target)&#123;</span><br><span class="line">            pre.push(candidates[i]);</span><br><span class="line">            <span class="comment">//目标值减去元素值</span></span><br><span class="line">            dfs(target-candidates[i],i,pre, candidates);</span><br><span class="line">            <span class="comment">//每次回溯将最后一次加入的元素删除</span></span><br><span class="line">            pre.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字符串压缩</title>
    <url>/2020/03/14/%5B%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%5D%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h2 id="NO-01-06-字符串压缩-简单"><a href="#NO-01-06-字符串压缩-简单" class="headerlink" title="NO.01.06 字符串压缩 简单 "></a>NO.01.06 字符串压缩 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/16/8G1O91.png" alt="8G1O91.png"></p>
<p><strong><font color=red>思路一：遍历</font></strong> 看到题，没什么好的思路，直接遍历统计。最后比较两个字符串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S==<span class="keyword">null</span>||S.length()&lt;<span class="number">2</span>)<span class="keyword">return</span> S;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">        <span class="keyword">while</span> (i&lt;S.length()-<span class="number">1</span>&amp;&amp;c==S.charAt(i+<span class="number">1</span>))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(c).append(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.length()&lt;S.length()?sb.toString():S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两数相加</title>
    <url>/2019/10/01/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="NO-2-两数相加-中等"><a href="#NO-2-两数相加-中等" class="headerlink" title="NO.2 两数相加    中等 "></a>NO.2 两数相加    <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMw8XR.png" alt="QMw8XR.png"></p>
<p><font color=red><strong>思路一：转换法</strong></font>    1.将两个链表先转化成int或long类型数值x和y。2.x和y相加后的值再转换成链表。</p>
<p><strong>缺点</strong>：当参数中两个链表足够长时，得到的结果很有可能会超出int或long类型的范围发生溢出。</p>
<p>可以将x和y用BigDecimal类型来存储尽可能避免发生溢出，<strong><u>需要注意的是题目中链表都是逆序的</u></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">""</span>;</span><br><span class="line">        String s2=<span class="string">""</span>;</span><br><span class="line">        ListNode q=l1,p=l2;</span><br><span class="line"><span class="comment">//        将两个链表转化为字符串</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s1=q.val+s1;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s2=p.val+s2;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        BigDecimal x=<span class="keyword">new</span> BigDecimal(s1);</span><br><span class="line">        BigDecimal y=<span class="keyword">new</span> BigDecimal(s2);</span><br><span class="line">        BigDecimal z=x.add(y);</span><br><span class="line"><span class="comment">//        将结果转换成链表</span></span><br><span class="line">        <span class="keyword">char</span>[] chars=z.toString().toCharArray();</span><br><span class="line">        ListNode result=<span class="keyword">new</span> ListNode(Integer.parseInt(String.valueOf(chars[chars.length-<span class="number">1</span>])));</span><br><span class="line">        ListNode t=result;</span><br><span class="line"><span class="comment">//        因为链表是逆序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=chars.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ListNode temp=<span class="keyword">new</span> ListNode(Integer.parseInt(String.valueOf(chars[i])));</span><br><span class="line">            t.next=temp;</span><br><span class="line">            t=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：初等数学法</strong></font>    1.因为链表本身就是逆序的，所以从后向前按位依次加。2.用一个int变量carry来记录前一位相加后得到的进位。3.如果一个链表已经遍历完毕，在后续的按位相加时，该链表的节点值就是0。4.每次按位相加之后更新进位值carry，并将进位之后的数值加入结果链表。5.<u>两个链表遍历相加结束之后，需要再次判断进位值，防止遗漏最高位的进位。</u></p>
<p><strong><u>需要注意的是每次按位相加时，不要忘记加上进位值carry。</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        用哑节点来简化代码，如果没有使用哑节点就需要额外的代码来初始化表头的值</span></span><br><span class="line">        ListNode dummyHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode q=l1,p=l2,curr=dummyHead;</span><br><span class="line"><span class="comment">//        进位标志carry</span></span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>||p!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//          获取节点值，如果节点为空，值就为0</span></span><br><span class="line">            <span class="keyword">int</span> x=q==<span class="keyword">null</span>?<span class="number">0</span>:q.val;</span><br><span class="line">            <span class="keyword">int</span> y=p==<span class="keyword">null</span>?<span class="number">0</span>:p.val;</span><br><span class="line"><span class="comment">//          两个节点值和进位相加</span></span><br><span class="line">            <span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line"><span class="comment">//          获取相加之后的进位值</span></span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line"><span class="comment">//          将相加后结果加入结果链表</span></span><br><span class="line">            curr.next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line"><span class="comment">//          移动到下一个节点</span></span><br><span class="line">            curr=curr.next;</span><br><span class="line">            <span class="keyword">if</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        最后判断是否仍有进位，防止进位被遗漏</span></span><br><span class="line">        <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            curr.next=<span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        因为第一个节点是哑节点，</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(max(m,n))</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——计算质数</title>
    <url>/2019/10/01/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-204-计算质数-简单"><a href="#NO-204-计算质数-简单" class="headerlink" title="NO.204 计算质数    简单 "></a>NO.204 计算质数    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMwlp4.png" alt="QMwlp4.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font>    双层for循环。1.第一层循环遍历逐个判断[2,n)。2.第二层循环判断参数是否为素数。：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime(i))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^2)</p>
<p><strong>可改进点：</strong>例如，12=2*6、12=3*4、12=sqrt(12)*sqrt(12)、12=4*3、12=6<em>2，可以观察到后面就是前面两个数反过来，说明查找可以整除12的因子时只需要找到“一半”的位置即可，如果前“一半”没有可以整除的因子，那么后“一半”也没有，这个临界点“一半”就是sqrt(12)。所以上述isPrime()方法的循环条件可以写为“i\</em>i&lt;n”即可，该方法时间复杂度降到了O(sqrt(n))。</p>
<p><font color=red><strong>思路二：厄拉多塞筛法</strong></font>    不难想象，所有质数的倍数都不是质数。例如，2是质数，2的倍数4、6、8、10、12。。。都不是质数；3是质数，3的倍数6、9、12、15。。。都不是质数；可以看一下维基百科中一个厄拉多塞筛的gif图：</p>
<p><img src="https://s2.ax1x.com/2019/12/03/QMw11J.gif" alt="QMw11J.gif"></p>
<p>这种方法大概就是“排除法”，每确定一个质数，就可以排除一批非质数，那么算法就可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isPrimes[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrimes,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//		将所有质数的倍数设置为false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;n;j+=i)&#123;</span><br><span class="line">                isPrimes[j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//      统计所有质数，即isPrimes[i]==true的为质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述算法还存在两处冗余：</p>
<ol>
<li>在本题的暴利算法下说的：只需要判断到sqrt(n)即可。</li>
<li>例如，12不是质数，所以会被设置为false，但是12既是2的倍数，也是3的倍数，所以它被标记了两次。</li>
</ol>
<p>解决上述两处冗余后的算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isPrimes[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrimes,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//        只需要判断小于sqrt(n)的数是否为质数即可，所以i*i&lt;n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;n;i++)&#123;</span><br><span class="line"><span class="comment">//            这样可以把质数i的整数倍都标记为false，但是仍然存在计算冗余。</span></span><br><span class="line"><span class="comment">//            比如n=25，i=4时算法会标记4×2=8，4×3=12等等数字，</span></span><br><span class="line"><span class="comment">//            但是这两个数字已经被i=2和i=3的2×4和3×4标记了。所以使用j=i*i减少此计算的冗余。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i*i;j&lt;n;j+=i)&#123;</span><br><span class="line">                isPrimes[j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//      统计所有质数，即isPrimes[i]==true的为质数</span></span><br><span class="line"><span class="comment">//        这里要注意从2开始，因为0,1不是质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>厄尔拉塞筛法的时间复杂度：O(nloglogn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>厄拉多塞筛</tag>
      </tags>
  </entry>
  <entry>
    <title>c3p0版本太低导致的错误</title>
    <url>/2019/06/18/c3p0%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E%E5%AF%BC%E8%87%B4%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>今天做了一个<strong>jsp、servlet、mybatis、spring ioc</strong>的简单复习（大概就是在web上最简单的增删改查）。出现了一个错误让我调试了好一会儿，最终百度解决。。。的问题。<a id="more"></a></p>
<p>我开始时配置<strong>DataSource</strong>用的是<strong>c3p0-0.9.1.2版本</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/05/28/Vnk44P.png" alt="c3p0-0.9.1.2版本"></p>
<p><strong>运行时报错信息</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/05/28/Vnko38.png" alt="运行时出现错误"></p>
<p>检查了一边代码，捋了一遍逻辑，找不出问题。索性换成dbcp的数据源（BasicDataSource ），就正常运行了。（开始怀疑是c3p0的jar包有毛病，毕竟我那么吊，怎么可能会写错！！！）</p>
<p><strong>百度了一下，果然是因为c3p0版本太低</strong>（跟不上我的技术了，哈哈）。</p>
<p>下载了一个高版本的c3p0jar包（c3p0-0.9.5.2），问题迎刃而解。</p>
<p><img src="https://s2.ax1x.com/2019/05/28/VnkI9f.png" alt="高版本c3p0"></p>
<p><img src="https://s2.ax1x.com/2019/05/28/VnkbuQ.png" alt="耶~问题解决！"></p>
<p>最烦<strong>jar包不匹配</strong>或者<strong>开发环境有问题</strong>导致的错误，实在是不好找原因！！！</p>
<p>记录一下百度百科上<strong>c3p0和dbcp的区别</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/05/28/VnkTgS.png" alt="c3p0和dbcp的区别"></p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC中的集合参数绑定</title>
    <url>/2019/06/09/SpringMVC%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>绑定数组参数和集合参数<a id="more"></a></p>
<h2 id="1-绑定数组参数"><a href="#1-绑定数组参数" class="headerlink" title="1. 绑定数组参数"></a>1. 绑定数组参数</h2><p><u>语言匮乏，组织不好语言。。。直接上例子。。</u></p>
<p>例子：页面中多个checkbox<strong>组件</strong>的<strong>name</strong>都是ids。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/queryItem.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">查询条件：</span><br><span class="line">&lt;table width=<span class="string">"100%"</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;商品id&lt;input type="text" name="item.id" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;商品名称&lt;input type="text" name="item.name" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">商品列表：</span><br><span class="line">&lt;table width=<span class="string">"100%"</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;选择&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品名称&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品价格&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;生产日期&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品描述&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;操作&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;itemList &#125;"</span> <span class="keyword">var</span>=<span class="string">"item"</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;&lt;input type="checkbox" name="ids" value="$&#123;item.id&#125;"/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.name &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.price &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>controller方法可以用一个数组做形参，MVC的处理器适配器就会自动绑定参数。</p>
<p>对应以上的例子，controller方法的形参可以是<strong>Integer[ ]</strong> 类型，表单提交后被选中的checkbox的<strong>value</strong>就会被自动绑定到方法的形参中去。</p>
<h2 id="2-绑定集合参数"><a href="#2-绑定集合参数" class="headerlink" title="2.  绑定集合参数"></a>2.  绑定集合参数</h2><p>依然是上面的jsp文件，controller方法的形参直接改为<strong>List&lt;Integer&gt;</strong>,表单提交后会报错！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报错信息：Failed to instantiate [java.util.List]: Specified class is an interface</span><br></pre></td></tr></table></figure>

<p>此时需要一个pojo对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemVo</span> </span>&#123;</span><br><span class="line">	。</span><br><span class="line">    。</span><br><span class="line">    。</span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line">	</span><br><span class="line">	getter/setter。。。</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>将controller方法的形参改为ItemVo类型，会自动将表单提交来的参数，按参数名绑定到pojo类的集合属性中。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller方法的返回值</title>
    <url>/2019/06/09/Controller%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<h3 id="1-返回ModelAndView"><a href="#1-返回ModelAndView" class="headerlink" title="1. 返回ModelAndView"></a>1. 返回ModelAndView<a id="more"></a></h3><p>最开始学习的时候就是返回这个类，可以给这个类添加model数据和指定view。</p>
<h3 id="2-返回void"><a href="#2-返回void" class="headerlink" title="2. 返回void"></a>2. 返回void</h3><p>返回值为空，那么model数据和view怎么办呢？</p>
<p>可以在形参中使用request和response，完成域对象存取数据、重定向、转发。。。（这里就有点像最初的servlet了）</p>
<h3 id="3-返回字符串"><a href="#3-返回字符串" class="headerlink" title="3. 返回字符串"></a>3. 返回字符串</h3><p>controller方法返回字符串可以指定<strong>逻辑视图名</strong>，通过<strong>视图解析器</strong>解析为<strong>物理视图地址</strong>。（类似于指定view）</p>
<p>可以在字符串前加<strong>Redirect</strong>或者<strong>forward</strong>完成<strong>重定向</strong>或<strong>转发</strong>。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>@RequestMapping注解的作用</title>
    <url>/2019/06/09/@RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-URL路径映射"><a href="#1-URL路径映射" class="headerlink" title="1. URL路径映射"></a>1. URL路径映射<a id="more"></a></h3><p>最常用，用的最多的属性value</p>
<p>@RequestMapping(value=”item”)或@RequestMapping(“/item”）</p>
<p>value的值是数组，可以将多个url映射到同一个方法</p>
<h3 id="2-添加在类上面"><a href="#2-添加在类上面" class="headerlink" title="2. 添加在类上面"></a>2. 添加在类上面</h3><p>在<strong>class</strong>上添加<strong>@RequestMapping(url)</strong>指定<strong>通用请求前缀</strong>， <u>限制此类下的所有方法请求url必须以请求前缀开头</u>。</p>
<p><font color="red"><strong>可以使用此方法对url进行分类管理。</strong></font></p>
<h3 id="3-请求方法限定"><a href="#3-请求方法限定" class="headerlink" title="3. 请求方法限定"></a>3. 请求方法限定</h3><p>method属性，可以限制请求的方法GET、POST。。。</p>
<p>并且该方法也是一个数组，可以指定多个请求的方法。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
