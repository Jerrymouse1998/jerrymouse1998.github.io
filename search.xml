<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>分布式之Redis之为什么</title>
    <url>/2020/03/15/(%E8%BD%AC)%E5%88%86%E5%B8%83%E5%BC%8F%E4%B9%8BRedis/</url>
    <content><![CDATA[<p>作者：孤独烟 </p>
<p>出处：<a href="http://rjzheng.cnblogs.com/" target="_blank" rel="noopener"> http://rjzheng.cnblogs.com/</a></p>
<p>本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。<a id="more"></a></p>
<p>[TOC]</p>
<h1 id="1、为什么使用redis"><a href="#1、为什么使用redis" class="headerlink" title="1、为什么使用redis"></a>1、为什么使用redis</h1><p><strong>分析</strong>:博主觉得在项目中使用redis，主要是从两个角度去考虑:<strong>性能</strong>和<strong>并发</strong>。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。因此，这个问题主要从性能和并发两个角度去答。<br><strong>回答</strong>:如下所示，分为两点</p>
<h2 id="（一）性能"><a href="#（一）性能" class="headerlink" title="（一）性能"></a>（一）性能</h2><p>如下图所示，我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够<strong>迅速响应</strong>。<br><img src="https://s2.ax1x.com/2019/10/09/uopDIO.png" alt="uopDIO.png"><br><strong>题外话：</strong>忽然想聊一下这个<strong>迅速响应</strong>的标准。其实根据交互效果的不同，这个响应时间没有固定标准。不过曾经有人这么告诉我:”在理想状态下，我们的页面跳转需要在<strong>瞬间</strong>解决，对于页内操作则需要在<strong>刹那</strong>间解决。另外，超过<strong>一弹指</strong>的耗时操作要有进度提示，并且可以随时中止或取消，这样才能给用户最好的体验。”<br>那么<strong>瞬间、刹那、一弹指</strong>具体是多少时间呢？<br>根据《摩诃僧祗律》记载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一刹那者为一念，二十念为一瞬，二十瞬为一弹指，二十弹指为一罗预，二十罗预为一须臾，一日一夜有三十须臾。</span><br></pre></td></tr></table></figure>

<p>那么，经过周密的计算，一<strong>瞬间</strong>为0.36 秒,一<strong>刹那</strong>有 0.018 秒.一<strong>弹指</strong>长达 7.2 秒。</p>
<h2 id="（二）并发"><a href="#（二）并发" class="headerlink" title="（二）并发"></a>（二）并发</h2><p>如下图所示，在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。<br><img src="https://s2.ax1x.com/2019/10/09/uopBdK.png" alt="uopBdK.png"></p>
<h1 id="2、使用redis有什么缺点"><a href="#2、使用redis有什么缺点" class="headerlink" title="2、使用redis有什么缺点"></a>2、使用redis有什么缺点</h1><p><strong>分析</strong>:大家用redis这么久，这个问题是必须要了解的，基本上使用redis都会碰到一些问题，常见的也就几个。<br><strong>回答</strong>:主要是四个问题：</p>
<ol>
<li>缓存和数据库双写一致性问题</li>
<li>缓存雪崩问题</li>
<li>缓存击穿问题</li>
<li>缓存的并发竞争问题</li>
</ol>
<p>这四个问题，我个人是觉得在项目中，比较常遇见的，具体解决方案，后文给出。</p>
<h1 id="3、单线程的redis为什么这么快"><a href="#3、单线程的redis为什么这么快" class="headerlink" title="3、单线程的redis为什么这么快"></a>3、单线程的redis为什么这么快</h1><p><strong>分析</strong>:这个问题其实是对redis内部机制的一个考察。其实根据博主的面试经验，很多人其实都不知道redis是单线程工作模型。所以，这个问题还是应该要复习一下的。<br><strong>回答</strong>:主要是以下三点：</p>
<ol>
<li>纯内存操作</li>
<li>单线程操作，避免了频繁的上下文切换</li>
<li>采用了非阻塞<strong>I/O多路复用机制</strong></li>
</ol>
<h2 id="题外话：I-O多路复用机制"><a href="#题外话：I-O多路复用机制" class="headerlink" title="题外话：I/O多路复用机制"></a><font color=red>题外话：I/O多路复用机制</font></h2><p>我们现在要仔细的说一说I/O多路复用机制，因为这个说法实在是太通俗了，通俗到一般人都不懂是什么意思。博主打一个比方：小曲在S城开了一家快递店，负责同城快送服务。小曲因为资金限制，雇佣了<strong>一批</strong>快递员，然后小曲发现资金不够了，只够买<strong>一辆</strong>车送快递。<br><strong>经营方式一</strong><br>客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。慢慢的小曲就发现了这种经营方式存在下述问题</p>
<ul>
<li>几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递</li>
<li>随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了</li>
<li>快递员之间的协调很花时间</li>
</ul>
<p>综合上述缺点，小曲痛定思痛，提出了下面的经营方式<br><strong>经营方式二</strong><br>小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按<strong>送达地点</strong>标注好，然后<strong>依次</strong>放在一个地方。最后，那个快递员<strong>依次</strong>的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。</p>
<p><strong>对比：</strong><br>上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢。在上述比喻中:</p>
<ul>
<li>每个快递员——————&gt;每个线程</li>
<li>每个快递——————–&gt;每个socket(I/O流)</li>
<li>快递的送达地点————–&gt;socket的不同状态</li>
<li>客户送快递请求————–&gt;来自客户端的请求</li>
<li>小曲的经营方式————–&gt;服务端运行的代码</li>
<li>一辆车———————-&gt;CPU的核数</li>
</ul>
<p>于是我们有如下结论：</p>
<ol>
<li>经营方式一就是传统的并发模型，每个I/O流(快递)都有一个新的线程(快递员)管理。</li>
<li>经营方式二就是I/O多路复用。只有单个线程(一个快递员)，通过跟踪每个I/O流的状态(每个快递的送达地点)，来管理多个I/O流。</li>
</ol>
<p>下面类比到真实的redis线程模型，如图所示<br><img src="https://s2.ax1x.com/2019/10/09/uopsiD.png" alt="uopsiD.png"><br>参照上图，简单来说，就是。我们的redis-client在操作的时候，会产生具有不同事件类型的socket。在服务端，有一段I/0多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。<br>需要说明的是，这个I/O多路复用机制，redis还提供了select、epoll、evport、kqueue等多路复用函数库，大家可以自行去了解。</p>
<h1 id="4、redis的数据类型，以及每种数据类型的使用场景"><a href="#4、redis的数据类型，以及每种数据类型的使用场景" class="headerlink" title="4、redis的数据类型，以及每种数据类型的使用场景"></a>4、redis的数据类型，以及每种数据类型的使用场景</h1><p><strong>分析</strong>：是不是觉得这个问题很基础，其实我也这么觉得。然而根据面试经验发现，至少百分八十的人答不上这个问题。建议，在项目中用到后，再类比记忆，体会更深，不要硬记。基本上，一个合格的程序员，五种类型都会用到。<br><strong>回答</strong>：一共五种</p>
<h2 id="一-String"><a href="#一-String" class="headerlink" title="(一)String"></a>(一)String</h2><p>这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做<font color=red><strong>一些复杂的计数功能的缓存。</strong></font></p>
<h2 id="二-hash"><a href="#二-hash" class="headerlink" title="(二)hash"></a>(二)hash</h2><p>这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做<font color=red><strong>单点登录</strong></font>的时候，就是用这种数据结构存储用户信息，<strong><u>以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。</u></strong></p>
<h2 id="三-list"><a href="#三-list" class="headerlink" title="(三)list"></a>(三)list</h2><p>使用List的数据结构，可以<font color=red><strong>做简单的消息队列的功能</strong></font>。另外还有一个就是，可以利用<strong>lrange</strong>命令，<font color=red><strong>做基于redis的分页功能</strong></font>，性能极佳，用户体验好。</p>
<h2 id="四-set"><a href="#四-set" class="headerlink" title="(四)set"></a>(四)set</h2><p>因为set堆放的是一堆不重复值的集合。所以可以做<font color=red><strong>全局去重的功能</strong></font>。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。<br>另外，就是利用<strong><u>交集、并集、差集</u></strong>等操作，可以<font color=red><strong>计算共同喜好，全部的喜好，自己独有的喜好等功能</strong></font>。</p>
<h2 id="五-sorted-set"><a href="#五-sorted-set" class="headerlink" title="(五)sorted set"></a>(五)sorted set</h2><p>sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做<font color=red><strong>排行榜应用，取TOP N操作</strong></font>。另外，参照另一篇<a href="https://www.cnblogs.com/rjzheng/p/8972725.html" target="_blank" rel="noopener">《分布式之延时任务方案解析》</a>，该文指出了sorted set可以用来做<font color=red><strong>延时任务</strong></font>。最后一个应用就是可以做<font color=red><strong>范围查找</strong></font>。</p>
<h1 id="5、redis的过期策略以及内存淘汰机制"><a href="#5、redis的过期策略以及内存淘汰机制" class="headerlink" title="5、redis的过期策略以及内存淘汰机制"></a>5、redis的过期策略以及内存淘汰机制</h1><p><strong>分析</strong>:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?<br><strong>回答</strong>:<br>redis采用的是<strong>定期删除+惰性删除</strong>策略。<br><strong>为什么不用定时删除策略?</strong><br>定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略。<br><strong>定期删除+惰性删除是如何工作的呢?</strong><br>定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。<br>于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。<br><strong>采用定期删除+惰性删除就没其他问题了么?</strong><br>不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<strong>内存淘汰机制</strong>。<br>在redis.conf中有一行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># maxmemory-policy volatile-lru</span><br></pre></td></tr></table></figure>

<p>该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)</p>
<ol>
<li>noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。<strong>应该没人用吧。</strong></li>
<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。<strong>推荐使用，目前项目在用这种。</strong></li>
<li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。<strong>应该也没人用吧，你不删最少使用Key,去随机删。</strong></li>
<li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。<strong>这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐</strong></li>
<li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。<strong>依然不推荐</strong></li>
<li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。<strong>不推荐</strong></li>
</ol>
<p><u>ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。</u></p>
<h1 id="6、redis和数据库双写一致性问题"><a href="#6、redis和数据库双写一致性问题" class="headerlink" title="6、redis和数据库双写一致性问题"></a>6、redis和数据库双写一致性问题</h1><p><strong>分析</strong>:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。<strong><u>就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</u></strong></p>
<p><strong>回答</strong>:<a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">《分布式之数据库和缓存双写一致性方案解析》</a>给出了详细的分析，在这里简单的说一说。<font color=red><strong><u>首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</u></strong></font></p>
<h1 id="7、如何应对缓存穿透和缓存雪崩问题"><a href="#7、如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="7、如何应对缓存穿透和缓存雪崩问题"></a>7、如何应对缓存穿透和缓存雪崩问题</h1><p><strong>分析</strong>:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。<br><strong>回答</strong>:如下所示<br><strong>缓存穿透：</strong>即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。<br><strong><font color=red>解决方案：</font></strong></p>
<ol>
<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。</li>
<li>采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做<strong>缓存预热</strong>(项目启动前，先加载缓存)操作。</li>
<li>提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。</li>
</ol>
<p><strong>缓存雪崩：</strong>即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。<br><font color=red><strong>解决方案：</strong></font></p>
<ol>
<li>给缓存的失效时间，加上一个随机值，避免集体失效。</li>
<li>使用互斥锁，但是该方案吞吐量明显下降了。</li>
<li>双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做<strong>缓存预热</strong>操作。然后细分以下几个小点：<ul>
<li>从缓存A读数据库，有则直接返回。</li>
<li>A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。</li>
<li>更新线程同时更新缓存A和缓存B。</li>
</ul>
</li>
</ol>
<h1 id="8、如何解决redis的并发竞争key问题"><a href="#8、如何解决redis的并发竞争key问题" class="headerlink" title="8、如何解决redis的并发竞争key问题"></a>8、如何解决redis的并发竞争key问题</h1><p><strong>分析</strong>:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主<strong>不推荐使用redis的事务机制。</strong>因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，<strong>redis的事务机制，十分鸡肋。</strong><br><strong>回答:</strong>如下所示<br>(1)如果对这个key操作，<strong>不要求顺序</strong><br>这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>(2)如果对这个key操作，<strong>要求顺序</strong><br>假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC。希望key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">系统A key 1 &#123;valueA  3:00&#125;</span><br><span class="line">系统B key 1 &#123;valueB  3:05&#125;</span><br><span class="line">系统C key 1 &#123;valueC  3:10&#125;</span><br></pre></td></tr></table></figure>

<p>那么，假设这会儿系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。</p>
<p>其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>补码(为什么按位取反再加一)</title>
    <url>/2020/03/15/(%E8%BD%AC)%E8%A1%A5%E7%A0%81(%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D%E5%86%8D%E5%8A%A0%E4%B8%80)/</url>
    <content><![CDATA[<p>首先，阅读这篇文章的你，肯定是一个在网上已经纠结了很久的读者，因为你查阅了所有你能查到的资料，然后他们都会很耐心的告诉你，补码：就是按位取反，然后加一。准确无误，毫无破绽。但是，你搜遍了所有俯拾即是而且准确无误的答案，却仍然选择来看这篇毫不起眼的文章，原因只有一个，只因为你还没有得到你想要的东西。<a id="more"></a></p>
<p> 因为你想要的，不是1+1=2，而是，1+1为什么等于2。当然，我们不讨论1+1的问题。我们讨论的，是补码。</p>
<p> 你已经困惑了很久，你明明知道补码就是按位取反，然后加一，但是你想知道的，不是它怎么求滴，而是，它怎来滴。当然，对于阅读这篇文章的你，既然想要知道这个答案，一定是有一定编程基础的读者，肯定知道补码与有符号数与无符号数的关系（有符号数指带有正负号的数，无符号可以理解为只大于0的数），你所查阅的所有资料首先都会用一个8位的二进制数给你举例，ok，我们也用一个8位的二进制数。</p>
<p> 8位二进制数，最小00000000，最大数11111111，换算十进制为0<del>255，当然，所有的参考资料都会这样讲，而且这也不是你想要的，但我们必须说下去。1</del>255，一共255的字符，再加上最前面的0，一共256个字符。现在，我们要用一个8位二进制数字来表示一个负数，可是二进制里没有负号，谁都知道二进制里只有0,1，再无其他符号。那么所以我们必须用一种方式来代替正负，也就是我们规定，当然是人规定的，而不是电脑，我们规定这个8位的二进制数的最前面一位数来表示这个数的正负，0代表是正，1代表是负。那么当第一位是0时，我们一共可以表示00000000<del>01111111这么多正数，因为第一位必须是0来代表正数；当第一位是1时，我们一共可以表示10000000</del>11111111这么多负数，然后，我们用00000000<del>01111111来代表0</del>127，那岂不是10000000~11111111代表  -0  ~  -127？？可是网上都说不能有 负0，可是我觉的没什么不妥啊，负0不还是0 吗？10-0=10，不就是相当于10+（-0）=10吗，现在我们不讨论正负0的问题，我们来讨论一个小学生的问题。</p>
<p> 我们现在要把00000000~11111111分成两组数，一组是正数，另一组是负数，正数是0,1,2,3,4,5,6,7,8，… 负数是 -1，-2，-3，-4，-5，-6，-7，-8，… 那么这里就有一个小学问题，那就是1+（-1）肯定要等于0，2+（-2）=0，他们是相反数，相加等于0，小学生都会。后面都是一样，那么现在我们使用上面的编码的方式进行一个计算，现在上面的编码中 1 对应的二进制是00000001，-1对应的二进制是10000001，然后你把这俩二进制数加起来，看看等于几，对，答案是10000010，不是00000000，也不是10000000,  10000010在上面的编码中代表 -2，00000000和10000000都在上面代表0，可是结果并不是他们。而00000001与10000001分别对应着1和-1，加起来理论的结果应该是0才对，也就是说上面的编码是错误的。</p>
<p> 或许接下来很多资料又讨论了反码，但是我们不，我们来求一个一元一次函数，一个小学的函数，1+x=0,求x=？,答：-1。没错，而且准确无误。那么现在问题来了，前面的正数编码应该是没有错的，00000000代表0,  00000001代表1，这些都符合我们的习惯，那么出错的是在后面的负数编码上，我们到底该如何编码对应负数编码它才能正确呢，因为我们知道1+（-1）必须等于0，也就是他们对应的二进制相加也必须等于0，1对应00000001，那么00000001+x=00000000，里面的x就应该代替 -1的二进制编码才对，这样，我们得到 x=11111111，大家看一下这和按位取反，然后加一的结果一样吗。</p>
<p>所以我们的结论是，一个正数对应的负数（也就是俩相反数），这两个数的二进制编码加起来必须等于0才对，所以我们只要知道其中一个数的编码x，然后用0-x就是他对应的数的编码，这样的话，从0<del>127，我们用（0 - 其中一个二进制数的编码）=（另一个二进制数的编码），例如 2 的二进制编码是00000010，那么-2 的二进制编码就是0 - 00000010=11111110，因为他就应该这样，因为它就是一个小学问题，他俩加起来就应该等于0。那么1000000对应的编码是多少呢，当然也必须满足加起来等于0才行，那么10000000+x=0，求解x，答x=10000000，还是它本身，也就是在00000000</del>11111111这个范围里所有的二进制数都无法满足它，也就是没有一个数加上它等于0，但是两个数要有对应的编码，就必须加起来等于0才行，其实不止它没有，0也没有，0+x=0，那么x=0，也是它本身，既然这样了，那么也没有办法了，无可奈何只能做单身汉了，然后我们规定，既然10000000第一位是1，代表负数，那么我们规定它是一个负数，那么10000000就代替了-128，而且，它只自己一个人，也就是只有-128，没有正数128。</p>
<p> 然后，他们每个数都有了自己对应的编码，而且准确无误。1<del>127对应-1</del> -127，再加上两个单身汉0和-128。然后呢，不知道谁起的名字，就把这种编码叫做了补码，如果你乐意，你也可以给它起个名字。但是呢，还有一个问题，为什么补码的求法是按位取反再加一呢，其实当你不明白为什么各大书籍都要用按位取反来计算补码的时候，我们完全可以直接用0减去它就得到他相反数的二进制编码了，譬如随便一个十六进制数 6C ，那么我们可以直接0-6C就得到他的相反数的补码了，结果为十六进制的94，跟按位取反再加一的效果一样。</p>
<p> 现在我们知道补码是怎么来的了，也就是为了保证两个相反数对应二进制的和必须是0，然后又不知道谁给它起了补码这个名字。补码补码，有没有感觉两个相反数是互补的呢，也就是任意两个相反数加起来一定等0，其中一个数变大，另一个就一定会变小互补保证结果为0。但是你肯定还在纠结，为啥要按位取反，为啥还要加一呢。其实，这涉及到一个二进制减法的问题，你既然知道补码这个概念，就一定会知道有进位丢失这么个东西。现在我们知道了补码是怎么来的，也就是（00000000 - 其中一个正数的补码）=（这个数相反数的补码），那么我们知道了1的二进制是00000001，那么我们来求-1的补码，也就是应该00000000 - 00000001=？，我们该怎么计算这个二进制减法呢，而且还是一个小数减去大数，连借位都没地方借，前面我们提到进位丢失这个东西，那么我们来计算一个算式，11111111+00000001=？知道进位丢失的你，肯定知道加起来后等于00000000，虽然结果应该是100000000（后面是8个0），但是只能有8位，所以最高位的1丢失了，那么现在好了，也就是说，我们可以把00000000看做（11111111+00000001）因为他俩是相等的，我们已经计算过的了，那么我们现在就可以把前面讲的公式中的00000000换成（11111111+00000001），也就是我们要计算-1的补码，我们就0-1的编码，也就是00000000-00000001，也就是（11111111+00000001）-00000001=(-1的补码)，这个算式我觉的你应该会计算了，大数减小数，到现在，或许你现在已经发现什么了，是的，你发现了之前一直迷惑你的一个东西，“按位取反再加一”，但是可能还有一点迷惑，我们继续，因为我们每次都是用一个0减去一个数的补码来得到另一个数的补码，也就是里面的（11111111+00000001）是不变的，因为它就是0，那么我们现在要求一个数的补码，就是（11111111+00000001）- 一个数的补码=它相反数的补码，咱们把括号去掉，也就是11111111 - 一个数的补码+00000001=它相反数的补码，这是加法交换法则，只是把位置交换一下，小学生都会的，然后呢再加个括号方便我们理解，也就是（1111111 - 一个数的补码）+00000001=它相反数的补码。好了，问题来了，（11111111 - 一个数的补码）的结果是什么，这个你心里应该是清楚的，你也可以算一下，它正好的等于它的反码，也就是按位取反的一个数，其实也好理解，你减几个数就看见规律了，描述好麻烦，现在好了，也就是（11111111 - 一个数的补码）=这个数的反码，也就是（11111111 - 一个数的补码）=把这个数按位取反，到现在，你应该你已经很清楚他是怎么来的了。</p>
<p>那么我们现在就可以把公式写成这样，（11111111 - 一个数的补码）+00000001=它相反数的补码，现在我们知道了（11111111 - 一个数的补码）=把这个数按位取反，然后把公式里的（11111111 - 一个数的补码）换成 “按位取反”，也就是 （按位取反）+000000001=它相反数的补码，现在，按位取反，再加一，就终于出来了，这就是各大书籍资料所讲的，补码=按位取反+1..。好了，真相大白！！！</p>
<p>本文章属个人领悟，错误必有，不吝赐教</p>
<hr>
<p>版权声明：本文为CSDN博主「wenxinwukui234」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/wenxinwukui234/article/details/42119265" target="_blank" rel="noopener">https://blog.csdn.net/wenxinwukui234/article/details/42119265</a></p>
]]></content>
      <categories>
        <category>Mark</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装Docker</title>
    <url>/2020/03/15/CentOS%207%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h2 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h2><p><strong>CentOS-7-x86_64-Everything-1908</strong>  下载地址：<a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/" target="_blank" rel="noopener">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a></p>
<p><strong>Vmware 15.1.0</strong> 下载地址：<a href="https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe" target="_blank" rel="noopener">https://download3.vmware.com/software/wkst/file/VMware-workstation-full-15.1.0-13591040.exe</a>       ( win10 1903版本之后，要使用15+版本，不然主系统向虚拟机拖拽文件时经常会卡死）<a id="more"></a></p>
<p>博文记录时的Docker版本：<strong>Docker v19.03</strong></p>
<p>可以参考官方文档安装：<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/centos/</a></p>
<h2 id="话不多说开始安装："><a href="#话不多说开始安装：" class="headerlink" title="话不多说开始安装："></a>话不多说开始安装：</h2><p>安装过程中最好要保证虚拟机一直可以访问外网！！！</p>
<ul>
<li><p>安装一下gcc：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum -y install gcc</span><br><span class="line">$ yum -y install gcc-c++</span><br></pre></td></tr></table></figure>

<p> <img src="https://s2.ax1x.com/2019/11/27/Q9XP1g.png" alt="Q9XP1g.png"></p>
</li>
<li><p>如果之前安装过docker，卸载旧版本docker，不知道之前有没有docker也可以执行一下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p> <img src="https://s2.ax1x.com/2019/11/27/Q9Xd3D.png" alt="Q9Xd3D.png"></p>
<p> 说明我之前没有安装过docker。</p>
</li>
<li><p>安装软件包：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置stable镜像仓库：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>

<p> <font color=red>上述命令是官方提供了，但是由于一些不可抗拒因素，导致我们不能很好地访问Docker提供的这个官方链接，所以经常产生Timeout或者TCP connection reset by peer的错误。所以我们可以使用下面的加速地址指令。</font></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure>

<p> <a href="https://imgchr.com/i/Q9zCan" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/27/Q9zCan.md.png" alt="Q9zCan.md.png"></a></p>
<p> 设置成功。</p>
</li>
<li><p>更新一下yum索引，以后下载东西会快点：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum makecache fast</span><br></pre></td></tr></table></figure>

<p> <a href="https://imgchr.com/i/Q9zMI1" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/27/Q9zMI1.md.png" alt="Q9zMI1.md.png"></a></p>
<p> 更新成功。</p>
</li>
<li><p>安装Docker:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum -y install docker-ce</span><br></pre></td></tr></table></figure>

<p> <a href="https://imgchr.com/i/QCSH9P" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2019/11/27/QCSH9P.md.png" alt="QCSH9P.md.png"></a></p>
<p> 安装完成。</p>
</li>
<li><p>启动Docker，测试一下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl start docker</span><br><span class="line">$ docker run hello-world</span><br><span class="line">$ docker images</span><br></pre></td></tr></table></figure>

<p> <img src="https://s2.ax1x.com/2019/11/27/QC9Cad.png" alt="QC9Cad.png"></p>
<p> 一切正常。</p>
</li>
<li><p>配置镜像加速，然后重新加载配置文件（  演示中使用网易云镜像地址：{“registry-mirrors”: [“<a href="http://hub-mirror.c.163.com&quot;]">http://hub-mirror.c.163.com&quot;]</a> }  ），重启Docker：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">$ vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">$ systemctl daemon-reload</span><br><span class="line">$ systemctl restart docker</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><img src="https://s2.ax1x.com/2019/11/27/QC9Wod.png" alt="QC9Wod.png"></p>
<p><font color=red>这里保存退出时一定要用“wq!”，不要用“wq”，不然重启docker时会出问题。</font></p>
<p>可以用以下命令查看一下docker是否安装完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ef|grep docker|grep -v grep </span><br><span class="line">$ docker version</span><br></pre></td></tr></table></figure>

<hr>
<p>完成上述步骤，Docker就基本算是安装完成可以开始学习使用了。</p>
]]></content>
      <categories>
        <category>工具环境</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA中Tomcat在控制台乱码问题以及IDEA编码设置UTF-8</title>
    <url>/2020/03/15/IDEA%E7%BC%96%E8%BE%91%E5%99%A8%E5%92%8CTomcat%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%97%A5%E5%BF%97%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<p>初次使用IDEA（IDEA2019.1 x64）布局和快捷键等等都还不适应，比较痛苦。<a id="more"></a></p>
<p>忘记设置编码方式导致<strong>代码中的中文错乱</strong>，但是解决起来还是很容易的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setting→Editor→FileEncodings</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2019/08/17/mKNwfx.md.png" alt="FileEncodings"></p>
<p>紧接住发现<strong>Tomcat</strong>运行时<strong>控制台相关日志的中文</strong>也错乱了，百度解决方案后解决：</p>
<p><img src="https://s2.ax1x.com/2019/08/17/mKNakR.md.png" alt="Tomcat运行时控制台相关日志的中文也错乱"></p>
<p>然后配置tomcat的编码问题：</p>
<p>Run/DeBug Configurations中</p>
<p>在VM options填写-Dfile.encoding=UTF-8：</p>
<p><img src="https://s2.ax1x.com/2019/08/17/mKNdt1.md.png" alt="在VM options填写-Dfile.encoding=UTF-8："></p>
<p>但是此时依然没有解决问题，继续。。。</p>
<p><strong>打开idea安装目录-bin</strong></p>
<p>用记事本打开<strong>idea.exe.vmoptions</strong>和<strong>idea64.exe.vmoptions</strong>文件</p>
<p><img src="https://s2.ax1x.com/2019/08/18/mKDmvt.png" alt="mKDmvt.png"></p>
<p>分别在文件的最后一行写入：<strong>-Dfile.encoding=UTF-8</strong> </p>
<p><img src="https://s2.ax1x.com/2019/08/17/mKNN79.png" alt="mKNN79.png"></p>
<p> 保存文件，重启IDEA，问题解决！</p>
]]></content>
      <categories>
        <category>工具环境</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8特性(一)</title>
    <url>/2020/03/15/Java8%E7%89%B9%E6%80%A7(%E4%B8%80)/</url>
    <content><![CDATA[<p>默认方法&amp;Lambda表达式&amp;函数式接口&amp;方法引用<a id="more"></a></p>
<p>Java8的重要特性之四：默认方法、函数式接口、Lambda表达式和方法引用，之所以将这四个特性拿出来一起记录学习，因为其作用都是为了在接口定义时或者实现时进一步优化编程体验。其中Lambda表达式和方法引用可以看做是匿名内部类的进一步的抽象，合理的使用这些特性可以使编程更加高效，代码更加简洁清晰。</p>
<h2 id="默认方法："><a href="#默认方法：" class="headerlink" title="默认方法："></a>默认方法：</h2><p>Java的接口用起来很方便，使编程更加易于规范化、格式化，但是也存在一些问题：当修改接口的方法时，所有实现该接口的类都要进行修改，这是很糟糕的体验。于是Java8中引入了默认方法，可以使接口中存在非抽象方法，目的是为了解决接口的修改与现有的实现类不兼容的问题。</p>
<p>关键字：<strong>default</strong></p>
<p>默认语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm B..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意:</strong></font>当B、C两个接口同时存在同名默认方法show()，并且同时被一个类D实现时会报出编译错误：<strong>D inherits unrelated defaults for show() from B and C</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm C..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方法：</strong>必须在实现类D中重写show()方法进行覆盖。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>,<span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm D..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果希望使用接口中的某个默认方法，可以在重写的方法中使用<strong>接口名.super.方法()</strong>的方式调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>,<span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        B.<span class="keyword">super</span>.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Java8中不但允许接口内实现方法，还允许接口实现<strong>静态方法</strong>并通过<strong>接口名.静态方法</strong>来调用。<font color=red>但是接口的实现类和实现类对象不能直接调用接口的静态方法。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">B</span>,<span class="title">C</span></span>&#123;<span class="comment">//在B接口中加入静态方法static  void hello()&#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	B.<span class="keyword">super</span>.show();</span><br><span class="line">        B.hello();</span><br><span class="line">        C.<span class="keyword">super</span>.show();</span><br><span class="line">        System.out.println(<span class="string">"I'm D..."</span>);</span><br><span class="line">    &#125;<span class="comment">//运行结果： I'm B...</span></span><br><span class="line">&#125;	<span class="comment">//			HelloWorld!</span></span><br><span class="line">	<span class="comment">//			I'm C... </span></span><br><span class="line">	<span class="comment">//			I'm D...</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Lambda表达式："><a href="#Lambda表达式：" class="headerlink" title="Lambda表达式："></a>Lambda表达式：</h2><p>基本语法：(params) -&gt; expression;   或者 (params) -&gt; {expression; expression；…};</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Runnable()&#123;<span class="comment">//匿名内部类实现</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"run..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.run();</span><br><span class="line">		<span class="comment">//改用Lambda表达式</span></span><br><span class="line">        Runnable runnable = ()-&gt; System.out.println(<span class="string">"run..."</span>);</span><br><span class="line">        runnable.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] atp = &#123;<span class="string">"Rafael Nadal"</span>, <span class="string">"Novak Djokovic"</span>,</span><br><span class="line">                <span class="string">"Stanislas Wawrinka"</span>,</span><br><span class="line">                <span class="string">"David Ferrer"</span>,<span class="string">"Roger Federer"</span>,</span><br><span class="line">                <span class="string">"Andy Murray"</span>,<span class="string">"Tomas Berdych"</span>,</span><br><span class="line">                <span class="string">"Juan Martin Del Potro"</span>&#125;;</span><br><span class="line">        List&lt;String&gt; players =  Arrays.asList(atp);</span><br><span class="line">        <span class="comment">//Java5的增强for</span></span><br><span class="line">        <span class="keyword">for</span> (String player : players) &#123;</span><br><span class="line">            System.out.println(player);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Java8的Lambda表达式</span></span><br><span class="line">        players.forEach((player)-&gt; System.out.println(player));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>Lambda表达式只支持<strong>函数式接口</strong>，也就是只有<strong>一个抽象方法</strong>但可以有<strong>多个default方法</strong>的接口。</li>
<li>-&gt;Lambda运算符，左边是<strong>参数</strong>列表，右边是需要执行的<strong>表达式</strong>语句。</li>
<li>当且仅当只有<strong>一个</strong>参数时可以<strong>省略()</strong>，当且仅当只有<strong>一条语句</strong>可以<strong>省略{}和return</strong>。</li>
<li>参数的<strong>类型</strong>可以<strong>不写</strong>，Javac编译时会根据上下文推断出参数的类型，即“类型推断”。</li>
<li>当有多个参数和多条语句时：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator =<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"函数式接口..."</span>);</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">//Lambda表达式</span></span><br><span class="line">        Comparator&lt;Integer&gt; comparator1 = (x,y) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"函数式接口..."</span>);</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数式接口："><a href="#函数式接口：" class="headerlink" title="函数式接口："></a>函数式接口：</h2><p><u>函数式接口：有且仅有只有一个抽象方法，但可以有多个非抽象方法的接口。</u></p>
<p>函数式接口可以被隐式的转换为Lambda表达式，并对现有的函数非常友好的支持Lambda表达式。</p>
<p><strong>JDK 1.8 之前已有的函数式接口:</strong></p>
<blockquote>
<ul>
<li>java.lang.Runnable</li>
<li>java.util.concurrent.Callable</li>
<li>java.security.PrivilegedAction</li>
<li>java.util.Comparator</li>
<li>java.io.FileFilter</li>
<li>java.nio.file.PathMatcher</li>
<li>java.lang.reflect.InvocationHandler</li>
<li>java.beans.PropertyChangeListener</li>
<li>java.awt.event.ActionListener</li>
<li>javax.swing.event.ChangeListener</li>
</ul>
</blockquote>
<p><strong>JDK 1.8 新增加的函数接口：</strong></p>
<blockquote>
<ul>
<li>java.util.function</li>
</ul>
</blockquote>
<p>java.util.function包中有很多接口，用来支持函数式编程：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>BiConsumer&lt;T,U&gt;</strong></td>
<td>代表了一个接受两个输入参数的操作，并且不返回任何结果</td>
</tr>
<tr>
<td>2</td>
<td><strong>BiFunction&lt;T,U,R&gt;</strong></td>
<td>代表了一个接受两个输入参数的方法，并且返回一个结果</td>
</tr>
<tr>
<td>3</td>
<td><strong>BinaryOperator<T></strong></td>
<td>代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果</td>
</tr>
<tr>
<td>4</td>
<td><strong>BiPredicate&lt;T,U&gt;</strong></td>
<td>代表了一个两个参数的boolean值方法</td>
</tr>
<tr>
<td>5</td>
<td><strong>BooleanSupplier</strong></td>
<td>代表了boolean值结果的提供方</td>
</tr>
<tr>
<td>6</td>
<td><strong>Consumer<T></strong></td>
<td>代表了接受一个输入参数并且无返回的操作</td>
</tr>
<tr>
<td>7</td>
<td><strong>DoubleBinaryOperator</strong></td>
<td>代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。</td>
</tr>
<tr>
<td>8</td>
<td><strong>DoubleConsumer</strong></td>
<td>代表一个接受double值参数的操作，并且不返回结果。</td>
</tr>
<tr>
<td>9</td>
<td><strong>DoubleFunction<R></strong></td>
<td>代表接受一个double值参数的方法，并且返回结果</td>
</tr>
<tr>
<td>10</td>
<td><strong>DoublePredicate</strong></td>
<td>代表一个拥有double值参数的boolean值方法</td>
</tr>
<tr>
<td>11</td>
<td><strong>DoubleSupplier</strong></td>
<td>代表一个double值结构的提供方</td>
</tr>
<tr>
<td>12</td>
<td><strong>DoubleToIntFunction</strong></td>
<td>接受一个double类型输入，返回一个int类型结果。</td>
</tr>
<tr>
<td>13</td>
<td><strong>DoubleToLongFunction</strong></td>
<td>接受一个double类型输入，返回一个long类型结果</td>
</tr>
<tr>
<td>14</td>
<td><strong>DoubleUnaryOperator</strong></td>
<td>接受一个参数同为类型double,返回值类型也为double 。</td>
</tr>
<tr>
<td>15</td>
<td><strong>Function&lt;T,R&gt;</strong></td>
<td>接受一个输入参数，返回一个结果。</td>
</tr>
<tr>
<td>16</td>
<td><strong>IntBinaryOperator</strong></td>
<td>接受两个参数同为类型int,返回值类型也为int 。</td>
</tr>
<tr>
<td>17</td>
<td><strong>IntConsumer</strong></td>
<td>接受一个int类型的输入参数，无返回值 。</td>
</tr>
<tr>
<td>18</td>
<td><strong>IntFunction<R></strong></td>
<td>接受一个int类型输入参数，返回一个结果 。</td>
</tr>
<tr>
<td>19</td>
<td><strong>IntPredicate</strong></td>
<td>接受一个int输入参数，返回一个布尔值的结果。</td>
</tr>
<tr>
<td>20</td>
<td><strong>IntSupplier</strong></td>
<td>无参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>21</td>
<td><strong>IntToDoubleFunction</strong></td>
<td>接受一个int类型输入，返回一个double类型结果 。</td>
</tr>
<tr>
<td>22</td>
<td><strong>IntToLongFunction</strong></td>
<td>接受一个int类型输入，返回一个long类型结果。</td>
</tr>
<tr>
<td>23</td>
<td><strong>IntUnaryOperator</strong></td>
<td>接受一个参数同为类型int,返回值类型也为int 。</td>
</tr>
<tr>
<td>24</td>
<td><strong>LongBinaryOperator</strong></td>
<td>接受两个参数同为类型long,返回值类型也为long。</td>
</tr>
<tr>
<td>25</td>
<td><strong>LongConsumer</strong></td>
<td>接受一个long类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>26</td>
<td><strong>LongFunction<R></strong></td>
<td>接受一个long类型输入参数，返回一个结果。</td>
</tr>
<tr>
<td>27</td>
<td><strong>LongPredicate</strong></td>
<td>R接受一个long输入参数，返回一个布尔值类型结果。</td>
</tr>
<tr>
<td>28</td>
<td><strong>LongSupplier</strong></td>
<td>无参数，返回一个结果long类型的值。</td>
</tr>
<tr>
<td>29</td>
<td><strong>LongToDoubleFunction</strong></td>
<td>接受一个long类型输入，返回一个double类型结果。</td>
</tr>
<tr>
<td>30</td>
<td><strong>LongToIntFunction</strong></td>
<td>接受一个long类型输入，返回一个int类型结果。</td>
</tr>
<tr>
<td>31</td>
<td><strong>LongUnaryOperator</strong></td>
<td>接受一个参数同为类型long,返回值类型也为long。</td>
</tr>
<tr>
<td>32</td>
<td><strong>ObjDoubleConsumer<T></strong></td>
<td>接受一个object类型和一个double类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>33</td>
<td><strong>ObjIntConsumer<T></strong></td>
<td>接受一个object类型和一个int类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>34</td>
<td><strong>ObjLongConsumer<T></strong></td>
<td>接受一个object类型和一个long类型的输入参数，无返回值。</td>
</tr>
<tr>
<td>35</td>
<td><strong>Predicate<T></strong></td>
<td>接受一个输入参数，返回一个布尔值结果。</td>
</tr>
<tr>
<td>36</td>
<td><strong>Supplier<T></strong></td>
<td>无参数，返回一个结果。</td>
</tr>
<tr>
<td>37</td>
<td><strong>ToDoubleBiFunction&lt;T,U&gt;</strong></td>
<td>接受两个输入参数，返回一个double类型结果</td>
</tr>
<tr>
<td>38</td>
<td><strong>ToDoubleFunction<T></strong></td>
<td>接受一个输入参数，返回一个double类型结果</td>
</tr>
<tr>
<td>39</td>
<td><strong>ToIntBiFunction&lt;T,U&gt;</strong></td>
<td>接受两个输入参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>40</td>
<td><strong>ToIntFunction<T></strong></td>
<td>接受一个输入参数，返回一个int类型结果。</td>
</tr>
<tr>
<td>41</td>
<td><strong>ToLongBiFunction&lt;T,U&gt;</strong></td>
<td>接受两个输入参数，返回一个long类型结果。</td>
</tr>
<tr>
<td>42</td>
<td><strong>ToLongFunction<T></strong></td>
<td>接受一个输入参数，返回一个long类型结果。</td>
</tr>
<tr>
<td>43</td>
<td><strong>UnaryOperator<T></strong></td>
<td>接受一个参数为类型T,返回值类型也为T。</td>
</tr>
</tbody></table>
<p>不难发现，提供的这么多的接口摘要出来无非五种：Consumer(消费型)、Supplier(供给型)、Function(函数型)、Predicate(断言型)、Operator(工具型) 。接下来逐一举例介绍：</p>
<h4 id="Consumer-消费型"><a href="#Consumer-消费型" class="headerlink" title="Consumer(消费型):"></a><font color=#00ffff>Consumer(消费型):</font></h4><p>接口方法 <strong>void accept(T t)</strong>：参数类型是T，无返回值 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了精简代码都使用Lambda表达式实现。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//接受一个T类型参数可以泛型指定，无返回值</span></span><br><span class="line">    Consumer&lt;String&gt; Consumer = (name) -&gt; System.out.println(name);</span><br><span class="line">    Consumer.accept(<span class="string">"张三"</span>);</span><br><span class="line">    <span class="comment">//接受T类型、U类型两个参数可以分别用泛型指定，无返回值</span></span><br><span class="line">    BiConsumer&lt;String,Integer&gt; biConsumer = (name,age)-&gt; System.out.println(name+age);</span><br><span class="line">    biConsumer.accept(<span class="string">"zhangsan"</span>,<span class="number">18</span>);</span><br><span class="line">    <span class="comment">//接受Double类型的参数已指定，无返回值</span></span><br><span class="line">    DoubleConsumer doubleConsumer = (money)-&gt; System.out.println(money);</span><br><span class="line">    doubleConsumer.accept(<span class="number">24.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; consumer)</span></span>&#123;</span><br><span class="line">        consumer.accept(money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//就像匿名内部类做参数一样</span></span><br><span class="line">        happy(<span class="number">1000</span>,(e)-&gt; System.out.println(<span class="string">"happy消费了"</span>+ e +<span class="string">"元"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Supplier-供给型"><a href="#Supplier-供给型" class="headerlink" title="Supplier(供给型):"></a><font color=#00ffff>Supplier(供给型):</font></h4><p>接口方法 <strong>T get()</strong>：无参数，有T类型返回值。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无参数，返回String类型返回值，因为只有一条语句所以省略return</span></span><br><span class="line">    Supplier&lt;String&gt; supplier = ()-&gt;<span class="string">"I'm Supplier"</span>;</span><br><span class="line">    System.out.println(supplier.get());</span><br><span class="line">    <span class="comment">//无参数，返回Boolean类型返回值</span></span><br><span class="line">    BooleanSupplier booleanSupplier = ()-&gt;&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">2</span>&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(booleanSupplier.getAsBoolean());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成size大小的ArrayList集合并填充数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">getList</span><span class="params">(<span class="keyword">int</span> size, Supplier&lt;Integer&gt; supplier)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;size ; i++) &#123;</span><br><span class="line">        Integer num = supplier.get();</span><br><span class="line">        list.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = getList(<span class="number">10</span>, ()-&gt;(<span class="keyword">int</span>)(Math.random()*<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Function-函数型"><a href="#Function-函数型" class="headerlink" title="Function(函数型):"></a><font color=#00ffff>Function(函数型):</font></h4><p>接口方法<strong>R apply(T)</strong>：有T类型参数，有R类型返回值 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//有T类型参数，有R类型返回值</span></span><br><span class="line">    Function&lt;String, String&gt; function = (str) -&gt; <span class="string">"I'm "</span> + str;</span><br><span class="line">    System.out.println(function.apply(<span class="string">"Function"</span>));</span><br><span class="line">    <span class="comment">//接受两个参数T、U类型，有R类型返回值</span></span><br><span class="line">    BiFunction&lt;String,String,String&gt; stringStringStringBiFunction = (str1,str2)-&gt;str1+str2;</span><br><span class="line">    System.out.println(stringStringStringBiFunction.apply(<span class="string">"I''m"</span>,<span class="string">"BiFunction"</span>));</span><br><span class="line">    <span class="comment">//接受Long类型参数，返回Double类型值</span></span><br><span class="line">    LongToDoubleFunction longToDoubleFunction = (tlong)-&gt;(<span class="keyword">double</span>) (tlong-<span class="number">10</span>);</span><br><span class="line">    System.out.println(longToDoubleFunction.applyAsDouble(<span class="number">123456789</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String,String&gt; function)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> function.apply(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//去除首尾空格</span></span><br><span class="line">    String s = strHandler(<span class="string">"\t\t123456  789"</span>, (str) -&gt; (str + <span class="string">"-&gt;no blank space  "</span>).trim());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Predicate-断言型"><a href="#Predicate-断言型" class="headerlink" title="Predicate(断言型):"></a><font color=#00ffff>Predicate(断言型):</font></h4><p>接口方法 <strong>boolean test（T t）</strong>：对T类型参数进行条件筛选操作，返回boolean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个Integer类型参数，有boolean类型返回值</span></span><br><span class="line">    Predicate&lt;Integer&gt; predicate =(num)-&gt;num&gt;<span class="number">10</span>;</span><br><span class="line">    System.out.println(predicate.test(<span class="number">11</span>));</span><br><span class="line">    <span class="comment">//两个参数，有boolean类型返回值</span></span><br><span class="line">    BiPredicate&lt;Double,Double&gt; biPredicate = (num1,num2)-&gt;num1&gt;num2;</span><br><span class="line">    System.out.println(biPredicate.test((<span class="keyword">double</span>)<span class="number">12</span>,<span class="number">13.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回满足条件的新集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getNewList</span><span class="params">(List&lt;String&gt; strList, Predicate&lt;String&gt; predicate)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; newlist = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String s : strList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(s))</span><br><span class="line">            newlist.add(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newlist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">"d34"</span>);</span><br><span class="line">    list.add(<span class="string">"d8wq9"</span>);</span><br><span class="line">    list.add(<span class="string">"c9"</span>);</span><br><span class="line">    list.add(<span class="string">"rnglj"</span>);</span><br><span class="line">    <span class="comment">//返回s.length()&gt;3的元素的新集合</span></span><br><span class="line">    List&lt;String&gt; newList = getNewList(list,(s)-&gt;s.length()&gt;<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (String s : newList) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回以9结尾元素的新集合</span></span><br><span class="line">    List&lt;String&gt; newList2 = getNewList(list,(s)-&gt;s.endsWith(<span class="string">"9"</span>));</span><br><span class="line">    <span class="keyword">for</span> (String s : newList2) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="XXXOperator"><a href="#XXXOperator" class="headerlink" title="XXXOperator:"></a><font color=#00ffff>XXXOperator:</font></h4><p>各种XXXOperator接口和Function使用非常类似。。。其中UnaryOperator就是继承了Function&lt;T,T&gt;。</p>
<p>XXXOperator可以看作是Function接口的特殊形式，即参数和返回值类型一致时的Function接口。</p>
<p>举几个例子：</p>
<p>UnaryOperator，就是一个T类型参数，有T类型返回值的情况下的Function&lt;T,T&gt;。</p>
<p>IntUnaryOperator，就是一个Int类型参数，有Int类型返回值情况下的Function&lt;int,int&gt;。</p>
<p>BinaryOperator，就是有两个T类型参数，有T类型返回值的情况下的Function&lt;T,T,T&gt;。</p>
<p>IntBinaryOperator，就是有就是有两个Int类型参数，有Int类型返回值的情况下的Function&lt;Int,Int,Int&gt;。</p>
<p>同理，以此类推。。。</p>
<hr>
<h2 id="方法引用："><a href="#方法引用：" class="headerlink" title="方法引用："></a>方法引用：</h2><p>Lambda表达式的进一步优化，将接口实现的内容封装在一个具体方法里，然后去进行方法引用作为接口的实现。增强方法的可复用性。</p>
<p>基本语法：<strong>CLassName::MethodName</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strings = &#123;<span class="string">"c"</span>,<span class="string">"D"</span>,<span class="string">"e"</span>,<span class="string">"de"</span>,<span class="string">"qw"</span>,<span class="string">"Aeq"</span>&#125;;</span><br><span class="line">    	<span class="comment">//匿名内部类方式实现接口</span></span><br><span class="line">   		Arrays.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.compareToIgnoreCase(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    	<span class="comment">//Lambda表达式中只是调用了一个现有的方法</span></span><br><span class="line">        Arrays.sort(strings,(s1,s2)-&gt;s1.compareToIgnoreCase(s2));</span><br><span class="line">    	<span class="comment">//可以用方法引用的方式实现匿名内部类</span></span><br><span class="line">        Arrays.sort(strings,String::compareToIgnoreCase);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：<u>sort(T[] a, Comparator c) 该方法中的接口参数Comparator是一个函数式接口。</u></p>
<p>方法引用也分几种情况：</p>
<ol>
<li><p><strong>静态方法引用：</strong> <strong>ClassName::staticMethodName</strong></p>
</li>
<li><p><strong>实例对象的方法引用：</strong> <strong>instanceReference::methodName</strong> </p>
</li>
<li><p><strong>超类上的实例方法引用：</strong> <strong>super::methodName</strong> </p>
<p><font color=red>注：</font>通过使用super，可以引用方法的超类版本。 还可以捕获this 指针，this :: equals  等价于lambda表达式  x -&gt; this.equals(x); </p>
</li>
<li><p><strong>类型上的实例方法引用：</strong> <strong>ClassName::methodName</strong>  </p>
</li>
</ol>
<p><font color=red>注：</font>要区别于静态方法引用，实例方法的调用是要依赖于对象去调用的，那么这个对象从何而来呢？   例如：String::toString 等价于lambda表达式 (s) -&gt; s.toString()   方法引用对应Lambda，Lambda的第一个参数会成为调用实例方法的对象。 有时候实例方法时泛型的，方法引用时可以在方法前加上&lt;类型参数&gt;，但大多数情况并不需要手动添加类型参数，编译器往往可以根据上下文推断出类型。</p>
<ol start="5">
<li><p><strong>构造方法引用： Class::new</strong> </p>
<p>例子：String::new， 等价于lambda表达式 () -&gt; new String() </p>
</li>
<li><p><strong>数组构造方法引用： TypeName[]::new</strong> </p>
<p>例子：int[]::new 是一个含有一个参数的构造器引用，这个参数就是数组的长度。等价于lambda表达式  x -&gt; new int[x]。</p>
</li>
</ol>
<p>无论Lambda表达式还是方法引用实质上都是匿名实现了函数式接口，都是对匿名内部类的进一步抽象。</p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>流式语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8特性(二)</title>
    <url>/2020/03/15/Java8%E7%89%B9%E6%80%A7(%E4%BA%8C)/</url>
    <content><![CDATA[<p><a href="https://jerrymouse1998.github.io/post/java8特性一/">Java8特性—流式语法</a>总结过Java8流式语法相关特性：函数式接口、默认方法、Lambda表达式、方法引用。<a id="more"></a></p>
<p>这次学一下Java8的其他特性：Stream API、Optional类、Date-Time API、Base64编码、Nashorn。</p>
<blockquote>
<p>——转载自<a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">RUNOOB</a>、<a href="https://www.cnblogs.com/rjzheng/p/9163246.html#4025294" target="_blank" rel="noopener">孤独烟</a>、<a href="https://blog.csdn.net/h_xiao_x/article/details/79729507" target="_blank" rel="noopener">回梦游先</a></p>
</blockquote>
<p>[TOC]</p>
<h2 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a><strong>Stream API</strong></h2><p>Java8API添加了一个新的抽象成为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream使用一种类似于SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象。</p>
<ul>
<li>StreamAPI可以极大提高Java程序员的生产力，让程序员写出高效率，干净，简洁的代码。</li>
</ul>
<p>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的结点上进行处理，比如筛选，排序，聚合等。。。</p>
<p>元素流在管道中经过中间操作(intermediate operation)的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
<p>流程：stream of elements —–&gt; filter-&gt; sorted-&gt; map-&gt; collect</p>
<p>以上的流程转换为Java代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = </span><br><span class="line">widgets.stream()</span><br><span class="line">             .filter(b -&gt; b.getColor() == RED)</span><br><span class="line">             .sorted((x,y) -&gt; x.getWeight() - y.getWeight())</span><br><span class="line">             .mapToInt(Widget::getWeight)</span><br><span class="line">             .sum();</span><br></pre></td></tr></table></figure>

<h3 id="什么是Stream？"><a href="#什么是Stream？" class="headerlink" title="什么是Stream？"></a>什么是Stream？</h3><p>Stream(流)是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成的一个队列。Java中的Steam并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong> 流的来源。可以是集合、数组、I/O channel、产生器geanerator等等。</li>
<li><strong>聚合操作</strong> 类似SQL语句一样的操作，比如filter、map、reduce、find、match、sorted等。和以前的Collection操作不同，Stream操作还有两个基础的特征：<ul>
<li><strong>Pipelining</strong>：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道，如同流式风格(fluent style)。这样做可以对操作进行优化，比如延迟执行(laziness)和短路(shor-circuiting)。</li>
<li><strong>内部迭代</strong>：以前对集合遍历都是通过Iterator或者For-Each的方式，显式的在集合外部进行迭代，这叫做<strong>外部迭代</strong>。Stream提供了<strong>内部迭代</strong>的方式，通过<strong>访问者模式(Visitor)</strong>实现。</li>
</ul>
</li>
</ul>
<h3 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h3><p>在Java8中，集合接口有两个方法来生成流：</p>
<ul>
<li><strong>stream()</strong>—为集合创建串行流。</li>
<li><strong>parallel Stream()</strong>—为集合创建并行流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Stream提供了新的方法“forEach”来迭代流中的每个数据。以下代码片段使用forEach输出了10个随机数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map方法用于映射每个元素到对应的结果，以下代码片段使用map输出了元素对应的平方数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter方法用于通过设置的条件过滤出元素。以下代码片段使用filter方法过滤出空字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit方法用于获取指定数量的流。以下代码片段使用limit方法打印出10条数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted方法用于对流进行排序。以下代码片段使用sorted方法对输出的10个随机数进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="并行-parallel-程序"><a href="#并行-parallel-程序" class="headerlink" title="并行(parallel)程序"></a>并行(parallel)程序</h3><p>parallelStream是流并行处理程序的替代方法。以下实例我们使用parallelStream来输出空字符串的数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><p>Collectors类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors可用于返回列表或字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">"筛选列表: "</span> + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">", "</span>));</span><br><span class="line">System.out.println(<span class="string">"合并字符串: "</span> + mergedString);</span><br></pre></td></tr></table></figure>

<h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>一些产生统计结果的收集器也非常有用。他们主要用于int、double、long等基本类型上，他们可以用来产生类似如下的统计结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//mapToInt((x) -&gt; x)返回一个IntStream对象</span></span><br><span class="line"><span class="comment">//summaryStatistics()返回一个IntSummaryStatistics对象</span></span><br><span class="line">IntSummaryStatistics stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">"列表中最大的数 : "</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">"列表中最小的数 : "</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">"所有数之和 : "</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">"平均数 : "</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a><strong>Optional类</strong></h2><p>Optional类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</p>
<p>Optional是个容器：他可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>Optional类的引用很好的解决空指针异常。</p>
<h3 id="类声明"><a href="#类声明" class="headerlink" title="类声明"></a>类声明</h3><p>java.util.Optinoal&lt;T&gt;类的声明:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt;<span class="keyword">extends</span> <span class="title">Object</span></span></span><br></pre></td></tr></table></figure>

<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><p><strong>注意：</strong> 这些方法是从 <strong>java.lang.Object</strong> 类继承来的。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th align="left">方法   &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="left">*<em>static &lt;T&gt;  Optional&lt;T&gt;   empty()  *</em>      返回空的 Optional 实例。</td>
</tr>
<tr>
<td>2</td>
<td align="left"><strong>boolean equals(Object   obj)</strong>        判断其他对象是否等于 Optional。</td>
</tr>
<tr>
<td>3</td>
<td align="left">*<em>Optional&lt;T&gt;   filter(Predicate&lt;? super &lt;T&gt; predicate)   *</em>如果值存在，并且这个值匹配给定的   predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</td>
</tr>
<tr>
<td>4</td>
<td align="left"><strong>Optional&lt;T&gt; filter(Predicate&lt;? super &lt;T&gt; predicate)</strong>      如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。</td>
</tr>
<tr>
<td>5</td>
<td align="left">*<em>T   get() *</em>  如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException，使用get()方法前，最好进行isPresent()校验。</td>
</tr>
<tr>
<td>6</td>
<td align="left"><strong>int hashCode()</strong>      返回存在值的哈希码，如果值不存在 返回   0。</td>
</tr>
<tr>
<td>7</td>
<td align="left"><strong>void ifPresent(Consumer&lt;? super   T&gt; consumer)</strong>     如果值存在则使用该值调用 consumer</td>
</tr>
<tr>
<td>8</td>
<td align="left"><strong>boolean   isPresent()</strong>      如果值存在则方法会返回true，否则返回 false。</td>
</tr>
<tr>
<td>9</td>
<td align="left"><strong>&lt;U&gt;Optional&lt;U&gt; map(Function&lt;? super T,? extends U&gt; mapper)</strong>  如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。</td>
</tr>
<tr>
<td>10</td>
<td align="left"><strong>static &lt;T&gt; Optional&lt;T&gt;   of(T value)</strong>  返回一个指定非null值的Optional。</td>
</tr>
<tr>
<td>11</td>
<td align="left">*<em>static &lt;T&gt; Optional&lt;T&gt;   ofNullable(T value)  *</em>如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。</td>
</tr>
<tr>
<td>12</td>
<td align="left"><strong>T orElse(T other)</strong>  如果存在该值，返回值， 否则返回   other。</td>
</tr>
<tr>
<td>13</td>
<td align="left"><strong>T orElseGet(Supplier&lt;? extends   T&gt; other)</strong>   如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。</td>
</tr>
<tr>
<td>14</td>
<td align="left">*<em>&lt;X extends Throwable&gt; T   orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)    *</em>如果存在该值，返回包含的值，否则抛出由   Supplier 继承的异常。</td>
</tr>
<tr>
<td>15</td>
<td align="left"><strong>String   toString()</strong>    返回一个Optional的非空字符串，用来调试。</td>
</tr>
</tbody></table>
<h4 id="1、Optional-T-value-empty-of-T-value-ofNullable-T-value"><a href="#1、Optional-T-value-empty-of-T-value-ofNullable-T-value" class="headerlink" title="1、Optional(T value),empty(),of(T value),ofNullable(T value)"></a>1、Optional(T value),empty(),of(T value),ofNullable(T value)</h4><p>这四个函数之间具有相关性，因此放在一组进行记忆。</p>
<p>先说明一下，Optional(T value)即构造函数，它是private权限的，不能由外部调用的。其余三个函数是public权限，供用户调用。<strong>那么Optional的本质就是内部储存了一个真实的值，在构造的时候，就直接判断其值是否为空</strong>。直接上Optional(T value)构造函数的源码，如下图：</p>
<p><img src="https://s2.ax1x.com/2019/09/21/nxrlVO.png" alt="nxrlVO.png"></p>
<p><strong>of(T value)</strong>的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">of</span><span class="params">(T var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Optional(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其内部直接调用了构造函数，根据构造函数可以得到两个结论：</p>
<ol>
<li>通过of(T value)函数所构造出的Optional对象，当value属性值为空时，依然会报出NPE。</li>
<li>通过of(T value)函数所构造出的Optional对象，当value属性值不为空是，能正常构造Optional对象。</li>
</ol>
<p>除此之外，Optional内部还维护一个value为null的对象，大概长下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="keyword">new</span> Optional&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Optional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，<strong>empty()的作用</strong>就是返回EMPTY对象。</p>
<p>说前面三个方法都是为了铺垫，可以说<strong>ofNullable(T value)的作用</strong>了，上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Optional&lt;T&gt; <span class="title">ofNullable</span><span class="params">(T var0)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> var0 == <span class="keyword">null</span> ? empty() : of(var0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>显而易见，相比较of(T value)的<strong>区别</strong>就是，当value值为null时，<strong>of(T value)</strong>会报NPE异常；而<strong>ofNullable(T value)</strong>不会throw Exception，ofNullable(T value)直接返回一个EMPTY对象。</p>
<p><strong>那是不是意味着，我们在项目中只用ofNullable(T value)函数而不需要of(T value)函数了呢？</strong></p>
<p>不是的，既然存在那么自然有存在的价值。当我们在运行过程中，不想隐藏NPE，而是要立刻报告，这种情况下就用of(T value)函数。但是不得不说，这种场景很少很少，博主也仅在写junit测试用例中用到过此函数。</p>
<h4 id="2、orElse-T-other-、orElseGet-Supplier-lt-extendsT-gt-other-、orElseThrow-Supplier-lt-extends-X-gt-exceptionSupplier"><a href="#2、orElse-T-other-、orElseGet-Supplier-lt-extendsT-gt-other-、orElseThrow-Supplier-lt-extends-X-gt-exceptionSupplier" class="headerlink" title="2、orElse(T other)、orElseGet(Supplier&lt;? extendsT&gt; other)、orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)"></a>2、orElse(T other)、orElseGet(Supplier&lt;? extendsT&gt; other)、orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</h4><p>这三个函数放一组进行记忆，都是在构造函数传入的value值为null时，进行调用的。<strong>orElse</strong>和<strong>orElseGet</strong>的用法如下所示，相当于value值为null时，给予一个默认值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">null</span>;</span><br><span class="line">    user = Optional.ofNullable(user).orElse(createUser());</span><br><span class="line">    user = Optional.ofNullable(user).orElseGet(() -&gt; createUser());</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">createUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"zhangsan"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数的<strong>区别</strong>：当user值不为null时，orElse函数依然会执行createUser()函数，而orElseGet函数并不会执行createUser()函数。</p>
<p>至于orElseThrow，就是value值为null时，直接抛一个异常出去，用法如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User user = <span class="keyword">null</span>;</span><br><span class="line">Optional.ofNullable(user).orElseThrow(()-&gt;<span class="keyword">new</span> Exception(<span class="string">"用户不存在"</span>));</span><br></pre></td></tr></table></figure>

<h4 id="3、map-Function-lt-super-T-extends-U-gt-mapper-和flatMap-Function-lt-super-T-Optional-lt-U-gt-gt-mapper"><a href="#3、map-Function-lt-super-T-extends-U-gt-mapper-和flatMap-Function-lt-super-T-Optional-lt-U-gt-gt-mapper" class="headerlink" title="3、map(Function &lt;? super T,? extends U&gt; mapper)和flatMap(Function &lt;? super T,Optional&lt;U&gt;&gt; mapper)"></a>3、map(Function &lt;? super T,? extends U&gt; mapper)和flatMap(Function &lt;? super T,Optional&lt;U&gt;&gt; mapper)</h4><p>这两个函数放在一组记忆，这两个函数做的是转换值的操作。上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; var1)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(var1);</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.isPresent() ? empty() : ofNullable(var1.apply(<span class="keyword">this</span>.value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> &lt;U&gt; <span class="function">Optional&lt;U&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, Optional&lt;U&gt;&gt; var1)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(var1);</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.isPresent() ? empty() : (Optional)Objects.requireNonNull(var1.apply(<span class="keyword">this</span>.value));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数，在函数体的上的区别不大，<strong>主要的区别</strong>就是入参，map函数所接受的入参类型为Function&lt;? supper T,? extends U&gt;,而flapMap的入参类型为Function&lt;? super T,Optional&lt;U&gt;&gt;。</p>
<p>具体用法上，对于<strong>map</strong>而言：</p>
<p>如果User结构是下面这样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候取name的写法如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = Optional.ofNullable(user).map(u-&gt; u.getName()).get()；</span><br></pre></td></tr></table></figure>

<p>对于<strong>flatmap</strong>而言则是这样：</p>
<p>如果User结构是下面这样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候取name的写法如下所示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = Optional.ofNullable(user).flatMap(u-&gt;u.getName()).get()；</span><br></pre></td></tr></table></figure>

<h4 id="4、isPresent-和ifPresent-Consumer-lt-super-T-gt-consumer"><a href="#4、isPresent-和ifPresent-Consumer-lt-super-T-gt-consumer" class="headerlink" title="4、isPresent()和ifPresent(Consumer&lt;? super T&gt; consumer)"></a>4、isPresent()和ifPresent(Consumer&lt;? super T&gt; consumer)</h4><p>这两个函数放在一起记忆，isPresent即判断value值是否为空，而ifPresent就是在value值不为空时，做一些操作。上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPresent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ifPresent</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.value != <span class="keyword">null</span>) &#123;</span><br><span class="line">        var1.accept(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>注意：</font>不要进行下面这种鸡肋的操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>)&#123;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//写成</span></span><br><span class="line">User user = Optional.ofNullable(user);</span><br><span class="line"><span class="keyword">if</span> (Optional.isPresent())&#123;</span><br><span class="line">   <span class="comment">// <span class="doctag">TODO:</span> do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这样写，代码结构依然丑陋。后面会给出正确写法</p>
<p>至于ifPresent(Consumer &lt;?super T&gt; consumer),用法也很简单，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional.ofNullable(user).ifPresent(u-&gt;&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="5、filter-Predicate-lt-super-T-gt-predicate"><a href="#5、filter-Predicate-lt-super-T-gt-predicate" class="headerlink" title="5、filter(Predicate&lt;? super T&gt; predicate)"></a>5、filter(Predicate&lt;? super T&gt; predicate)</h4><p>直接上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//省略....</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(predicate);</span><br><span class="line">        <span class="keyword">if</span> (!isPresent())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> predicate.test(value) ? <span class="keyword">this</span> : empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>filter方法接受一个Predicate来对Optional中包含的值进行过滤，如果包含的值满足条件，那么还是返回这个Optional；否则返回Optional.empty。</p>
<p>用法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;User&gt; user1 = Optional.ofNullable(user).filter(u -&gt; u.getName().length()&lt;<span class="number">6</span>);</span><br></pre></td></tr></table></figure>

<p>如上所示，如果user的name的长度是小于6的，则返回。如果是大于6的，则返回一个EMPTY对象。</p>
<h3 id="实战使用"><a href="#实战使用" class="headerlink" title="实战使用"></a>实战使用</h3><h4 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">(User user)</span>  <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(user.getAddress()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Address address = user.getAddress();</span><br><span class="line">            <span class="keyword">if</span>(address.getCity()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> address.getCity();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Excpetion(<span class="string">"取值错误"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JAVA8写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCity</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(user)</span><br><span class="line">        .map(u-&gt; u.getAddress())</span><br><span class="line">        .map(a-&gt;a.getCity())</span><br><span class="line">        .orElseThrow(()-&gt;<span class="keyword">new</span> Exception(<span class="string">"取指错误"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前写法</span></span><br><span class="line"><span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    dosomething(user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//JAVA8写法</span></span><br><span class="line">Optional.ofNullable(user)</span><br><span class="line">    .ifPresent(u-&gt;&#123;</span><br><span class="line">        dosomething(u);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以前写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(User user)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        String name = user.getName();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"zhangsan"</span>.equals(name))&#123;</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"zhangsan"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//java8写法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(user)</span><br><span class="line">        .filter(u-&gt;<span class="string">"zhangsan"</span>.equals(u.getName()))</span><br><span class="line">        .orElseGet(()-&gt; &#123;</span><br><span class="line">            User user1 = <span class="keyword">new</span> User();</span><br><span class="line">            user1.setName(<span class="string">"zhangsan"</span>);</span><br><span class="line">            <span class="keyword">return</span> user1;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有很多应用的例子，就不一一列举了。不过采用这种链式编程，虽然代码优雅了。但是，逻辑性没那么明显，可读性有所下降，大家项目中看情况酌情使用。</p>
<hr>
<h2 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date-Time API"></a><strong>Date-Time API</strong></h2><p>Java8发布新的Date-Time API(JSR 310)来进一步加强对日期和时间的处理。</p>
<p>在旧版的Java中，日期时间API存在诸多问题，其中有：</p>
<ul>
<li><strong>非线程安全</strong>：java.util.Date是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。</li>
<li><strong>设计很差</strong>：Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。</li>
<li><strong>时区处理麻烦</strong>：日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有问题。</li>
</ul>
<p>Java8在<strong>java.time</strong>包下提供了很多的新的API。以下为两个比较重要的API：</p>
<ul>
<li><strong>Local(本地)</strong>：简化了日期时间的处理，没有时区的问题。</li>
<li><strong>Zoned(时区)</strong>：通过制定的时区处理日期时间。</li>
</ul>
<p>新的java.time包涵盖了所有处理日期、时间、日期/时间、时区、时刻(instants)、过程(during)与时钟(clock)的操作。</p>
<h3 id="常用、重要对象介绍："><a href="#常用、重要对象介绍：" class="headerlink" title="常用、重要对象介绍："></a>常用、重要对象介绍：</h3><p><strong>ZoneId：时区ID，用来确定Instant和LocalDateTime互相转换的规则。</strong></p>
<p><strong>Instant：用来表示时间线上的一个点（瞬时）。</strong></p>
<p><strong>LocalDate：表示没有时区的日期，LocalDate是不可变并且线程安全的。</strong></p>
<p><strong>LocalTime：表示没有时区的时间，LocalTime是不可变并且线程安全的。</strong></p>
<p><strong>LocalDateTime：表示没有时区的日期时间，LocalDateTime是不可变并且线程安全的。</strong></p>
<p><strong>Clock：用于访问当前时刻、日期、时间，用到时区。</strong></p>
<p><strong>Duration：用秒和纳秒表示时间的数量（长短），用于计算两个日期的“时间”间隔。</strong></p>
<p><strong>Period：用于计算两个“日期”间隔。</strong></p>
<p><u>其中，LocalDate、LocalTime、LocalDateTime都是新API里的基础对象，绝大多数操作都是围绕这三个对象来进行的，有必要啰嗦一遍：</u></p>
<p><strong>LocalDate：只含年 月 日的日期对象。</strong></p>
<p><strong>LocalTime：只含时 分 秒的时间对象。</strong></p>
<p><strong>LocalDateTime：同时含有年 月 日 时 分 秒的日期对象。</strong></p>
<h3 id="直接上示例："><a href="#直接上示例：" class="headerlink" title="直接上示例："></a>直接上示例：</h3><h4 id="1-获取当前时间："><a href="#1-获取当前时间：" class="headerlink" title="1.获取当前时间："></a>1.获取当前时间：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2019-09-22T12:22:10.214</span></span><br><span class="line"><span class="comment">//2019-09-22</span></span><br><span class="line"><span class="comment">//12:22:10.215</span></span><br></pre></td></tr></table></figure>

<h4 id="2-根据指定日期-时间创建对象："><a href="#2-根据指定日期-时间创建对象：" class="headerlink" title="2.根据指定日期/时间创建对象："></a>2.根据指定日期/时间创建对象：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.of(<span class="number">2018</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">        LocalDate localDate = LocalDate.of(<span class="number">2018</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">        LocalTime localTime = LocalTime.of(<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">        System.out.println(localDateTime);</span><br><span class="line">        System.out.println(localDate);</span><br><span class="line">        System.out.println(localTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2018-08-08T08:08:08</span></span><br><span class="line"><span class="comment">//2018-08-08</span></span><br><span class="line"><span class="comment">//08:08:08</span></span><br></pre></td></tr></table></figure>

<h4 id="3-日期时间的加减："><a href="#3-日期时间的加减：" class="headerlink" title="3.日期时间的加减："></a>3.日期时间的加减：</h4><p><font color=red>注意：对于<strong>LocalDate</strong>，只有精度大于等于日的加减，如年，月，日；对于<strong>LocalTime</strong>，只有精度小于等于时加减，如时，分，秒，纳秒；对于<strong>LocalDateTime</strong>，则可以进行任意精度的时间相加减；否则会抛出异常：java.time.temporal.UnsupportedTemporalTypeException: Unsupported unit: XXX</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line"><span class="comment">//以下方法的参数都是long型，返回值都是LocalDateTime</span></span><br><span class="line">        LocalDateTime plusYearsResult = localDateTime.plusYears(<span class="number">2L</span>);</span><br><span class="line">        LocalDateTime plusMonthsResult = localDateTime.plusMonths(<span class="number">4L</span>);</span><br><span class="line">        LocalDateTime plusDaysResult = localDateTime.plusDays(<span class="number">7L</span>);</span><br><span class="line">        LocalDateTime plusHoursResult = localDateTime.plusHours(<span class="number">2L</span>);</span><br><span class="line">        LocalDateTime plusMinutesResult = localDateTime.plusMinutes(<span class="number">10L</span>);</span><br><span class="line">        LocalDateTime plusSecondsResult = localDateTime.plusSeconds(<span class="number">10L</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前时间是 : "</span> + localDateTime + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加2年后为 : "</span> + plusYearsResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加3个月后为 : "</span> + plusMonthsResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加7日后为 : "</span> + plusDaysResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加2小时后为 : "</span> + plusHoursResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加10分钟后为 : "</span> + plusMinutesResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"当前时间加10秒后为 : "</span> + plusSecondsResult + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line"><span class="comment">//也可以以另一种方式来相加减日期，即plus(long amountToAdd, TemporalUnit unit)</span></span><br><span class="line"><span class="comment">//             参数1 ： 相加的数量， 参数2 ： 相加的单位</span></span><br><span class="line">        LocalDateTime nextMonth = localDateTime.plus(<span class="number">1</span>, ChronoUnit.MONTHS);</span><br><span class="line">        LocalDateTime nextYear = localDateTime.plus(<span class="number">1</span>, ChronoUnit.YEARS);</span><br><span class="line">        LocalDateTime nextWeek = localDateTime.plus(<span class="number">1</span>, ChronoUnit.WEEKS);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"now : "</span> + localDateTime + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"nextYear : "</span> + nextYear + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"nextMonth : "</span> + nextMonth + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"nextWeek :"</span> + nextWeek + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line"><span class="comment">//日期的减法用法一样，在此不再举例用minus()方法或者minusXXX()方法</span></span><br><span class="line">        LocalDateTime minus = localDateTime.minus(<span class="number">1L</span>, ChronoUnit.YEARS);</span><br><span class="line">        System.out.println(minus);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前时间是 : 2019-09-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加2年后为 : 2021-09-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加3个月后为 : 2020-01-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加7日后为 : 2019-09-29T13:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加2小时后为 : 2019-09-22T15:01:41.773</span></span><br><span class="line"><span class="comment">//当前时间加10分钟后为 : 2019-09-22T13:11:41.773</span></span><br><span class="line"><span class="comment">//当前时间加10秒后为 : 2019-09-22T13:01:51.773</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//now : 2019-09-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//nextYear : 2020-09-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//nextMonth : 2019-10-22T13:01:41.773</span></span><br><span class="line"><span class="comment">//nextWeek :2019-09-29T13:01:41.773</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2018-09-22T13:01:41.773</span></span><br></pre></td></tr></table></figure>

<h4 id="4-将年、月、日、等修改为指定的值，并返回新的日期-时间对象："><a href="#4-将年、月、日、等修改为指定的值，并返回新的日期-时间对象：" class="headerlink" title="4.将年、月、日、等修改为指定的值，并返回新的日期/时间对象："></a>4.将年、月、日、等修改为指定的值，并返回新的日期/时间对象：</h4><p><font color=red>注意：在指定日期/时间时要注意取值范围，日期还要注意日期基础上是否为闰年(leap year)，如果超出取值范围会报出：java.time.DateTimeException: Invalid value for DayOfYear (valid values 1 - 365/366): XXX，如果没有注意是否为闰年去特殊范围值的时候会报出：java.time.DateTimeException: Invalid date ‘DayOfYear XXX’ as ‘XXXX’ is not a leap year</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line"><span class="comment">//当前时间基础上，指定本年当中的第几天，取值范围为1-365,366</span></span><br><span class="line">        LocalDate withDayOfYearResult = localDate.withDayOfYear(<span class="number">200</span>);</span><br><span class="line"><span class="comment">//当前时间基础上，指定本月当中的第几天，取值范围为1-29,30,31</span></span><br><span class="line">        LocalDate withDayOfMonthResult = localDate.withDayOfMonth(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//当前时间基础上，直接指定年份</span></span><br><span class="line">        LocalDate withYearResult = localDate.withYear(<span class="number">2017</span>);</span><br><span class="line"><span class="comment">//当前时间基础上，直接指定月份</span></span><br><span class="line">        LocalDate withMonthResult = localDate.withMonth(<span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前时间是 : "</span> + localDate + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"指定本年当中的第200天 : "</span> + withDayOfYearResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"指定本月当中的第5天 : "</span> + withDayOfMonthResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"直接指定年份为2017 : "</span> + withYearResult + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"直接指定月份为5月 : "</span> + withMonthResult + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前时间是 : 2019-09-22</span></span><br><span class="line"><span class="comment">//指定本年当中的第200天 : 2019-07-19</span></span><br><span class="line"><span class="comment">//指定本月当中的第5天 : 2019-09-05</span></span><br><span class="line"><span class="comment">//直接指定年份为2017 : 2017-09-22</span></span><br><span class="line"><span class="comment">//直接指定月份为5月 : 2019-05-22</span></span><br></pre></td></tr></table></figure>

<h4 id="5-获取日期的年月日周时分秒："><a href="#5-获取日期的年月日周时分秒：" class="headerlink" title="5.获取日期的年月日周时分秒："></a>5.获取日期的年月日周时分秒：</h4><p>直接用getDayOfWeek或者getMonth取得的是枚举类型(enum)的英文单词，可以用可以再用Week或者Month枚举类提供的getValue方法转换为数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        <span class="keyword">int</span> dayOfYear = localDateTime.getDayOfYear();</span><br><span class="line">        <span class="keyword">int</span> dayOfMonth = localDateTime.getDayOfMonth();</span><br><span class="line">        DayOfWeek dayOfWeek = localDateTime.getDayOfWeek();</span><br><span class="line">        System.out.println(<span class="string">"今天是"</span> + localDateTime + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"本年当中第"</span> + dayOfYear + <span class="string">"天"</span> + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"本月当中第"</span> + dayOfMonth + <span class="string">"天"</span> + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"本周中星期"</span> + dayOfWeek.getValue() + <span class="string">"-即"</span> + dayOfWeek + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当天时间的年月日时分秒</span></span><br><span class="line">        <span class="keyword">int</span> year = localDateTime.getYear();</span><br><span class="line">        Month month = localDateTime.getMonth();</span><br><span class="line">        <span class="keyword">int</span> day = localDateTime.getDayOfMonth();</span><br><span class="line">        <span class="keyword">int</span> hour = localDateTime.getHour();</span><br><span class="line">        <span class="keyword">int</span> minute = localDateTime.getMinute();</span><br><span class="line">        <span class="keyword">int</span> second = localDateTime.getSecond();</span><br><span class="line">        System.out.println(<span class="string">"今天是"</span> + localDateTime + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"年 ： "</span> + year + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"月 ： "</span> + month.getValue() + <span class="string">"-即 "</span>+ month + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"日 ： "</span> + day + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"时 ： "</span> + hour + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"分 ： "</span> + minute + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">"秒 ： "</span> + second + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//今天是2019-09-22T13:30:03.943</span></span><br><span class="line"><span class="comment">//本年当中第265天</span></span><br><span class="line"><span class="comment">//本月当中第22天</span></span><br><span class="line"><span class="comment">//本周中星期7-即SUNDAY</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//今天是2019-09-22T13:30:03.943</span></span><br><span class="line"><span class="comment">//年 ： 2019</span></span><br><span class="line"><span class="comment">//月 ： 9-即 SEPTEMBER</span></span><br><span class="line"><span class="comment">//日 ： 22</span></span><br><span class="line"><span class="comment">//时 ： 13</span></span><br><span class="line"><span class="comment">//分 ： 30</span></span><br><span class="line"><span class="comment">//秒 ： 3</span></span><br></pre></td></tr></table></figure>

<h4 id="6-时间-日期前后的比较与判断："><a href="#6-时间-日期前后的比较与判断：" class="headerlink" title="6.时间/日期前后的比较与判断："></a>6.时间/日期前后的比较与判断：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断两个时间点的前后</span></span><br><span class="line">        LocalDate localDate1 = LocalDate.of(<span class="number">2019</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        LocalDate localDate2 = LocalDate.of(<span class="number">2018</span>, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">boolean</span> date1IsBeforeDate2 = localDate1.isBefore(localDate2);</span><br><span class="line">        System.out.println(<span class="string">"date1IsBeforeDate2 : "</span> + date1IsBeforeDate2);</span><br><span class="line">        <span class="comment">//API还提供了isAfter()、isEqual()，顾名思义就不必举例了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//date1IsBeforeDate2 : false</span></span><br></pre></td></tr></table></figure>

<h4 id="7-判断是否为闰年："><a href="#7-判断是否为闰年：" class="headerlink" title="7.判断是否为闰年："></a>7.判断是否为闰年：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LocalDate now = LocalDate.now();</span><br><span class="line">        System.out.println(<span class="string">"now : "</span> + now + <span class="string">", is leap year ? "</span> + now.isLeapYear());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//now : 2019-09-22, is leap year ? false</span></span><br></pre></td></tr></table></figure>

<h4 id="8-java8时钟-：-clock"><a href="#8-java8时钟-：-clock" class="headerlink" title="8.java8时钟 ： clock()"></a>8.java8时钟 ： clock()</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//返回当前时间，根据系统时间和UTC</span></span><br><span class="line">        Clock clock = Clock.systemUTC();</span><br><span class="line">        System.out.println(clock);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//SystemClock[Z]</span></span><br></pre></td></tr></table></figure>

<h4 id="9-时间戳"><a href="#9-时间戳" class="headerlink" title="9.时间戳:"></a>9.时间戳:</h4><p><font color=red>事实上<strong>Instant</strong>就是Java8之前的Date，可以使用以下两个类中的方法在这两个类型之间进行转换，比如Date.from(Instant)就是用来把Instant转换成java.util.date的，而new Date().toInstant()就是将Date转换为Instant的。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant instant = Instant.now();</span><br><span class="line">        System.out.println(instant);</span><br><span class="line">        Date date = Date.from(instant);</span><br><span class="line">        Instant instant2 = date.toInstant();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        System.out.println(instant2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2019-09-22T05:51:30.257Z</span></span><br><span class="line"><span class="comment">//Sun Sep 22 13:51:30 CST 2019</span></span><br><span class="line"><span class="comment">//2019-09-22T05:51:30.257Z</span></span><br></pre></td></tr></table></figure>

<h4 id="10-计算时间-日期间隔"><a href="#10-计算时间-日期间隔" class="headerlink" title="10.计算时间/日期间隔:"></a>10.计算时间/日期间隔:</h4><p>Duration：用于计算两个“时间”间隔</p>
<p>Period：用于计算两个“日期”间隔</p>
<p><font color=red>注意：当获取两个日期的间隔时，并不是单纯的年月日对应的数字相加减，而是会先算出具体差多少天，在折算成相差几年几月几日的</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//计算两个日期的日期间隔-年月日</span></span><br><span class="line">        LocalDate date1 = LocalDate.of(<span class="number">2018</span>, <span class="number">2</span>, <span class="number">13</span>);</span><br><span class="line">        LocalDate date2 = LocalDate.of(<span class="number">2017</span>, <span class="number">3</span>, <span class="number">12</span>);</span><br><span class="line"><span class="comment">//内部是用date2-date1，所以得到的结果是负数</span></span><br><span class="line">        Period period = Period.between(date1, date2);</span><br><span class="line">        System.out.println(<span class="string">"相差年数 ： "</span> + period.getYears());</span><br><span class="line">        System.out.println(<span class="string">"相差月数 ： "</span> + period.getMonths());</span><br><span class="line">        System.out.println(<span class="string">"相差日数 ： "</span> + period.getDays());</span><br><span class="line"><span class="comment">//还可以这样获取相差的年月日</span></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        <span class="keyword">long</span> years = period.get(ChronoUnit.YEARS);</span><br><span class="line">        <span class="keyword">long</span> months = period.get(ChronoUnit.MONTHS);</span><br><span class="line">        <span class="keyword">long</span> days = period.get(ChronoUnit.DAYS);</span><br><span class="line">        System.out.println(<span class="string">"相差的年月日分别为 ： "</span> + years + <span class="string">","</span> + months + <span class="string">","</span> + days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算两个时间的间隔</span></span><br><span class="line">        System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">        LocalDateTime date3 = LocalDateTime.now();</span><br><span class="line">        LocalDateTime date4 = LocalDateTime.of(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">22</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line">        Duration duration = Duration.between(date3, date4);</span><br><span class="line">        System.out.println(date3 + <span class="string">" 与 "</span> + date4 + <span class="string">" 间隔  "</span> + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 天 :"</span> + duration.toDays() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 时 :"</span> + duration.toHours() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 分 :"</span> + duration.toMinutes() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 毫秒 :"</span> + duration.toMillis() + <span class="string">"\n"</span></span><br><span class="line">                + <span class="string">" 纳秒 :"</span> + duration.toNanos() + <span class="string">"\n"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相差年数 ： 0</span></span><br><span class="line"><span class="comment">//相差月数 ： -11</span></span><br><span class="line"><span class="comment">//相差日数 ： -1</span></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"><span class="comment">//相差的年月日分别为 ： 0,-11,-1</span></span><br><span class="line"><span class="comment">//-------------------------------</span></span><br><span class="line"><span class="comment">//2019-09-22T13:58:43.623 与 2018-01-13T22:30:10 间隔  </span></span><br><span class="line"><span class="comment">// 天 :-616</span></span><br><span class="line"><span class="comment">// 时 :-14799</span></span><br><span class="line"><span class="comment">// 分 :-887968</span></span><br><span class="line"><span class="comment">// 毫秒 :-53278113623</span></span><br><span class="line"><span class="comment">// 纳秒 :-53278113623000000</span></span><br></pre></td></tr></table></figure>

<h4 id="11-当计算程序的运行时间时，应当使用时间戳Instant"><a href="#11-当计算程序的运行时间时，应当使用时间戳Instant" class="headerlink" title="11.当计算程序的运行时间时，应当使用时间戳Instant:"></a>11.当计算程序的运行时间时，应当使用时间戳Instant:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Instant ins1 = Instant.now();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//循环一百万次</span></span><br><span class="line">        &#125;</span><br><span class="line">        Instant ins2 = Instant.now();</span><br><span class="line">        Duration duration = Duration.between(ins1, ins2);</span><br><span class="line">        System.out.println(<span class="string">"程序运行耗时为 ： "</span> + duration.toMillis() + <span class="string">"毫秒"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序运行耗时为 ： 1毫秒</span></span><br></pre></td></tr></table></figure>

<h4 id="12-时间日期的格式化（格式化后返回的类型是String）"><a href="#12-时间日期的格式化（格式化后返回的类型是String）" class="headerlink" title="12.时间日期的格式化（格式化后返回的类型是String）:"></a>12.时间日期的格式化（格式化后返回的类型是String）:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用jdk自身配置好的日期格式</span></span><br><span class="line">        DateTimeFormatter formatter1 = DateTimeFormatter.ISO_DATE_TIME;</span><br><span class="line">        LocalDateTime date1 = LocalDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">"LocalDateTime："</span>+date1);</span><br><span class="line">        <span class="comment">//反过来调用也可以 : date1.format(formatter1);</span></span><br><span class="line">        String date1Str = formatter1.format(date1);</span><br><span class="line">        System.out.println(<span class="string">"jdk自身配置好的日期格式："</span>+date1Str);</span><br><span class="line">        <span class="comment">//使用自定义的日期格式</span></span><br><span class="line">        DateTimeFormatter dtf= DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String formatDateTime = date1.format(dtf);</span><br><span class="line">        System.out.println(<span class="string">"自定义日期格式:"</span>+formatDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//LocalDateTime：2019-09-22T14:21:21.762</span></span><br><span class="line"><span class="comment">//jdk自身配置好的日期格式：2019-09-22T14:21:21.762</span></span><br><span class="line"><span class="comment">//自定义日期格式:2019-09-22 14:21:21</span></span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注意</strong>：格式的写法必须与字符串的形式一样：如：</font></p>
<p><font color=red>2018-01-13 21:27:30 对应  yyyy-MM-dd HH:mm:ss</font></p>
<p><font color=red>20180113213328  对应   yyyyMMddHHmmss</font></p>
<p><font color=red>否则会有运行时异常！</font></p>
<p>看一个例子，思考原因：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新的格式化API中，格式化后的结果都默认是String，有时我们也需要返回经过格式化的同类型对象</span></span><br><span class="line">        LocalDateTime ldt1 = LocalDateTime.now();</span><br><span class="line">        System.out.println(ldt1);</span><br><span class="line">        DateTimeFormatter dtf1 = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String temp = dtf1.format(ldt1);</span><br><span class="line">        LocalDateTime formatedDateTime = LocalDateTime.parse(temp, dtf1);</span><br><span class="line">        System.out.println(formatedDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2019-09-22T14:34:24.653</span></span><br><span class="line"><span class="comment">//2019-09-22 14:39:54</span></span><br><span class="line"><span class="comment">//2019-09-22T14:34:24</span></span><br></pre></td></tr></table></figure>

<p><font color=red><strong>记住</strong>：得到的最终结果都是类似2019-09-22T14:34:24的格式因为在输出LocalDateTime对象时，会调用其重写的toString方法，读者可以读读源码就可知道，对于LocalDateTime对象，无论是String类型的时间日期转为LocalDatetime对象，还是LocalDateTime对象转为格式化后的LocalDateTime对象，得到的最终输出都是：yyyy-MM-ddThh:mm:ss 这样的格式！</font></p>
<p><font color=red>至于为什么这样，应该是为了符合国际化吧，也正因为如此，才有了LocalDate和LocalTime，以便于开发者有更多的选择。</font></p>
<p><font color=red>但上述说法仅限于LocalDateTime对象，而如果是LocalDateTime对象格式化转为String对象是可以任意格式的，如上文自定义格式示例！<br></font></p>
<h4 id="13-long毫秒值转换为日期"><a href="#13-long毫秒值转换为日期" class="headerlink" title="13.long毫秒值转换为日期:"></a>13.long毫秒值转换为日期:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo.testZonedDateTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testZonedDateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---------long毫秒值转换为日期---------"</span>);</span><br><span class="line">        DateTimeFormatter df= DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">        String longToDateTime = df.format(LocalDateTime.ofInstant(Instant.ofEpochMilli(System.currentTimeMillis()), ZoneId.of(<span class="string">"Asia/Shanghai"</span>)));</span><br><span class="line">        System.out.println(longToDateTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------long毫秒值转换为日期---------</span></span><br><span class="line"><span class="comment">//2019-09-22 14:41:25</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a><strong>Base64编码</strong></h2><p>在Java8中，Base64编码已经成为Java类库的标准。</p>
<p>Java8内置了Base64编码的编码器和解码器。</p>
<p>Base64工具类提供了一套静态方法获取下面三种Base64编解码器：</p>
<ul>
<li><strong>基本：</strong>输出被映射到一组字符A-Z a-z 0-9+/，编码不添加任何行标，输出的解码仅支持A-Z a-z 0-9+/。</li>
<li><strong>URL：</strong>输出映射到一组字符A-Z a-z 0-9+_，输出时URL和文件。</li>
<li><strong>MIME：</strong>输出映射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li>
</ul>
<h3 id="内嵌类"><a href="#内嵌类" class="headerlink" title="内嵌类"></a>内嵌类</h3><table>
<thead>
<tr>
<th>序号</th>
<th>内嵌类   &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>static class   Base64.Decoder</strong>    该类实现一个解码器用于，使用 Base64 编码来解码字节数据。</td>
</tr>
<tr>
<td>2</td>
<td><strong>static class   Base64.Encoder</strong>    该类实现一个编码器，使用 Base64 编码来编码字节数据。</td>
</tr>
</tbody></table>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><table>
<thead>
<tr>
<th>序号</th>
<th>方法名   &amp; 描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>static Base64.Decoder   getDecoder()</strong>      返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td>2</td>
<td>*<em>static Base64.Encoder   getEncoder() *</em>     返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。</td>
</tr>
<tr>
<td>3</td>
<td>*<em>static Base64.Decoder   getMimeDecoder() *</em>      返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td>4</td>
<td>*<em>static Base64.Encoder   getMimeEncoder() *</em>     返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。</td>
</tr>
<tr>
<td>5</td>
<td><strong>static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)</strong>       返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。</td>
</tr>
<tr>
<td>6</td>
<td><strong>static Base64.Decoder   getUrlDecoder()</strong>      返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
<tr>
<td>7</td>
<td><strong>static Base64.Encoder   getUrlEncoder()</strong>       返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。</td>
</tr>
</tbody></table>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用基本编码</span></span><br><span class="line">            String base64encodedString = Base64.getEncoder().encodeToString(<span class="string">"runoob?java8"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Base64 编码字符串 (基本) :"</span> + base64encodedString);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"原始字符串: "</span> + <span class="keyword">new</span> String(base64decodedBytes, <span class="string">"utf-8"</span>));</span><br><span class="line">            base64encodedString = Base64.getUrlEncoder().encodeToString(<span class="string">"runoob?java8"</span>.getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">            System.out.println(<span class="string">"Base64 编码字符串 (URL) :"</span> + base64encodedString);</span><br><span class="line"></span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                stringBuilder.append(UUID.randomUUID().toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] mimeBytes = stringBuilder.toString().getBytes(<span class="string">"utf-8"</span>);</span><br><span class="line">            String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);</span><br><span class="line">            System.out.println(<span class="string">"Base64 编码字符串 (MIME) :"</span> + mimeEncodedString);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span>(UnsupportedEncodingException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Error :"</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输出结果：</span><br><span class="line">$ javac Java8Tester.java </span><br><span class="line">$ java Java8Tester</span><br><span class="line">原始字符串: runoob?java8</span><br><span class="line">Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg&#x3D;</span><br><span class="line">Base64 编码字符串 (MIME) :M2Q4YmUxMTEtYWRkZi00NzBlLTgyZDgtN2MwNjgzOGY2NGFlOTQ3NDYyMWEtZDM4ZS00YWVhLTkz</span><br><span class="line">OTYtY2ZjMzZiMzFhNmZmOGJmOGI2OTYtMzkxZi00OTJiLWEyMTQtMjgwN2RjOGI0MTBmZWUwMGNk</span><br><span class="line">NTktY2ZiZS00MTMxLTgzODctNDRjMjFkYmZmNGM4Njg1NDc3OGItNzNlMC00ZWM4LTgxNzAtNjY3</span><br><span class="line">NTgyMGY3YzVhZWQyMmNiZGItOTIwZi00NGUzLTlkMjAtOTkzZTI1MjUwMDU5ZjdkYjg2M2UtZTJm</span><br><span class="line">YS00Y2Y2LWIwNDYtNWQ2MGRiOWQyZjFiMzJhMzYxOWQtNDE0ZS00MmRiLTk3NDgtNmM4NTczYjMx</span><br><span class="line">ZDIzNGRhOWU4NDAtNTBiMi00ZmE2LWE0M2ItZjU3MWFiNTI2NmQ2NTlmMTFmZjctYjg1NC00NmE1</span><br><span class="line">LWEzMWItYjk3MmEwZTYyNTdk</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Nashorn"><a href="#Nashorn" class="headerlink" title="Nashorn"></a><strong>Nashorn</strong></h2><p>这部分仅仅是科普一下。。。知道有这么个东西，具体细节等到后序用到时再记录。。。</p>
<p><strong>Nashorn一个JavaScript引擎。</strong></p>
<p>从JDK1.8开始，Nashorn取代Rhino(JDK1.6，JDK1.7)成为Java嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSP 292的新语言特性，其中包含在JDK7中引入的invokedynamic，将JavaScript编译成Java字节码。</p>
<p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p>
<h3 id="jjs"><a href="#jjs" class="headerlink" title="jjs"></a>jjs</h3><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。jjs可以提供交互式编程体验。</p>
<h3 id="Java中调用JavaScript"><a href="#Java中调用JavaScript" class="headerlink" title="Java中调用JavaScript"></a>Java中调用JavaScript</h3><p>使用ScriptEngineManager类，JavaScript代码可以在Java中执行。</p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>流式语法</tag>
        <tag>Java8</tag>
        <tag>日期类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/2020/03/15/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="进程和线程的概念："><a href="#进程和线程的概念：" class="headerlink" title="进程和线程的概念："></a>进程和线程的概念：</h2><p>这不是一个复杂的概念，网上的解释有很多，引用百度到的一个解释。</p>
<p>转载自<a href="https://www.cnblogs.com/Jones-dd/p/8858995.html" target="_blank" rel="noopener">博客园</a>。</p>
<p><strong>进程：</strong>指在系统中正在运行的一个应用程序；程序一旦运行就是进程；或者更专业化来说：进程是指程序执行时的一个实例，即它是程序已经执行到课中程度的数据结构的汇集。从内核的观点看，进程的目的就是担当分配系统资源（CPU时间、内存等）的基本单位。</p>
<p><strong>线程：</strong>系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个单元执行流。进程——资源分配的最小单位，线程——程序执行的最小单位。</p>
<h3 id="线程进程的区别体现在4个方面："><a href="#线程进程的区别体现在4个方面：" class="headerlink" title="线程进程的区别体现在4个方面："></a>线程进程的区别体现在4个方面：</h3><ol>
<li><p>因为进程拥有独立的堆栈空间和数据段，所以每当启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这对于多进程来说十分“奢侈”，系统开销比较大，而线程不一样，线程拥有独立的堆栈空间，但是共享数据段，它们彼此之间使用相同的地址空间，共享大部分数据，比进程更节俭，开销比较小，切换速度也比进程快，效率高，但是正由于进程之间独立的特点，使得进程安全性比较高，也因为进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。一个线程死掉就等于整个进程死掉。</p>
</li>
<li><p>体现在通信机制上面，正因为进程之间互不干扰，相互独立，进程的通信机制相对很复杂，譬如管道，信号，消息队列，共享内存，套接字等通信机制，而线程由于共享数据段所以通信机制很方便。。</p>
</li>
<li><p>体现在CPU系统上面，线程使得CPU系统更加有效，因为操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。</p>
</li>
<li><p>体现在程序结构上，举一个简明易懂的列子：当我们使用进程的时候，我们不自主的使用if else嵌套来判断pid，使得程序结构繁琐，但是当我们使用线程的时候，基本上可以甩掉它，当然程序内部执行功能单元需要使用的时候还是要使用，所以线程对程序结构的改善有很大帮助。</p>
</li>
</ol>
<h3 id="什么情况下使用进程个线程："><a href="#什么情况下使用进程个线程：" class="headerlink" title="什么情况下使用进程个线程："></a>什么情况下使用进程个线程：</h3><ol>
<li><p>需要频繁创建销毁的优先使用线程；因为对进程来说创建和销毁一个进程代价是很大的</p>
</li>
<li><p>线程的切换速度快，所以在需要大量计算，切换频繁时用线程，还有耗时的操作使用线程可提高应用程序的响应</p>
</li>
<li><p>因为对CPU系统的效率使用上线程更占优，所以可能要发展到多机分布的用进程，多核分布用线程</p>
</li>
<li><p>并行操作时使用线程，如C/S架构的服务器端并发线程响应用户的请求</p>
</li>
<li><p>需要更稳定安全时，适合选择进程；需要速度时，选择线程更好</p>
<pre><code> 因为我的项目中需要对数据段的数据共享，可以被多个程序所修改，所以使用线程来完成此操作，无需加入复杂的通信机制，使用进程需要添加复杂的通信机制实现数据段的共享，增加了我的代码的繁琐，而且使用线程开销小，项目运行的速度快，效率高。

如果只用进程的话，虽然安全性高，但是对代码的简洁性不好，程序结构繁琐，开销比较大，还需要加入复杂的通信机制，会使得我的项目代码量大大增加，切换速度会变的很慢，执行效率降低不少。。。</code></pre></li>
</ol>
<h3 id="进程和线程的关系："><a href="#进程和线程的关系：" class="headerlink" title="进程和线程的关系："></a>进程和线程的关系：</h3><ol>
<li><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程是操作系统可识别的最小执行和调度单位。</p>
</li>
<li><p>资源分配给进程，同一进程的所有线程共享该进程的所有资源。 同一进程中的多个线程共享代码段(代码和常量)，数据段(全局变量和静态变量)，扩展段(堆存储)。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</p>
</li>
<li><p>处理机分给线程，即真正在处理机上运行的是线程。</p>
</li>
<li><p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p>
</li>
</ol>
<hr>
<h2 id="引子："><a href="#引子：" class="headerlink" title="引子："></a>引子：</h2><p>先看一段简单的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"MyThread的run方法在运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.run();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Main方法的循环"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果可想而知，当程序执行到myThread.run();时就会一直打印”MyThread的run方法在运行”，导致main方法中的”Main方法的循环”永远无法执行打印。</p>
<p>这种情况就是因为该程序是一个<strong>单线程程序</strong>，如果希望两个while循环中的打印语句都能够并发执行，就需要<strong>多线程。</strong></p>
<hr>
<h2 id="创建新线程和启动："><a href="#创建新线程和启动：" class="headerlink" title="创建新线程和启动："></a>创建新线程和启动：</h2><p>Java中可以通过继承Thread类重写run()方法实现多线程，Tread提供了一个start()方法，用于启动新线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"MyThread的run方法在运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();<span class="comment">//启动新线程</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Main方法的循环"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，两个while循环中的字符串不断地交替打印。大概是下图这个样子：</p>
<p><img src="https://s2.ax1x.com/2019/09/24/uAzL6I.png" alt="uAzL6I.png"></p>
<p>虽然继承Thread类实现了多线程，但是这种方式有一定的局限性：因为Java只支持单继承(之前写的<a href="https://jerrymouse1998.github.io/post/java%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/">Java继承策略</a>中聊过)，一个类一旦继承了某个父类就无法再继承Thread类。</p>
<p>虽然可以通过内部类继承Thread类的方法解决这个问题，但是显然这不会是一个好的方法。于是，Java还提供了<strong>实现Runnable接口</strong>创建多线程的方法，Thread类提供了一个<strong>构造方法Thread(Runnable target)</strong>。其中，Runnable是一个接口，他只有一个run()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当通过Thread(Runnable target)构造方法创建线程对象时，只需为该方法传递一个实现了Runnable接口的实例对象，这样创建的线程将调用实现了Runnable接口的类中的run()方法作为运行代码，而不需要调用Thread类中的run()方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"MyThread的run方法在运行"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Main方法的循环"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以实现和继承Thread类一样的效果，Runnable再应用时经常用匿名内部类的方式创建实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"MyThread的run方法在运行"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);<span class="comment">//Lambda表达式创建Runnable的匿名内部类传参</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Main方法的循环"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还不会流式语法的朋友可以参考之前的文章：<a href="https://jerrymouse1998.github.io/post/java8特性一/">Java8特性(一)</a></p>
<hr>
<h2 id="继承Thread类和实现Runnable接口的区别："><a href="#继承Thread类和实现Runnable接口的区别：" class="headerlink" title="继承Thread类和实现Runnable接口的区别："></a>继承Thread类和实现Runnable接口的区别：</h2><p>还是先看个例子：假设售票厅有4个窗口可发售某日某次列车的票100张，这时100张车票可以看作是共享资源，四个售票窗口需要创建4个线程。</p>
<p>先用继承Thread类方式创建多线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Thread th = Thread.currentThread();</span><br><span class="line">                String th_name = th.getName();</span><br><span class="line">                System.out.println(th_name+<span class="string">"正在发售第"</span>+ tickets-- +<span class="string">"张票！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> TicketWindow().start();</span><br><span class="line">        <span class="keyword">new</span> TicketWindow().start();</span><br><span class="line">        <span class="keyword">new</span> TicketWindow().start();</span><br><span class="line">        <span class="keyword">new</span> TicketWindow().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：Thread-0、Thread-1、Thread-2、Thread-3分别都卖了100张票，明显不符合场景要求。出现这种情况的原因是因为创建了4个TicketWindow就等于创建了四个程序，每个程序都有100张票，每个线程独立地处理各自的资源。</p>
<p>用实现Runnable接口方式创建多线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                Thread th = Thread.currentThread();<span class="comment">//获取当前线程</span></span><br><span class="line">                String th_name = th.getName();<span class="comment">//获取线程的名字</span></span><br><span class="line">                System.out.println(th_name+<span class="string">"正在发售第"</span>+ tickets-- +<span class="string">"张票！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TicketWindow ticketWindow = <span class="keyword">new</span> TicketWindow();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只创建了一个TicketWindow对象，然后创建了4个线程，每个线程都调用这个TicketWindow对象的run()方法，这样就可以确保4个线程访问的是同一个tickets变量，共享100张票。</p>
<p>通过上面这个例子，总结实现Runnable接口相对于继承Thread类来说，有如下优点：</p>
<ol>
<li>适合多个相同程序代码的线程去处理同一个资源的情况，把线程与程序代码、数据有效分离，很好地体现了面向对象的设计思想。</li>
<li>可以避免由于Java的单继承带来的局限性。</li>
</ol>
<p><strong><font color=red>事实上大部分的多线程应用都会采取实现Runnable接口的方法。</font></strong></p>
<hr>
<h2 id="线程的生命周期及状态转换："><a href="#线程的生命周期及状态转换：" class="headerlink" title="线程的生命周期及状态转换："></a>线程的生命周期及状态转换：</h2><p>在Java中，任何对象都有生命周期，线程也不例外。当Thread对象<strong>创建</strong>完成时，线程的声明周期便<strong>开始</strong>了。当<strong>run()方法</strong>中的代码正常执行完毕或者线程<strong>抛出一个未捕获的异常(Exception)或者错误(Error)</strong>时，线程的生命周期便会<strong>结束</strong>。线程整个生命周期分为5个阶段:<strong>新建状态(New)、就绪状态(Runnable)、运行状态(Running)、阻塞状态(Blocked)、和死亡状态(Terminated)</strong>。如下图所示：</p>
<p><img src="https://s2.ax1x.com/2019/09/24/uEebad.png" alt="uEebad.png"></p>
<h3 id="1-新建状态-New"><a href="#1-新建状态-New" class="headerlink" title="1.新建状态(New)"></a>1.新建状态(New)</h3><p>创建一个线程对象后，该线程对象就处于新建状态，此时它<strong>不能运行</strong>，和其他Java对象一样，仅仅由<strong>JVM为其分配了内存</strong>，没有表现出任何线程的动态特征。可以通过调用start方法进入就绪状态（runnable）.</p>
<p><font color=red>注意：不能对已经启动的线程再次调用start()方法，否则会出现Java.lang.IllegalThreadStateException异常。</font></p>
<h3 id="2-就绪状态-Runnable"><a href="#2-就绪状态-Runnable" class="headerlink" title="2.就绪状态(Runnable)"></a>2.就绪状态(Runnable)</h3><p>当线程对象调用了<strong>start()</strong>方法后，该线程就进入就绪状态。处于就绪状态的线程位于<strong>线程队列</strong>中，此时它只是<strong>具备了运行的条件</strong>，能否获得CPU的使用权并开始运行，还需要<strong>等待系统的调度</strong>。</p>
<p><font color=red>尽管是采用队列形式，事实上，把它称为可运行池而不是可运行队列。因为cpu的调度不一定是按照先进先出的顺序来调度的。</font></p>
<p><font color=red>提示：如果希望子线程调用start()方法后立即执行，可以使用Thread.sleep()方式使主线程睡眠一伙儿，转去执行子线程。</font></p>
<h3 id="3-运行状态-Running"><a href="#3-运行状态-Running" class="headerlink" title="3.运行状态(Running)"></a>3.运行状态(Running)</h3><p>如果处于就绪状态的线程<strong>获得CPU的使用权</strong>，并<strong>开始执行run()方法</strong>中的线程执行体，则该线程处于运行状态。一个线程启动后，他可能<strong>不会一直处于运行状态</strong>，当运行状态的线程<strong>使用完系统分配的时间</strong>后，系统就会<strong>剥夺</strong>该线程占用的CPU资源，让<strong>其他线程获得执行</strong>的机会。可以对在运行状态的线程调用<strong>yield()方法</strong>，它就会<strong>让出cpu资源</strong>，再次变为就绪状态。</p>
<p><font color=red>需要注意的是，只有处于就绪状态的线程才可能转换到运行状态。</font></p>
<h3 id="4-阻塞状态-Blocked"><a href="#4-阻塞状态-Blocked" class="headerlink" title="4.阻塞状态(Blocked)"></a>4.阻塞状态(Blocked)</h3><p>一个<strong>正在执行的线程</strong>在某些特殊情况下，如被<strong>人为挂起</strong>或<strong>执行耗时的输入/输出操作</strong>时，会<strong>让出CPU的使用权</strong>并<strong>暂时终止自己的执行</strong>，进入阻塞状态。线程进入<strong>阻塞状态后</strong>，就<strong>不能进入排队队列</strong>。只有当引起阻塞的原因被消除后，线程才可以转入就绪状态。</p>
<p>下面列举一下线程由运行状态转换成阻塞状态的原因，以及如何从阻塞状态转换成就绪状态：</p>
<ul>
<li>当线程视图获取某个对象的同步锁时，如果该锁被其他线程所持有，则当前线程会进入阻塞状态。如果想从阻塞状态进入就绪状态必须获取到其他线程所持有的锁。</li>
<li>当线程调用了一个阻塞式IO方法时，也会使线程进入阻塞状态，如果想进入就绪状态就必须要等到这个阻塞的IO方法返回。</li>
<li>当线程调用了某个对象的wait()方法时，也会使线程进入阻塞状态，如果想进入就绪队列就需要使用notify()方法唤醒该线程。</li>
<li>当线程调用了Thread的sleep(long millis)方法时，也会使线程进入阻塞状态。这种情况下，只需要等到线程睡眠的时间到了以后，线程就会自动进入就绪状态。</li>
<li>当在一个线程中调用了另一个线程的join()方法时，会使当前线程进入阻塞状态。在这种情况下，需要等到新加入的线程运行结束后才会结束阻塞状态，进入就绪状态。</li>
</ul>
<p><font color=red>需要注意的是：<strong>线程从阻塞状态只能进入就绪状态，而不能直接进入运行状态</strong>，也就是说结束阻塞的线程需要重新进入可运行池，等待系统的调度。</font></p>
<h3 id="5-死亡状态-Terminated"><a href="#5-死亡状态-Terminated" class="headerlink" title="5.死亡状态(Terminated)"></a>5.死亡状态(Terminated)</h3><p>当线程调用stop()方法或run()方法正常执行完毕后，或者线程抛出一个未捕获的异常(Exception)、错误(Error)，线程就进入死亡状态。一旦进入死亡状态，线程将不再拥有运行的资格，也不能再转换到其他状态。</p>
<p><font color=red>线程一旦死亡，就不能复生。 如果在一个死去的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</font></p>
<hr>
<h2 id="线程的调度："><a href="#线程的调度：" class="headerlink" title="线程的调度："></a>线程的调度：</h2><p>在计算机中，线程调度有两种模式，分别是<strong>分时调度模型</strong>和<strong>抢占式调度模型</strong>。所谓<strong>分时调度模型</strong>是指让所有的线程轮流获得CPU的使用权，并且平均分配每个线程占用的CPU的时间片。<strong>抢占式调度模型</strong>是指让可运行池中优先级高的线程优先占用CPU，而对于优先级相同的线程，随机选择一个线程使其占用CPU，当他失去了CPU的使用权后，再随机选择其他线程获取CPU的使用权。<strong>JVM默认采用抢占式调度模型</strong>，通常情况下程序员不需要去考虑它，但在某些特定需求下需要改变这种模式，由程序自己来控制CPU的调度。</p>
<h3 id="线程的优先级："><a href="#线程的优先级：" class="headerlink" title="线程的优先级："></a>线程的优先级：</h3><p>如果要对线程进行调度，最直接的方法就是设置线程的优先级。优先级越高的线程获得CPU执行的机会越大，反之，机会越小。线程的优先级有<strong>1~10的整数</strong>来表示，<strong>数字越大优先级越高</strong>。除了直接使用数字表示线程的优先级，还可以使用Thread中提供的<strong>三个静态常量</strong>表示线程的优先级：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>程序运行时，处于就绪状态的每个线程都有自己的优先级，例如：main线程具有普通优先级。然而线程的优先级不是固定不变的，可以通过<strong>setPriority(int newPriority)</strong>方法进行设置，方法参数接受1~10整数或上述的静态常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在打印"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread minPriority = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(),<span class="string">"低优先级的线程"</span>);</span><br><span class="line">        Thread normPriority = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(),<span class="string">"中优先级的线程"</span>);</span><br><span class="line">        Thread maxPriority = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task(),<span class="string">"高优先级的线程"</span>);</span><br><span class="line">        minPriority.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        normPriority.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        maxPriority.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        minPriority.start();</span><br><span class="line">        normPriority.start();</span><br><span class="line">        maxPriority.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有设置优先级，打印顺序和线程启动顺序一样。设置优先级之后，打印顺序按照线程优先级从高到低。<strong>getPriority()</strong>方法可以获取线程的优先级。</p>
<p><font color=red>需要注意：不同的操作系统对优先级的支持是不一样的，不会与Java中线程优先级一一对应。因此，再设计多线程应用程序时，其功能的实现一定不能依赖于线程的优先级，而只能讲优先级作为一种提高程序效率的手段。</font></p>
<h3 id="线程休眠："><a href="#线程休眠：" class="headerlink" title="线程休眠："></a>线程休眠：</h3><p>如果希望人为地控制线程，使正在执行的线程暂停，将CPU让给别的线程，可以使用<strong>静态方法sleep(long millis)</strong>，该方法可以是当前正在执行的线程暂停一顿时间，在指定时间内进入阻塞状态。</p>
<p>sleep(long millis)方法声明会抛出<strong>InterruptException</strong>异常，因此在调用该方法时应该捕获异常，或者声明抛出该异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">3</span>)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在打印"</span>+i);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task()).start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i==<span class="number">3</span>)&#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在打印"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为两个线程存在休眠，每次一个线程休眠时，另一个线程就会获得执行，所以最后效果是main线程和thread-0线程交替执行打印。</p>
<p><font color=red>sleep()是静态方法，<strong>只能控制当前正在运行的线程休眠，而不能控制其他线程休眠</strong>。当休眠结束后,线程就会返回到就绪状态，而不是立即开始运行。</font></p>
<h3 id="线程让步："><a href="#线程让步：" class="headerlink" title="线程让步："></a>线程让步：</h3><p>如果希望正在执行的线程将CPU资源让给其他线程执行。可以使用<strong>yield()</strong>方法来实现，该方法和sleep()方法有点相似，都可以让当前运行的线程暂停。<strong><u>区别：yield()方法不会阻塞该线程，他只是将线程转换成就绪状态，让系统的调度器重新调度一次。</u></strong>当某个线程调用yield()之后，只有与当前线程优先级相同或者更高的线程才能获得执行的机会。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YieldThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">YieldThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"打印"</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程让步："</span>);</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> YieldThread(<span class="string">"线程A"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> YieldThread(<span class="string">"线程B"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>t1和t2线程优先级相同，开始是分别都有执行，当两个线程的循环遍历等于3时，就会线程让步，另一个线程就会获得执行。</p>
<h3 id="线程插队："><a href="#线程插队：" class="headerlink" title="线程插队："></a>线程插队：</h3><p>Thread类提供了一个<strong>join()</strong>方法来实现插队功能。当某个线程中调用其他线程的join()方法时，调用的线程将被阻塞，直到被join()方法加入的线程执行完成后他才会继续执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"打印:"</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> JoinThread(),<span class="string">"线程一"</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"打印:"</span>+i);</span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">2</span>)&#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main和线程一都有sleep()方法，应该交替执行。但是main线程中在i==2时执行了线程一的join()方法，main就会等待线程一死亡后再继续执行。</p>
<p>join()有三个重载方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span>      </span></span><br><span class="line"><span class="function">     当前线程等该加入该线程后面，等待该线程终止。    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span>  </span></span><br><span class="line"><span class="function">     当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanos)</span>   </span></span><br><span class="line"><span class="function">     等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度</span></span><br></pre></td></tr></table></figure>

<h3 id="后台-守护-线程："><a href="#后台-守护-线程：" class="headerlink" title="后台(守护)线程："></a>后台(守护)线程：</h3><p>守护线程使用的情况较少，但并非无用，举例来说，<strong>JVM的垃圾回收</strong>、<strong>内存管理</strong>等线程都是守护线程。还有就是在做数据库应用时候，使用的<strong>数据库连接池</strong>，连接池本身也包含着很多后台线程，<strong>监控连接个数</strong>、<strong>超时时间</strong>、<strong>状态</strong>等等。调用线程对象的方法<strong>setDaemon(true)</strong>，则可以将其设置为守护线程。守护线程的用途为：</p>
<ul>
<li><p>守护线程通常用于执行一些后台作业，例如在你的应用程序运行时播放背景音乐，在文字编辑器里做自动语法检查、自动保存等功能。</p>
</li>
<li><p>Java的垃圾回收也是一个守护线程。守护线的好处就是你不需要关心它的结束问题。例如你在你的应用程序运行的时候希望播放背景音乐，如果将这个播放背景音乐的线程设定为非守护线程，那么在用户请求退出的时候，不仅要退出主线程，还要通知播放背景音乐的线程退出；如果设定为守护线程则不需要了。</p>
</li>
</ul>
<p><strong>setDaemon方法的详细说明：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。    </span></span><br><span class="line"><span class="comment">//该方法必须在启动线程前调用。 该方法首先调用该线程的 checkAccess 方法，且不带任何参数。</span></span><br><span class="line"><span class="comment">//这可能抛出 SecurityException（在当前线程中）。   </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDaemon</span><span class="params">(<span class="keyword">boolean</span> on)</span> </span>&#123;<span class="comment">//on - 如果为 true，则将该线程标记为守护线程。    </span></span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (isAlive()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">    &#125;</span><br><span class="line">    daemon = on;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color=red>如果该线程处于活动状态。抛出：IllegalThreadStateException 异常。</font></p>
</li>
<li><p><font color=red>如果当前线程无法修改该线程。在当前线程中抛出：SecurityException异常。</font></p>
</li>
</ul>
<p><font color=red><strong>注：</strong>JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台县城时候一定要注意这个问题。</font></p>
<h3 id="正确的结束线程："><a href="#正确的结束线程：" class="headerlink" title="正确的结束线程："></a>正确的结束线程：</h3><p><strong>Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit</strong>这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！！！</p>
<p>想要安全有效的结束一个线程，可以使用下面的方法：</p>
<ul>
<li><p>正常执行完run方法，然后结束掉。</p>
</li>
<li><p>控制循环条件和判断条件的标识符来结束掉线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">boolean</span> next=<span class="keyword">true</span>;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">while</span> (next) &#123;  </span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">10</span>)  </span><br><span class="line">                next=<span class="keyword">false</span>;  </span><br><span class="line">            i++;  </span><br><span class="line">            System.out.println(i);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="线程同步："><a href="#线程同步：" class="headerlink" title="线程同步："></a>线程同步：</h2><p>多线程的并发执行可以提高程序的效率，但是，当多个线程去访问同一个资源时，也会引发一些安全问题。</p>
<p>最开始<strong>”继承Thread类和实现Runnable接口的区别“</strong>讲解部分举了一个售票窗口售票的例子，改为模拟四个窗口出售10张票，并在每次售票后要sleep()10毫秒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (tickets&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"买票："</span>+tickets--);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TicketWindow ticketWindow = <span class="keyword">new</span> TicketWindow();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow,<span class="string">"窗口1"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow,<span class="string">"窗口2"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow,<span class="string">"窗口3"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(ticketWindow,<span class="string">"窗口4"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了预期的10号到1号的票，竟然出现了0号、-1号、-2号车票，这种现象是不应该的，因为售票中做了判断，只有票号大于0时才会售票。</p>
<p>之所以出现了0、-1、-2的情况是因为线程由延迟(sleep()模拟了线程延迟)，假如线程1(窗口1)出售1号票，对票号进行了判断后，进入while循环，在售票前通过sleep()方法让线程休眠，这时线程2(窗口2)会进行售票，因为此时的票号仍为1，因此线程2也会进入循环。同理，4个线程都会进入while循环，休眠结束之后，4个线程都会进行售票(tickets–)，这样就相当于将票号减了4次，导致出现了0、-1这样的票号。</p>
<h3 id="同步代码块："><a href="#同步代码块：" class="headerlink" title="同步代码块："></a>同步代码块：</h3><p>线程安全问题其实就是由<strong>多个线程同时处理共享资源所导致的</strong>。要想解决这样的线程安全问题，<strong>必须得保证处理共享资源的代码在任何时刻只能有一个线程访问。</strong></p>
<p>为了实现这种限制，Java中提供了同步机制。当多个线程使用同一个共享资源时，可以将处理共享资源的代码放在一个使用<strong>synchronized关键字来修饰的代码块中，</strong>这个代码块被称为同步代码块，语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">    <span class="comment">//操作共享资源代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>lock</strong>是一个锁对象，它是同步代码块的关键。当一个线程执行同步代码块时，其他线程将无法执行当前同步代码块，会发生阻塞，当前线程执行完同步代码块后，所有线程开始<strong>抢夺</strong>线程的执行权，抢到执行权的线程将进入同步代码块，执行其中的代码。循环往复，直到共享资源处理完毕。像是公用电话亭，只有前一个人打完电话出来后，其他的人才可以进入。</p>
<p>更改售票代码，Demo类不变，修改TicketWindow类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object lock=<span class="keyword">new</span> Object();<span class="comment">//定义任意一个对象，用作同步代码块的锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"买票："</span>+tickets--);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将有关tickets变量的操作都放到同步代码块中，为了保证线程的持续执行，将代码块放在死循环中，直到tickets&lt;=0时跳出循环。这样就不再出现0和负数的情况了，运行结果往往并不是四个线程都执行了同步代码块，因为线程在获得锁对象时是随机的，运行期间有些线程始终未获得锁对象，所以未能执行同步代码块。</p>
<p><font color=red>同步代码块中的锁对象可以是任意类型的对象，但多个线程共享的锁对象必须是唯一的。“任意”是指锁对象的类型。锁对象的创建不能放到run()方法中，这样每个线程都会创建不同的锁，每个锁都有自己的标志位，这样线程之间便不能产生同步的效果。</font></p>
<p><font color=red><strong>注：</strong>同步是一种高开销的操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchronized代码块同步关键代码即可。</font></p>
<h3 id="同步方法："><a href="#同步方法：" class="headerlink" title="同步方法："></a>同步方法：</h3><p>除了将共享资源的操作放在synchronized定义的区域内，也可以在方法前使用synchronized关键字来修饰，被修饰的方法为同步方法，他能实现和同步代码块相同的功能，语法格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 返回值类型 方法名([参数<span class="number">1</span>，。。。])&#123;。。。&#125;</span><br></pre></td></tr></table></figure>

<p>被synchronized修饰的方法在某一时刻只允许一个线程访问，访问该方法的其他线程都会发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行该方法。</p>
<p><font color=red>由于java的每个对象都有一个<strong>内置锁</strong>，当用synchronized关键字修饰方法时，内置锁会保护整个方法。线程在调用该方法前，需要获得内置锁，否则该线程就会处于阻塞状态。</font></p>
<p><font color=red><strong>同步方法</strong>也有锁，它的锁就是<strong>当前调用该方法的对象</strong>，也就是<strong>this指向的对象</strong>。这样做的好处是：同步方法被所有线程所共享，方法所在的对象相对于所有线程来说是唯一的，从而保证了锁的唯一性。</font></p>
<p><font color=red>同步方法有时候是静态的，静态方法不需要创建对象就可以直接使用，这时<strong>静态同步方法</strong>的锁就不会是这个this，而是<strong>该方法所在的类的class对象</strong>，该对象在装载该类时自动创建，可以用类名.class获取。</font></p>
<p>使用同步方法改造售票程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                sendTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"买票："</span>+tickets--);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red> <strong>注： synchronized关键字也可以修饰静态方法，此时线程如果调用该静态方法，将会锁住整个类。</strong></font></p>
<h3 id="使用特殊域变量-volatile-实现线程同步："><a href="#使用特殊域变量-volatile-实现线程同步：" class="headerlink" title="使用特殊域变量(volatile)实现线程同步："></a>使用特殊域变量(volatile)实现线程同步：</h3><ul>
<li>volatile关键字为域变量的访问提供了一种<strong>免锁机制</strong>；</li>
<li>使用volatile修饰域相当于告诉JVM该域可能会被其他线程更新；</li>
<li>因此每次使用该域就要<strong>重新计算</strong>，而不是使用寄存器中的值；</li>
<li>volatile不会提供任何原子操作，它也<strong>不能用来修饰final类型</strong>的变量；</li>
</ul>
<p><font color=red><strong>注：</strong>多线程中的非同步问题主要出现在对域的读写上，如果让域自身避免这个问题，则就不需要修改操作该域的方法。用<strong>final域</strong>，<strong>有锁保护的域</strong>和<strong>volatile域</strong>可以避免非同步的问题。</font></p>
<h3 id="使用重入锁-Lock-实现线程同步："><a href="#使用重入锁-Lock-实现线程同步：" class="headerlink" title="使用重入锁(Lock)实现线程同步："></a>使用重入锁(Lock)实现线程同步：</h3><p>在JDK5之后增加了一个java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchronized修饰的方法和代码块具有相同的基本行为和语义，并且扩展了其能力。ReenreantLock类的常用方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReentrantLock(); <span class="comment">//创建一个ReentrantLock实例</span></span><br><span class="line">lock();	<span class="comment">//获得锁</span></span><br><span class="line">unlock(); <span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>

<p><font color=red><strong>注：</strong>ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用。</font></p>
<p>之前同步方法实现的售票程序，可以改为用重入锁实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//和同步代码块一样，锁的声明要在执行的代码外</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                sendTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();<span class="comment">//抢到执行权的线程获得锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">20</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"买票："</span>+tickets--);</span><br><span class="line">            lock.unlock();<span class="comment">//每次售票后就释放锁</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="线程通信："><a href="#线程通信：" class="headerlink" title="线程通信："></a>线程通信：</h2><h3 id="Object类的wait-、notify-和notifyAll-实现通信："><a href="#Object类的wait-、notify-和notifyAll-实现通信：" class="headerlink" title="Object类的wait()、notify()和notifyAll()实现通信："></a>Object类的wait()、notify()和notifyAll()实现通信：</h3><p>线程执行wait()之后，就放弃了运行资格处于阻塞状态，JVM会把该线程放入等待池中。等待池中的线程不会像锁池中的线程一样自动唤醒，要等待其他线程的notify()或者notifyAll()唤醒该线程并将该线程放入锁池中。</p>
<p>wait()、notify()和notifyAll()，在使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；而锁可以是任意对象，所以这三个方法都是Object类中的方法。</p>
<p><font color=red><strong>注:</strong>等待池中的线程被notify()或者notifyAll()方法唤醒进入到锁池，最后竞争到了锁并且进入了Running状态的话，会从wait现场恢复，执行wait()方法之后的代码。</font></p>
<h3 id="使用Condition控制线程通信："><a href="#使用Condition控制线程通信：" class="headerlink" title="使用Condition控制线程通信："></a>使用Condition控制线程通信：</h3><p>JDK5中，提供了很多线程的升级解决方案：</p>
<ol>
<li>将同步synchronized替换为显式的Lock操作；</li>
<li>将Object类中的wait()、notify()和notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取；</li>
<li>一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而JDK5之前一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。</li>
</ol>
<h3 id="使用阻塞队列控制线程通信："><a href="#使用阻塞队列控制线程通信：" class="headerlink" title="使用阻塞队列控制线程通信："></a>使用阻塞队列控制线程通信：</h3><p> BlockingQueue是一个接口，也是Queue的子接口。<strong>BlockingQueue具有一个特征：</strong>当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则线程被阻塞；但消费者线程试图从BlockingQueue中取出元素时，如果队列已空，则该线程阻塞。程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。</p>
<p><strong>BlockingQueue提供如下两个支持阻塞的方法：</strong></p>
<p>  <strong>（1）put(E e)：</strong>尝试把Eu元素放如BlockingQueue中，如果该队列的元素已满，则阻塞该线程。</p>
<p>  <strong>（2）take（）：</strong>尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程。</p>
<p><strong>BlockingQueue继承了Queue接口，当然也可以使用Queue接口中的方法，这些方法归纳起来可以分为如下三组：</strong></p>
<p>  <strong>（1）</strong>在队列尾部插入元素，包括add（E e）、offer（E e）、put（E e）方法，当该队列已满时，这三个方法分别会抛出异常、返回false、阻塞队列。</p>
<p>  <strong>（2）</strong>在队列头部删除并返回删除的元素。包括remove（）、poll（）、和take（）方法，当该队列已空时，这三个方法分别会抛出异常、返回false、阻塞队列。</p>
<p>  <strong>（3）</strong>在队列头部取出但不删除元素。包括element（）和peek（）方法，当队列已空时，这两个方法分别抛出异常、返回false。</p>
<p><strong>BlockingQueue接口包含如下5个实现类：</strong></p>
<ul>
<li><strong>ArrayBlockingQueue</strong> ：基于数组实现的BlockingQueue队列。</li>
<li><strong>LinkedBlockingQueue</strong>：基于链表实现的BlockingQueue队列。</li>
<li><strong>PriorityBlockingQueue</strong>：它并不是保准的阻塞队列，该队列调用remove（）、poll（）、take（）等方法提取出元素时，并不是取出队列中存在时间最长的元素，而是队列中最小的元素。它判断元素的大小即可根据元素（实现Comparable接口）的本身大小来自然排序，也可使用Comparator进行定制排序。</li>
<li><strong>SynchronousQueue</strong>：同步队列。对该队列的存、取操作必须交替进行。</li>
<li><strong>DelayQueue</strong>：它是一个特殊的BlockingQueue，底层基于PriorityBlockingQueue实现，不过，DelayQueue要求集合元素都实现Delay接口（该接口里只有一个long getDelay（）方法），DelayQueue根据集合元素的getDalay（）方法的返回值进行排序。</li>
</ul>
<hr>
<h2 id="线程池："><a href="#线程池：" class="headerlink" title="线程池："></a>线程池：</h2><p>合理使用线程池能够带来三个好处：</p>
<ol>
<li><strong>降低资源消耗。</strong>通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度。</strong>当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性。</strong>线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ol>
<p><u>具体的先不做总结，等遇到应用场景时再做记录</u>。大致产生线程池的方法有：<strong>使用Executors工厂类</strong>、<strong>使用Java8增强的ForkJoinPool</strong>等等。。</p>
<hr>
<h2 id="死锁："><a href="#死锁：" class="headerlink" title="死锁："></a>死锁：</h2><p>两个人A和B进行交易，A说：“我等你的钱到了，我再给你货！”，B说：“我等你的货到了，我再给你钱。”。。。如果不进行干预，结果肯定是无限的等下去。。。</p>
<p>例子中，A和B相当于不同的线程，钱和货相当于锁。两个线程运行时都在等待对方的锁，这样就造成了双方的停滞。这种现象就是死锁。</p>
<h3 id="死锁的四个条件："><a href="#死锁的四个条件：" class="headerlink" title="死锁的四个条件："></a>死锁的四个条件：</h3><ul>
<li>互斥条件：资源不能被共享，只能被同一个进程使用。</li>
<li>请求与保持条件：已经得到资源的进程可以申请新的资源。</li>
<li>非剥夺条件：已分配的资源不能从相应的进程中被强制剥夺。</li>
<li>循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源。</li>
</ul>
<h3 id="处理死锁的一般思路："><a href="#处理死锁的一般思路：" class="headerlink" title="处理死锁的一般思路："></a>处理死锁的一般思路：</h3><ul>
<li>忽略问题！即鸵鸟算法，当发生了什么问题时，不管他，直接跳过，无视它。</li>
<li>检测死锁并恢复。</li>
<li>资源进行动态分配。</li>
<li>破除上面的四种死锁条件之一。</li>
</ul>
<hr>
<p>编写时参考目录：<a href="https://blog.csdn.net/qq_22498277/article/details/82184419?utm_source=copy" target="_blank" rel="noopener">雪飘雪融</a>、<a href="https://www.cnblogs.com/snow-flower/p/6114765.html" target="_blank" rel="noopener">snow_flower</a>、<a href="https://blog.csdn.net/zhaojunwei666/article/details/96433488" target="_blank" rel="noopener">程序员的买房梦</a></p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多继承问题</title>
    <url>/2020/03/15/Java%E5%A4%9A%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>长期被诟病的多继承，不仅仅是Java语言所头疼的问题。多继承是一个较为复杂的设计问题，使用中很容易出现致命的问题。像Goto语句一样，利弊交织。<a id="more"></a></p>
<blockquote>
<p>很多技术伟人已经提供了多套解决方案例如：<strong>传统模式</strong>(深度优先，每个类以第一次出现的位置为准)，但是遇到菱形继承就bug了。<strong>new-style class</strong>曾应用于python2.2中，和Java使用的策略很相似仍然使用深度优先搜索、从左向右，但是每个类选择其最后一次出现的位置，解决了菱形继承的bug但是交叉继承依旧bug。 <strong>C3算法</strong>提供了一个基于层级计算的线性MRO算法，被称为C3，整体上比较合理了。 在2012年被加入了Dylan语言，2007年加入了Python2.3后来又被应用于更多的语言，虽然计算问题解决了，但是依然存在一些难以理解的问题：</p>
<p><img src="https://s2.ax1x.com/2019/08/21/mNbgw4.jpg" alt="mNbgw4.jpg"></p>
<p>引见： <a href="http://python-history.blogspot.jp/2010/06/method-resolution-order.html" target="_blank" rel="noopener">python-history</a>、<a href="https://www.zhihu.com/question/21476063" target="_blank" rel="noopener">知乎</a>、<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">python.org</a></p>
</blockquote>
<h1 id="Java编程中可选的解决方法"><a href="#Java编程中可选的解决方法" class="headerlink" title="Java编程中可选的解决方法"></a>Java编程中可选的解决方法</h1><p>原则上Java是不允许多继承的，但是在编程中依然存在一些方法来模拟实现多继承：</p>
<h3 id="多层继承"><a href="#多层继承" class="headerlink" title="多层继承"></a>多层继承</h3><p>ABCD四个类，B继承A，C继承B，D继承C，然后通过D的对象调用父类们的方法。</p>
<p>建议一般不要超过三次，缺点很明显，代码冗余，一点也不优雅。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>不写演示了，相对于多层继承，就是把ABC三个类的继承工作放到D类中，用A1、B1、C3三个内部类分别继承ABC三个类，然后写A1、B1、C1调用方法，直接new内部类对象调用其方法。</p>
<p>相对于多层继承，内部类继承的方式将所有的继承都放在一个类中，阅读性增加。但是缺点依然没有太好的改善：代码冗余，依然不够优雅。</p>
<h3 id="接口-推荐"><a href="#接口-推荐" class="headerlink" title="接口(推荐)"></a>接口(推荐)</h3><blockquote>
<p>Java的接口继承功能，<strong>既实现了静态语言的多重继承性，又避免了多重继承的数据构造的冲突和类层次的复杂性。</strong><br>但是，我们并不能说接口是解决问题的完美方案。<strong>接口也有不能共享实现的缺点。</strong><br><u>本来只是为了跨越继承层次来共享代码，现在却需要另外生成一个独立对象，而且每次方法调用都要委派给这个对象，这实在是不太合理，而且执行的效率也不高。</u></p>
<p>——《松本行弘的程序世界》</p>
<blockquote>
<p><em>松本行弘在Ruby中选择了Mix-in方案来解决多继承问题。</em></p>
</blockquote>
</blockquote>
<p>通过松本行弘的话大概明白了接口继承的部分优劣性，Java中也确实是这么做的，接口继承虽然将问题抛给了使用者大大增加了工作量，但是也切实有效的避免了很大一部分问题。<strong>有取必有舍</strong>。 </p>
<p>一个类只能extends一个父类，但可以implements多个接口。java通过使用接口的概念来取代C++中多继承。与此同时，一个接口则可以同时extends多个接口，却不能implements任何接口。因而，<strong>Java中的接口是支持多继承的。</strong> </p>
<p>接口实现多继承还有一个好处：<strong>这样可以把子类利用多态赋给多个父类（接口），而把主要的方法使用组合封装起来而避免多次实现接口的方法。</strong> </p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>多继承</tag>
      </tags>
  </entry>
  <entry>
    <title>java.util.Date和java.sql.Date区别</title>
    <url>/2020/03/15/java.util.Date%E5%92%8Cjava.sql.Date%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<ol>
<li><p>java.util.Date是在除了SQL语句的情况下面使用的。java.sql.Date是针对SQL语句使用的。<a id="more"></a></p>
</li>
<li><p>java.util.Date 类型写到数据库后存储的值可以到秒，java.sql.Date 类型的写入后只能到日期。</p>
</li>
<li><p>java.util.Date 是 java.sql.Date 的父类，前者是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他，后者之后在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date。</p>
</li>
</ol>
<p>直接上实验代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.sql.Date;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   </span><br><span class="line">      	java.util.Date nowUtil =newjava.util.Date();<span class="comment">// java.util.Date</span></span><br><span class="line">     	java.sql.Date nowSql=newjava.sql.Date(System.curretTimeMillis());<span class="comment">//java.sql.Date</span></span><br><span class="line">  	 	SimpleDateFormatformat=newSimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">       </span><br><span class="line">      	System.out.println(format.format(nowUtil));<span class="comment">//格式化 输出</span></span><br><span class="line">        System.out.println(format.format(nowSql));<span class="comment">//格式化 输出</span></span><br><span class="line">        System.out.println(nowUtil); <span class="comment">//直接 输出</span></span><br><span class="line">        System.out.println(nowSql);  <span class="comment">//直接 输出</span></span><br><span class="line">      </span><br><span class="line">  &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码输出结果：</p>
<p>2017-11-13 14:10:03<br>        2017-11-13 14:10:03<br>        Mon Nov 13 14:10:03 CST 2017<br>        2017-11-13</p>
]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>日期类</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效数字</title>
    <url>/2020/03/14/LeetCode-%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>什么是面向测试编程？试试本题就知道了！</p>
<h2 id="NO-65-有效数字-困难"><a href="#NO-65-有效数字-困难" class="headerlink" title="NO.65 有效数字 困难 "></a>NO.65 有效数字 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8Q6Wd0.png" alt="8Q6Wd0.png"></p>
<p>没有get到这道题目的点，这样的题目很搞心态。尤其是看了<a href="https://leetcode.com/problems/valid-number/discuss/23977/A-clean-design-solution-By-using-design-pattern" target="_blank" rel="noopener">作者的解答</a>之后更懵逼了，作者使用了责任链的设计模式，从来没想到解算法题还能用到设计模式。大牛的思维方式就适合我不一样，解个算法题都能考虑到扩展性和复用性。</p>
<h3 id="思路一：暴力法"><a href="#思路一：暴力法" class="headerlink" title="思路一：暴力法"></a><strong><font color=red>思路一：暴力法</font></strong></h3><p>按序遍历字符串，逐位判断是否合法。注意要去除首尾空格。</p>
<p>这种方法就是比较恶心，很容易有考虑不到的情况。</p>
<p>而且测试用例中有：”.1”、”.2”、”+.8”、”46.”、”2e0”等等，预期输出都是true。真的恶心到了。。。</p>
<p>切身感受什么是面向测试编程！！！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="keyword">if</span> (s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> pointSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 .</span></span><br><span class="line">    <span class="keyword">boolean</span> eSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 e</span></span><br><span class="line">    <span class="keyword">boolean</span> numberSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 0-9</span></span><br><span class="line">    <span class="keyword">boolean</span> numberAfterE = <span class="keyword">true</span>;<span class="comment">//e之后是否出现 0-9</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'0'</span> &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= <span class="string">'9'</span>) &#123;<span class="comment">//当前元素是数字</span></span><br><span class="line">            numberSeen = <span class="keyword">true</span>;</span><br><span class="line">            numberAfterE = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'.'</span>) &#123;<span class="comment">//当前元素是 .</span></span><br><span class="line">            <span class="keyword">if</span>(eSeen || pointSeen) &#123;<span class="comment">//已经出现过 e或者.，则非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pointSeen = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'e'</span>) &#123;<span class="comment">//当前元素 e</span></span><br><span class="line">            <span class="keyword">if</span>(eSeen || !numberSeen) &#123;<span class="comment">//已经出现过 e或者e之前没出现过数字，则非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numberAfterE = <span class="keyword">false</span>;<span class="comment">//注意这点很重要，现在开始记录e之后是否有数字</span></span><br><span class="line">            eSeen = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'-'</span> || s.charAt(i) == <span class="string">'+'</span>) &#123;<span class="comment">//当前元素是-或+</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) != <span class="string">'e'</span>) &#123;<span class="comment">//如果-或+不是第一个元素 或者 之前不是 e</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//当前元素不是0-9、. 、e 、- 、+，非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否有数字并且e之后也有数字</span></span><br><span class="line">    <span class="keyword">return</span> numberSeen &amp;&amp; numberAfterE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>写完暴力法，忍不住给下面这个骚操作点了个赞 : )</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            key=float(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="思路二：确定有限自动机-DFA"><a href="#思路二：确定有限自动机-DFA" class="headerlink" title="思路二：确定有限自动机(DFA)"></a><strong><font color=red>思路二：确定有限自动机(DFA)</font></strong></h3><p>下面搬运自leetcode社区windliang，我不是大佬，我只是大佬的搬运工。</p>
<p>先画出状态转换图：</p>
<p><img src="https://s1.ax1x.com/2020/03/14/8QIq3t.png" alt="8QIq3t.png"></p>
<p>如上图，从 0 开始总共有 9 个状态，橙色代表可接受状态，也就是表示此时是合法数字。总共有四大类输入，数字，小数点，e 和 正负号。我们只需要将这个图实现就够了。</p>
<p>这种方式思路清晰多了，但是之前没有接触过这种方法实现起来还是很生疏的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">0</span>;<span class="comment">//当前状态</span></span><br><span class="line">    s = s.trim();<span class="comment">//去除头尾的空格</span></span><br><span class="line">    <span class="comment">//遍历所有字符，当做输入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line">                <span class="comment">//输入正负号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                    state = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">4</span>) &#123;</span><br><span class="line">                    state = <span class="number">6</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//输入数字</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'6'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'7'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'9'</span>:</span><br><span class="line">                <span class="comment">//根据当前状态去跳转</span></span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        state = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        state = <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                        state = <span class="number">5</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                        state = <span class="number">8</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                        state = <span class="number">8</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//小数点</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        state = <span class="number">7</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        state = <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//e</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                        state = <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//橙色部分的状态代表合法数字</span></span><br><span class="line">    <span class="keyword">return</span> state == <span class="number">2</span> || state == <span class="number">3</span> || state == <span class="number">5</span> || state == <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h3 id="思路三：责任链模式"><a href="#思路三：责任链模式" class="headerlink" title="思路三：责任链模式"></a><strong><font color=red>思路三：责任链模式</font></strong></h3><p>解法二看起来已经很清晰明了了，只需要把状态图画出来，然后实现代码就很简单了。但是缺点是，如果状态图少考虑了东西，再改起来就会很麻烦。</p>
<p>这里作者提出来，利用责任链的设计模式，会使得写出的算法扩展性以及维护性更高。这里用到的思想就是，每个类只判断一种类型。比如判断是否是正数的类，判断是否是小数的类，判断是否是科学计数法的类，这样每个类只关心自己的部分，出了问题很好排查，而且互不影响。</p>
<p>虽然代码变多了，但是维护性，扩展性变的很强了。比如，题目新增了一种情况，”0x123” 16 进制也算是合法数字。这样的话，解法一和解法二就没什么用了，完全得重新设计。但对于解法三，我们只需要新增一个类，专门判断这种情况，然后加到执行者的数组里就够了，很牛逼！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个类都实现这个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NumberValidate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个抽象类，用来检查一些基础的操作，是否为空，去掉首尾空格，去掉 +/-</span></span><br><span class="line"><span class="comment">//doValidate 交给子类自己去实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>  <span class="title">NumberValidateTemplate</span> <span class="keyword">implements</span> <span class="title">NumberValidate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkStringEmpty(s))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = checkAndProcessHeader(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doValidate(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkStringEmpty</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">checkAndProcessHeader</span><span class="params">(String value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = value.trim();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value.startsWith(<span class="string">"+"</span>) || value.startsWith(<span class="string">"-"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            value = value.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是整数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String integer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integer.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(integer.charAt(i)) == <span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是科学计数法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SienceFormatValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> pos = s.indexOf(<span class="string">"e"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String first = s.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String second = s.substring(pos+<span class="number">1</span>, s.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validatePartBeforeE(first) == <span class="keyword">false</span> || validatePartAfterE(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePartBeforeE</span><span class="params">(String first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.equals(<span class="string">""</span>) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHeadAndEndForSpace(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate integerValidate = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        NumberValidate floatValidate = <span class="keyword">new</span> FloatValidate();</span><br><span class="line">        <span class="keyword">if</span> (integerValidate.validate(first) == <span class="keyword">false</span> &amp;&amp; floatValidate.validate(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkHeadAndEndForSpace</span><span class="params">(String part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (part.startsWith(<span class="string">" "</span>) ||</span><br><span class="line">            part.endsWith(<span class="string">" "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePartAfterE</span><span class="params">(String second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (second.equals(<span class="string">""</span>) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHeadAndEndForSpace(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate integerValidate = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        <span class="keyword">if</span> (integerValidate.validate(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是小数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String floatVal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = floatVal.indexOf(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (floatVal.length() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        String first = floatVal.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String second = floatVal.substring(pos + <span class="number">1</span>, floatVal.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkFirstPart(first) == <span class="keyword">true</span> &amp;&amp; checkFirstPart(second) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkFirstPart</span><span class="params">(String first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.equals(<span class="string">""</span>) == <span class="keyword">false</span> &amp;&amp; checkPart(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPart</span><span class="params">(String part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(part.charAt(<span class="number">0</span>)) == <span class="keyword">false</span> ||</span><br><span class="line">            Character.isDigit(part.charAt(part.length() - <span class="number">1</span>)) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        <span class="keyword">if</span> (nv.validate(part) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个执行者，我们把之前实现的各个类加到一个数组里，然后依次调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberValidator</span> <span class="keyword">implements</span> <span class="title">NumberValidate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;NumberValidate&gt; validators = <span class="keyword">new</span> ArrayList&lt;NumberValidate&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberValidator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        addValidators();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">addValidators</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line"></span><br><span class="line">        nv = <span class="keyword">new</span> FloatValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//nv = new HexValidate();</span></span><br><span class="line">        <span class="comment">//validators.add(nv);</span></span><br><span class="line"></span><br><span class="line">        nv = <span class="keyword">new</span> SienceFormatValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (NumberValidate nv : validators)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nv.validate(s) == <span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    NumberValidate nv = <span class="keyword">new</span> NumberValidator();</span><br><span class="line">    <span class="keyword">return</span> nv.validate(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>确定有限自动机</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%20%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="NO-20-有效括号-简单"><a href="#NO-20-有效括号-简单" class="headerlink" title="NO.20 有效括号 简单 "></a>NO.20 有效括号 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFVldS.png" alt="lFVldS.png"></p>
<p><font color=red><strong>思路一：栈</strong></font>  学校的数据结构课就是那这个作为例子来引入栈结构的。1. 遍历表达式中每个字符，如果是’(‘或’[]’或’{‘就放入栈中。2. 如果是’)’或’]’或’}’就弹出栈顶字符top，如果此时栈为空或者将此时被遍历字符和top不匹配，则说明表达式无效。3. 遍历完所有字符，检查栈是否为空，如果不为空则表达式无效，反之有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//        用hashmap存储括号对</span></span><br><span class="line">        HashMap&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line"><span class="comment">//        用栈来保存遍历到的'(' '[' '&#123;'</span></span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"><span class="comment">//            如果map中没有c这个key，则说明c是(或[或&#123;,就存入栈中（题目说只有六种字符）</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c))&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果存在c这个key则说明，c是)或]或&#125;，就需要去和栈顶字符进行匹配</span></span><br><span class="line"><span class="comment">//                如果栈为空，则无法匹配</span></span><br><span class="line">                <span class="keyword">if</span> (stack.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//                取出栈顶元素</span></span><br><span class="line">                Character top = stack.pop();</span><br><span class="line"><span class="comment">//                如果map中c的value和栈顶元素top不相等，则无法匹配</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(c)!=top)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        遍历完所有字符之后，检查栈是否为空，如果为空则匹配，反之无法匹配</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长上升子序列</title>
    <url>/2020/03/14/LeetCode-%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-300-最长上升子序列-中等"><a href="#NO-300-最长上升子序列-中等" class="headerlink" title="NO.300 最长上升子序列 中等 "></a>NO.300 最长上升子序列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8QQPq1.png" alt="8QQPq1.png"></p>
<p>刚看到题，我以为寻找的这个上升子序列需要是连续的递增元素，所以我想双指针。发现行不通，重新审题发现，示例中的子序列元素不是连续的。。。</p>
<h3 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a><strong><font color=red>思路一：动态规划</font></strong></h3><p>dp数组含义：dp[i]nums前i个元素中最长上升子序列的长度。</p>
<p>初始化：初始状态全部为1，因为每个元素自身至少是长度为1子序列。</p>
<p>状态转移：填写dp[i]时遍历j∈[0,i，</p>
<p>如果i元素&gt;j元素则当前元素i可以接在j元素之后作为上升子序列dp[i]=Max(dp[i],dp[j]+1)；</p>
<p>否则i元素&lt;=j元素当前元素i不能拼接在j元素之后就忽略。</p>
<p>每次填写完dp[i]更新当前最长上升子序列长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">//如果i元素&gt;j元素，则i可以接在j元素后面作为上升子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[j])dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最大长度</span></span><br><span class="line">        maxLen=Math.max(maxLen,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h3 id="思路二：TreeSet"><a href="#思路二：TreeSet" class="headerlink" title="思路二：TreeSet"></a><strong><font color=red>思路二：TreeSet</font></strong></h3><p>JAVA Api中的TreeSet有ceiling(x)方法，取大于x的数，如果不存在则返回null。(此方法时间复杂度O(logn)，但是最坏情况下会退化到O(n))</p>
<p>按序遍历nums，到TreeSet中取大于num的数x，如果存在x则删除x并将num加入set，如果不存在就是所有的数都小于num就将num加入set。</p>
<p>最后返回set的大小即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TreeSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        Integer x = set.ceiling(num);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.remove(x);</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏时间复杂度仍然是：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——N皇后II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20N%E7%9A%87%E5%90%8EII/</url>
    <content><![CDATA[<h2 id="NO-52-N皇后II-困难"><a href="#NO-52-N皇后II-困难" class="headerlink" title="NO.52 N皇后II 困难 "></a>NO.52 N皇后II <font color=#ff0099>困难</font> <a id="more"></a></h2><p>NO.52是NO.51的姊妹题，区别在于NO.51要求返回包含”棋子摆放”的List&lt;List&lt;String&gt;&gt;集合，而本题NO.52只需要返回一共有多少种摆法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO.51:public List&lt;List&lt;String&gt;&gt; solveNQueens(int n)</span><br><span class="line">NO.52:public int totalNQueens(int n)</span><br></pre></td></tr></table></figure>

<p><strong><font color=red>思路一：回溯法</font></strong> 看到题的第一反应是直接把上一题回溯法的终止处理”res.add”改成”计数器+1”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//棋盘,默认为0表示空，1表示皇后</span></span><br><span class="line">    <span class="keyword">int</span>[][] board=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//row当前填写得的行号</span></span><br><span class="line">    dfs(n,<span class="number">0</span>,board);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0~n-1都填写完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==n)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsable(board,row,col))&#123;</span><br><span class="line">            board[row][col]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//填写下一行</span></span><br><span class="line">            dfs(n,row+<span class="number">1</span>,board);</span><br><span class="line">            board[row][col]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//board[row][col]是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUsable</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查列上有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查左上至右下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+row-col&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i+row-col][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查右上至左下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row+col-i&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row+col-i][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——Z字形变换</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="NO-6-Z字形变换-中等"><a href="#NO-6-Z字形变换-中等" class="headerlink" title="NO.6 Z字形变换 中等 "></a>NO.6 Z字形变换 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/10/QDB5TA.png" alt="QDB5TA.png"></p>
<p><font color=red><strong>思路一：按列写，按行读</strong></font> 将原字符串按列写成”Z字形”，写好之后按行读取“Z字形”。1.先创建一个有min(numRows,len(s))个元素的list，且list的每个元素都是一个StringBuilder。2.用两个变量分别记录当前是第几行和当前的方向。3.然后将参数字符串中的字符逐一填入。4.仅当前行等于list的第一个参数下标0或者等于numRows-1时方向改变。</p>
<p>这个思路很类似我们动手在纸上将参数字符串写成Z字形的过程，将所有字符逐一写出，在第一行写字符之后写字符的方向变为向下写，在最后一行（numRows）写字符之后写字符的方向变为向上写。当全部写完之后，按行将字符串读出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        List&lt;StringBuilder&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Math.min(numRows,s.length());i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        定义一个变量记录方向，向下为false，向上为true</span></span><br><span class="line">        <span class="keyword">boolean</span> goingDown=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        记录当前是第几行</span></span><br><span class="line">        <span class="keyword">int</span> currentRow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            list.get(currentRow).append(c);</span><br><span class="line"><span class="comment">//            如果当前行下标是第一行或者是最后一行，就改变方向标识</span></span><br><span class="line">            <span class="keyword">if</span> (currentRow==<span class="number">0</span>||currentRow==numRows-<span class="number">1</span>)goingDown=!goingDown;</span><br><span class="line"><span class="comment">//            行下标向当前方向移动，如果true就+1向下移动，如果是false就-1向上移动</span></span><br><span class="line">            currentRow+=goingDown?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        按行读取，获取最后的输出结果</span></span><br><span class="line">        StringBuilder ret=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder stringBuilder : list) &#123;</span><br><span class="line">            ret.append(stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red><strong>思路二：直接按行访问</strong></font>  直接按照将参数字符串写成Z字形之后的结构进行按行访问拼接到结果字符串中。经过观察，可以发现如下规律：对于所有的行i和结果字符串中的字符索引k都有，1. 行0中的字符位于原字符串的k(2*numRows-2)索引处。 2. 行numRows-1中的字符位于原字符串的k(2*numRows-2)+numRows-1索引处。3. 内部的行i中的字符位于原字符串的k(2*numRows-1)+i以及(k+1)(2*numRows-2)-i索引处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> len=s.length();</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//        一个循环长度（Z字形两次方向变换，即向下写到numRows行方向变化为向上再写到0行的长度）</span></span><br><span class="line">    <span class="keyword">int</span> cycleLen=<span class="number">2</span>*numRows-<span class="number">2</span>;</span><br><span class="line"><span class="comment">//        0-numRows行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;len;j+=cycleLen)&#123;</span><br><span class="line">            ans.append(s.charAt(j+i));</span><br><span class="line"><span class="comment">//     当不是第0行且不是第numRows-1行且当前行下一个字符在原字符串中存在时，将当前行下一个字符加入结果串</span></span><br><span class="line"><span class="comment">//                防止遗漏中间行的字符</span></span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>&amp;&amp;i!=numRows-<span class="number">1</span>&amp;&amp;j+cycleLen-i&lt;len)</span><br><span class="line">                ans.append(s.charAt(j+cycleLen-i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——买卖股票的最佳时机</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="NO-121-买卖股票的最佳时机-简单"><a href="#NO-121-买卖股票的最佳时机-简单" class="headerlink" title="NO.121 买卖股票的最佳时机 简单 "></a>NO.121 买卖股票的最佳时机 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/09/3zzoW9.png" alt="3zzoW9.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 没什么好说的，双重循环计算所有元素两两组合相减的结果，取最大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            maxProfit=Math.max(maxProfit,prices[j]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><strong><font color=red>思路二：优化暴力法到一次遍历</font></strong> 买卖股票从第二天开始我们每天都会”后悔”：后悔没有在之前的最低点进行买入，只有这样我们的收益才会最大化。</p>
<p>由此可见，我们想要当天利益最大化，只需要在过去的某个最低点买入股票就好。所以我们只需要记录曾经出现过的最低点就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minPoint=Integer.MAX_VALUE,maxProfit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">//记录曾出现过最低点</span></span><br><span class="line">        minPoint=Math.min(prices[i],minPoint);</span><br><span class="line">        <span class="comment">//当日-曾经的最低</span></span><br><span class="line">        maxProfit=Math.max(maxProfit,prices[i]-minPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>从NO.121题不难看出：<strong><font color=red>买股票的最佳时机是曾经！股市有风险，入股需谨慎！</font></strong>(狗头)</p>
<p>单纯的解答本题是比较简单的，但是买卖股票可以算作是一个系列的经典问题，在leetcode上就有本题一系列的变种问题：买卖股票的最佳时机、买卖股票的最佳时机II、买卖股票的最佳时机III、买卖股票的最佳时机IV、买卖股票的最佳时机含冷冻期、买卖股票的最佳时机含手续费。</p>
<p>虽然这些题有难有易，但是既然是一类问题，就有这一些通用的方法。</p>
<p>这六个问题都是由第四个问题简化变种而来的，第四题相较于本题多了一个参数k，限制只能进行k次交易；第一题也就是本题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种。</p>
<p>之后记一下笔记总结一下这几个问题。</p>
<p>目前找到了”labuladong”大佬的公众号写的一篇《一个方法团灭 6 道股票问题》题解，打算先学习在总结。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——Pow(x,n)</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20Pow(x,n)/</url>
    <content><![CDATA[<h2 id="NO-50-Pow-x-n-中等"><a href="#NO-50-Pow-x-n-中等" class="headerlink" title="NO.50 Pow(x,n) 中等 "></a>NO.50 Pow(x,n) <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/07/1gKljg.png" alt="1gKljg.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 这道题暴力法是不能通过leetcode判题机，会得到一个t。但是方法本身是可以得到正确答案的，所以我们需要对他进行优化。暴力法的想法很简单的：2^3=2*2*2。</p>
<p>如果n为负，则n=-n同时x=1/x，例如2^(-3)=1/2*1/2*1/2。但是这里要注意n的取值范围，主要是 正整数和负整数的不同范围限制 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> N=n;</span><br><span class="line">    <span class="keyword">if</span> (N&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        N=-N;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        ans*=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：二分法</font></strong> 当我们得到x^(n/2)的时候，我们不需要再去乘上n/2个x了，而是x^(n/2)*x^(n/2)=x^n。</p>
<p>这个想法用递归很容易实现，但是需要注意的是n的奇偶性，如果n为奇数则需要再乘上一个x。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> half=myPow(x,n/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//奇偶性处理</span></span><br><span class="line">    <span class="keyword">double</span> rest=myPow(x,n%<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> half*half*rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——第K个排列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E7%AC%ACK%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-60-第K个排列-中等"><a href="#NO-60-第K个排列-中等" class="headerlink" title="NO.60 第K个排列 中等 "></a>NO.60 第K个排列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/08/3x0skq.png" alt="3x0skq.png"></p>
<p><strong><font color=red>思路一：逆用康托展开</font></strong> 什么是康托展开式可以先从百度了解。本文直接从示例着手。</p>
<p>利用康托展开求排列是第几个，例如”213”是n=3的全排列中的第几个？<img src="https://s2.ax1x.com/2020/03/08/3x5LgH.png" alt="3x5LgH.png"></p>
<p>其实就是找出比”213”小的排列有几个，然后+1。</p>
<p>先比较首位，比2小的只有1，1开头的排列有1*2!个。</p>
<p>第二位比1小的不存在所以有0*1!排列。</p>
<p>第三位比3小的有1和2但是前面已经用过所以有0*0!个。</p>
<p>综上所述，有2个比”213”小的排列，所以”213”排在第3位。</p>
<p><strong>本题是逆用，知道n和第k个，求排列本身。</strong></p>
<p>例如：要找n=5，k=35的排列。共有5!=120个排列，从小到大要找第35个排列。</p>
<p>从首位开始找，首位分别是1、2、3、4、5的排列分成五组，每组各有(5-1)!=24个，由于k=35，所以要找的排列在第二组中，就是首位是2开头的24个排列中，即目标排列首位是”2”。</p>
<p>再看第二位，第二位可能是1、3、4、5分成四组，每组分别有(5-2)!=6个，由于k-24=11，所以要找的排列在第二组中，即目标排列的前两位是”23”。</p>
<p>同理，第三位可能是1、4、5分成三组，每组分别有(5-3)!=2个，因为k-6=5，所以要找的排列在第三组的两个排列中，即目标排列的前三位是”235”。</p>
<p>再然后第四位可能是1、4，分两组各有(5-4)!=1个，因为k-4=1，所以在第一组，即目标排列的前四位是”2351”。</p>
<p>最后第五位只剩下4，所以目标排列是”23514”。</p>
<p>找到第35个排列。</p>
<p><strong>其实这个方法就是分组，上例中找第一位时候将有序全排列按照首位数字分为5组，看看我们要找的那个排列在第几组中从而确定了首位数字。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//所有可用数字</span></span><br><span class="line">    StringBuilder map=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)map.append(i);</span><br><span class="line">    <span class="keyword">int</span> groupId,index=n;</span><br><span class="line">    <span class="comment">//逐位确定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//确定在当前分组的第几组</span></span><br><span class="line">        groupId=(k-<span class="number">1</span>)/foc(index);</span><br><span class="line">        <span class="comment">//得到分组的数字，移除使用过的数字</span></span><br><span class="line">        ans.append(map.charAt(groupId));</span><br><span class="line">        map.deleteCharAt(groupId);</span><br><span class="line">        <span class="comment">//更新k</span></span><br><span class="line">        k-=groupId*foc(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求 i!</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">foc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        x*=i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)    题目说n的范围[1,9]，可以直接将1~9的阶乘预先保存在一个数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//0~9的阶乘,直接使用</span></span><br><span class="line">    <span class="keyword">int</span> factor[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;</span><br><span class="line">    <span class="comment">//所有可用数字</span></span><br><span class="line">    StringBuilder map=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)map.append(i);</span><br><span class="line">    <span class="keyword">int</span> groupId,index=n;</span><br><span class="line">    <span class="comment">//逐位确定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//确定在当前分组的第几组</span></span><br><span class="line">        groupId=(k-<span class="number">1</span>)/factor[index];</span><br><span class="line">        <span class="comment">//得到分组的数字，移除使用过的数字</span></span><br><span class="line">        ans.append(map.charAt(groupId));</span><br><span class="line">        map.deleteCharAt(groupId);</span><br><span class="line">        <span class="comment">//更新k</span></span><br><span class="line">        k-=groupId*factor[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>康托展开式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——解数独</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="NO-37-解数独-困难"><a href="#NO-37-解数独-困难" class="headerlink" title="NO.37 解数独 困难 "></a>NO.37 解数独 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/23/310IhV.png" alt="310IhV.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3105t0.png" alt="3105t0.png"></p>
<p><strong><font color=red>思路一：回溯法</font></strong> 就是模拟人解数独时的简单想法：</p>
<ol>
<li>人在解数独的时候要注意每一行、每一列、每一个子数独中哪些数字已经被使用过了；</li>
<li>一行一行的进行填充，填充完一行就聚焦到下一行继续填充；</li>
<li>如果一个单元格中不为空，则去下一个单元格；</li>
<li>如果一个单元格为空，我们就看一下这个单元格所属的行、列、子数独中有哪些数字没有使用过，就将未使用过的数字填入单元格，并且记录这个被填入的数字在此单元格所属的行、列、子数独中已经被使用过了；</li>
<li>如果出现因为之前填充空格时选择不佳，导致无法继续填写空格的情况，就逐步擦除之前填入的数字，并将被擦除的数字在所属的行、列、子数独中设置为未使用的状态后，重新选择下一个未使用过的数字进行填充，尝试继续完成填充；</li>
<li>如果已经填充完所有行，即成功解数独。</li>
</ol>
<p>通过描述”我”解这类数独时的朴素想法，我们大概知道编码的方法了：</p>
<ol>
<li>大方向上，我们就是对需要填写的空白格进行尝试，不断地将每个空白格填写上当前状态可用的数字。当填写逐步推进的过程中，如果出现无法满足要求的组合时，就返回并擦除填写的数字，直至得到一个完全符合要求的组合。<u>这个过程就是典型的dfs剪枝回溯的思路。</u></li>
<li>我们需要实时的记录更新每一行、每一列、每一个子数独中1~9数字的使用情况。<u>这里可以用三大小为9*9的boolean类型数组分别记录，初始化为false表示都未使用，遍历初始数独将已使用过的数字记录为true表示已使用。</u></li>
<li>回溯方法中需要按行逐步推进，所有行都填写完毕即完成解数独。<u>编写时需要时刻记录当前填写的行和被填写的列。</u></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三个数组分别记录9行、9列、9个子数独中9个数字的使用状态，finished记录是否完成解数独</span></span><br><span class="line"><span class="keyword">boolean</span>[][] rows=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>],cols=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>],blocks=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">boolean</span> finished=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//解数独方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化状态数组，遍历初始数独，将使用过的数字的状态置为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                rows[row][board[row][col]-<span class="string">'1'</span>]=</span><br><span class="line">                    cols[col][board[row][col]-<span class="string">'1'</span>]=</span><br><span class="line">                    blocks[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][board[row][col]-<span class="string">'1'</span>]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度遍历，row记录当前要填写的行，col记录当前要填写的列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0-8行都已经填写，解数独完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==<span class="number">9</span>)&#123;</span><br><span class="line">        finished=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是空白格，不需要填写，继续向后移动</span></span><br><span class="line">    <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>)&#123;</span><br><span class="line">        <span class="comment">//如果本行已经是最后一列，则继续填写下一行的第一列；否则继续当前行的下一列。</span></span><br><span class="line">        <span class="keyword">if</span> (col==<span class="number">8</span>) dfs(board,row+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> dfs(board,row,col+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//按顺序将当前行、列、子数独未使用的数字尝试填入空白格</span></span><br><span class="line">        <span class="keyword">int</span> block = row / <span class="number">3</span> * <span class="number">3</span> + col / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//如果i+1未使用，可以填入当前空白格</span></span><br><span class="line">            <span class="keyword">if</span> (!rows[row][i] &amp;&amp; !cols[col][i] &amp;&amp; !blocks[block][i])&#123;</span><br><span class="line">                board[row][col]=(<span class="keyword">char</span>)(i+<span class="string">'1'</span>);</span><br><span class="line">                <span class="comment">//更新被入数字的状态</span></span><br><span class="line">                rows[row][i]=cols[col][i]=blocks[block][i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//填写完毕当前空白格，继续填写一格</span></span><br><span class="line">                <span class="keyword">if</span> (col==<span class="number">8</span>)dfs(board,row+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> dfs(board,row,col+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果当前尝试填入的数字组合不能成功解数独(导致后序空白格无法填写)，则回溯</span></span><br><span class="line">                <span class="keyword">if</span> (!finished)&#123;</span><br><span class="line">                    <span class="comment">//擦除填入的数字，并更新被擦除数字的状态</span></span><br><span class="line">                    board[row][col]=<span class="string">'.'</span>;</span><br><span class="line">                    rows[row][i]=cols[col][i]=blocks[block][i]=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看着长，除去注释其实没多少。而且这道题思路比较简单清晰易懂。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——删除排序数组中的重复项</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="NO-26-删除排序数组中的重复项-简单"><a href="#NO-26-删除排序数组中的重复项-简单" class="headerlink" title="NO.26 删除排序数组中的重复项 简单 "></a>NO.26 删除排序数组中的重复项 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZCsTU.png" alt="lZCsTU.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/27/lZCrwT.png" alt="lZCrwT.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 题目中给了两个关键点需要特别思考”原地”和”不需要考虑数组中超出新长度后面的元素”，所谓的”原地”就是不需要创建新的数组将不重复的元素复制过去，只需要在原数组中进行”覆盖”即可；所谓”不需要考虑数组中超出新长度后面的元素”就是只需要将不重复元素都”紧凑到原数组的前面”，如：[1,1,1,2,3,3,4,6]遵循上述两个点进行”覆盖”和”紧凑”的结果[1,2,3,4,6,3,4,6]，算法的返回值为新长度5。</p>
<p>可以用两个指针i和j分别指向0号和1号元素，如果j指向的元素和i指向的元素相等就移动j指针，如果不相等则先移动i指针再让j指向的元素覆盖此时i指向的元素最后移动j指针，直至j指针遍历完所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="comment">//            如果不相等,则先移动i指针再让j指向的元素覆盖此时i指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——四数之和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-18-四数之和-中等"><a href="#NO-18-四数之和-中等" class="headerlink" title="NO.18 四数之和 中等 "></a>NO.18 四数之和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/19/QLB8Qs.png" alt="QLB8Qs.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 熟悉的配方，熟悉的味道，回想“2.两数之和”和“15.三数之和”分别是如何计算的。这里我的思路是将二者相结合形参这道“四数之和”的算法：1.因为需要用到双指针法，所以先将数组排序。2. 遍历数组每个元素nums[i]的时候计算其于target的差值temp（这里有点两数之和的味道）。3. 同时在nums[i]元素后面的部分寻找是否有三个数相加等于temp（这里就是进行双指针法解三数之和，具体思路参考<a href="https://jerrymouse1998.github.io/post/%E5%BE%92%E6%89%8B%E6%8C%96%E5%9C%B0%E7%90%83%E5%85%AD%E5%91%A8%E7%9B%AE/">徒手挖地球六周目</a>中的三数之和双指针法思路），如果找到三数和等于temp就将这三个数和nums[i]加入结果集。5. 在nums[i]元素后面的部分进行双指针法全部遍历完后，对nums[i+1]进行上述操作，直至数组中所有元素都进行完毕。</p>
<p>和”三数之和”一样需要”<strong>去重</strong>“：1. 外层for遍历每个元素nums[i]时，除了0号元素之外如果nums[i]==nums[i+1]，则需要跳过。2. 内层循环除了第一个元素之外，如果nums[j]==nums[j+1],也需要跳过。</p>
<p>可以<strong>优化</strong>的地方：1. 固定当前nums[i]元素后，最小的四数之和已经大于target，则结束循环。2.固定当前nums[i]元素后，当前最大的四数之和依然小于target，则跳过当前元素，进行下一个元素nums[i+1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">4</span>)<span class="keyword">return</span> ans;</span><br><span class="line"><span class="comment">//        排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历数组每一个元素,因为是求四数之和，所以i&lt;len-3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="comment">//            如果当前最小的四数之和已经大于target，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt; target)<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//            如果当前最大的四数之和依然小于target，则跳过当前元素，进行下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[len-<span class="number">1</span>]+nums[len-<span class="number">2</span>]+nums[len-<span class="number">3</span>]&lt; target)<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            跳过重复的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            当前数组想要组成target所需要的值</span></span><br><span class="line">            <span class="keyword">int</span> temp=target-nums[i];</span><br><span class="line">            </span><br><span class="line"><span class="comment">//            遍历i号元素后面部分的每个元素，因为是求三数之和，所以i&lt;len-2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len-<span class="number">2</span>;j++)&#123;</span><br><span class="line"><span class="comment">//                跳过重复元素</span></span><br><span class="line">                <span class="keyword">if</span> (j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//                用双指针分别指向j号元素后面部分的开始元素和结尾元素</span></span><br><span class="line">                <span class="keyword">int</span> L=j+<span class="number">1</span>,R=len-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[j]+nums[L]+nums[R];</span><br><span class="line">                    <span class="keyword">if</span> (sum==temp)&#123;</span><br><span class="line">                        ans.add(Arrays.asList(nums[i],nums[j],nums[L],nums[R]));</span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[L]==nums[L+<span class="number">1</span>])L++;</span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[R]==nums[R-<span class="number">1</span>])R--;</span><br><span class="line">                        L++;</span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;temp)&#123;</span><br><span class="line">                        L++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;temp)&#123;</span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长回文子串</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="NO-5-最长回文子串-中等"><a href="#NO-5-最长回文子串-中等" class="headerlink" title="NO.5 最长回文子串 中等 "></a>NO.5 最长回文子串 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/05/Q8ZSII.png" alt="Q8ZSII.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 用两个for循环划分出所有子串，并依次判断划分出的子串是否为回文，如果是回文并且子串长度大于ans当前记录的值，就更新ans。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String ans=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s.substring(i,j))&amp;&amp;len&lt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                ans=s.substring(i,j);</span><br><span class="line">                len=Math.max(len,ans.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)!=s.charAt(s.length()-<span class="number">1</span>-i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^3)</p>
<p><font color=red><strong>思路二：扩展中心法</strong></font> 经过对回文特点的观察发现，回文都是中心对称的。所以我们可以从中心进行展开判断，一个长度为n的字符串中有2n-1个中心（因为回文长度有可能是基数或偶数，基数回文的中心有n个，如abc中心是b；偶数回文的中心有n-1个，如abbc中心是bb）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        如果是空串，则直接返回空串表示没有回文串</span></span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.length()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line"><span class="comment">//            判断i为中心的基数回文长度</span></span><br><span class="line">            <span class="keyword">int</span> len1=expandAroundCenter(s,i,i);</span><br><span class="line"><span class="comment">//            判断i，i+1为中心的偶数回文长度</span></span><br><span class="line">            <span class="keyword">int</span> len2=expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len=Math.max(len1,len2);</span><br><span class="line"><span class="comment">//            如果新回文串的长度大于之前的回文串长度，则更新</span></span><br><span class="line">            <span class="keyword">if</span> (len&gt;end-start)&#123;</span><br><span class="line"><span class="comment">//                </span></span><br><span class="line">                start=i-(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        因为substring()方法截取的范围是[起始索引,结束索引)，所以第二个参数需要+1</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="comment">//        当左标记大于等于0,且右标记小于输入串长，且当前左右标记的字符相等时，左右标记分别中心扩展</span></span><br><span class="line">        <span class="keyword">while</span> (left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        返回以i或(i，i+1)为中心的回文串长度。</span></span><br><span class="line">        <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><font color=red><strong>思路三：最长公共子串法(LCS)</strong></font> 回文是从左向右读和从右向左读都是一样的，所以我们可以将原字符串s倒置之后获得s’，然后取s和s’的最长公共子串ans作为最长回文子串。</p>
<p>用动态规划法求最长公共子串，大概思路是：1.申请一个二维数组arr[s.length][s’.length]。2.判断每个对应位置的字符是否相等，如果相等 arr[i][j]=arr[i-1][j-1]+1；当i=0或j=0时候单独分析，如果对应位置字符相等 arr[i][j]=1。(<strong>PS：</strong>arr[i][j]保存的就是公共子串的长度。)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String origin=s;</span><br><span class="line"><span class="comment">//        倒置原字符串</span></span><br><span class="line">        String reverse=<span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line"><span class="comment">//        maxLen记录最长公共子序列，maxEnd记录最长公共子序列的结尾下标</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>,maxEnd=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        分别以原字符串长度和倒置字符串长度来表示，是为了更直观的理解该二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr=<span class="keyword">new</span> <span class="keyword">int</span>[origin.length()][reverse.length()];</span><br><span class="line"><span class="comment">//        双重循环遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;reverse.length();j++)&#123;</span><br><span class="line"><span class="comment">//                判断原字符串i位置字符和倒置字符串j位置字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (origin.charAt(i)==reverse.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;<span class="comment">//当i=0或j=0时候单独分析，如果对应位置字符相等 arr[i][j]=1</span></span><br><span class="line">                        arr[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        arr[i][j]=arr[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                如果当前公共子串长度比maxLen所记录的值更大，则更新最长公共子串的长度及其结束下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i][j]&gt;maxLen)&#123;</span><br><span class="line">                    maxLen=arr[i][j];</span><br><span class="line">                    maxEnd=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxEnd-maxLen+<span class="number">1</span>,maxEnd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>当S=”abc435cba”，S’=”abc534cba”时，上述算法依然可以计算出最长公共子串”abc”来作为最长回文子串，这显然是不对的。</font>对于这个问题的解决思路是：1.因为j一直指向倒置字符串中子串的末尾字符，可以先求出j指向的字符X倒置之前的下标beforeReverse=length-1-j。2.此时求出的beforeReverse是X在<strong>原字符串中的子串首位的下标</strong>，还需要加上当前子串的长度才是<strong>原字符串中子串末尾的下标</strong>e，即e=beforeReverse+arr[i][j]-1。3.因为i一直指向原字符串中子串的末尾字符，所以将e与i进行比较，如果相等，则说明当前找到的公共子串是回文子串。</p>
<p>例如，字符串倒置前后分别是S=”abc435cba”，S’=”abc534cba”，当i=2且j=2时，arr[2][2]=3,然后进行计算出beforeReverse=length-1-j=9-1-2=6，判断beforeReverse+arr[2][2]-1是否等于i，显然 6+3-1!=2，所以当前子串不是回文子串且不需要更新maxLen和maxEnd。</p>
<p><img src="https://s2.ax1x.com/2019/12/08/Qamn76.png" alt="Qamn76.png"></p>
<p>针对该思路，只需要在更新maxLen和maxEnd之前添加<strong>下标是否匹配的判断</strong>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String origin=s;</span><br><span class="line"><span class="comment">//        倒置原字符串</span></span><br><span class="line">        String reverse=<span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line"><span class="comment">//        maxLen记录最长公共子序列，maxEnd记录最长公共子序列的结尾下标</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>,maxEnd=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        分别以原字符串长度和倒置字符串长度来表示，是为了更直观的理解该二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr=<span class="keyword">new</span> <span class="keyword">int</span>[origin.length()][reverse.length()];</span><br><span class="line"><span class="comment">//        双重循环遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;reverse.length();j++)&#123;</span><br><span class="line"><span class="comment">//                判断原字符串i位置字符和倒置字符串j位置字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (origin.charAt(i)==reverse.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;<span class="comment">//当i=0或j=0时候单独分析，如果对应位置字符相等 arr[i][j]=1</span></span><br><span class="line">                        arr[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        arr[i][j]=arr[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                如果当前公共子串长度比maxLen所记录的值更大，则更新最长公共子串的长度及其结束下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i][j]&gt;maxLen)&#123;</span><br><span class="line">                    <span class="keyword">int</span> beforeReverse=origin.length()-<span class="number">1</span>-j;</span><br><span class="line"><span class="comment">//					  添加下标是否匹配的判断                 </span></span><br><span class="line">                    <span class="keyword">if</span> (beforeReverse+arr[i][j]-<span class="number">1</span>==i) &#123;</span><br><span class="line">                        maxLen = arr[i][j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxEnd-maxLen+<span class="number">1</span>,maxEnd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^2)</p>
<p>写到这里，利用LCS算法解决求最长回文子串的问题已经基本完成了,经过查阅资料和学习之后发现：其实可以使用一个一位数组即可，而不必使用上述的二维数组arr[][]。空间复杂度从之前的用二维数组时的O(n^2)降到了用一维数组后的O(n)。</p>
<p>例如还是上面的那个数组S=”abc435cba”，i=0，j=1、2、3、4、5、6、7、8更新了第一列；i=2j=1、2、3、4、5、6、7、8更新了第二列，以此类推直到i=8且j=8每一列都更新完毕。但是经过观察发现，每次更新时只需要参考前一列的值，更新第三列时，第一列的值就用不到了，所以只需要一个一维数组就可以了。但是，更新arr[i]的时候需要arr[i-1]的值，例如arr[3]=arr[2]+1，arr[4]=arr[3]+1，此时的arr[3]的信息已经被更新过了并不是”之前一列的信息了“，所以循环时j不能从0到8递增，应该倒过来，arr[8]=arr[7]+1、arr[7]=arr[6]+1。。。更新arr[8]时用arr[7]，用完之后才能去更新arr[7]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String origin=s;</span><br><span class="line"><span class="comment">//        倒置原字符串</span></span><br><span class="line">        String reverse=<span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line"><span class="comment">//        maxLen记录最长公共子序列，maxEnd记录最长公共子序列的结尾下标</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>,maxEnd=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        分别以原字符串长度和倒置字符串长度来表示，是为了更直观的理解该二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="comment">//        双重循环遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=reverse.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="comment">//                判断原字符串i位置字符和倒置字符串j位置字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (origin.charAt(i)==reverse.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;<span class="comment">//当i=0或j=0时候单独分析，如果对应位置字符相等 arr[j]=1</span></span><br><span class="line">                        arr[j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        arr[j]=arr[j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//之前是二维数组每一列默认值就是0，现在是一维数组所以需要手动更新为0</span></span><br><span class="line">                    arr[j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                如果当前公共子串长度比maxLen所记录的值更大，则更新最长公共子串的长度及其结束下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;maxLen)&#123;</span><br><span class="line">                    <span class="keyword">int</span> beforeReverse=origin.length()-<span class="number">1</span>-j;</span><br><span class="line">                    <span class="keyword">if</span> (beforeReverse+arr[j]-<span class="number">1</span>==i) &#123;</span><br><span class="line">                        maxLen = arr[j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxEnd-maxLen+<span class="number">1</span>,maxEnd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路四：Manacher算法</strong></font> 在扩展中心算法中，将奇数长度回文子串和偶数长度的回文子串分别进行了处理。本算法首先解决了奇数和偶数的问题，在每个字符间插入“#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入“^”和“$”，这样重心扩展的时候，判断两端字符是否相等时，如果到了边界就一定不会相等，从而结束循环（这里的“#”“^”“$”是字符串中不存在的字符）。并且，经过插入特殊字符处理后，字符串的长度永远都是奇数了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，</span><br><span class="line">	&quot;aba&quot; 扩展为 &quot;^#a#b#a#$&quot;</span><br><span class="line">	&quot;acca&quot; 扩展为 &quot;^#a#c#c#a#$&quot;</span><br><span class="line">	&quot;cbcbccde&quot; 扩展为 &quot;^#c#b#c#b#c#c#d#e#$&quot;</span><br></pre></td></tr></table></figure>

<p>字符串扩展之后，我们申请一个数组p[]保存从中心扩展的最大个数，而这个数也刚好是去掉”#“之后原子串的长度。例如下图中下标为6的字符，p[6]=5,所以它是从左边扩展5个字符，相应的右边也是扩展5个字符，也就是“#c#b#c#b#c#”。而去掉“#”恢复到原来的子串，变成“cbcbc”，它的长度刚好也是5。</p>
<p><img src="https://s2.ax1x.com/2019/12/08/QawkCQ.png" alt="QawkCQ.png"></p>
<p><strong>求原字符串下标</strong>：用p的下标i减去p[i]，再除以2，就是原字符串的开头下标了。例如，我们找到上图中p[i]最大值为5，也就是回文串的最大长度是5，对应的下标是6，所以原子串在原字符串中的开头下标是（6-5）/2=0。所以我们只需要返回原字符串的第0到第（5-1）位就可以了。</p>
<p>既然已经知道了如何利用p[]数组巧妙地取得结果子串了，那么就要进行马拉车算法最重要的步骤了，即<strong>如何求p[]数组？</strong></p>
<p>这一步是马拉车算法的精髓所在，充分利用的回文的对称性。用c表示回文子串的中心，用r表示回文子串的右边半径。所以r=c+p[i]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串，而不一定是最长的回文串。</p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0m8Ld.png" alt="Q0m8Ld.png"></p>
<p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。 我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串中心 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。</p>
<p><font color=green>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论:</font></p>
<p><font color=green><strong>情况一：超出了 R</strong></font></p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0mJeA.png" alt="Q0mJeA.png"></p>
<p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
<p><font color=green><strong>情况二：P [ i_mirror ] 遇到了原字符串的左边界</strong></font></p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0mtot.png" alt="Q0mtot.png"></p>
<p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
<p><font color=green><strong>情况三：i 等于了 R</strong></font></p>
<p>此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。</p>
<p><strong>考虑 C 和 R 的更新</strong><br>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0mYdI.png" alt="Q0mYdI.png"></p>
<p>此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        获取扩充后的字符串T</span></span><br><span class="line">        String T=preProsess(s);</span><br><span class="line">        <span class="keyword">int</span> len=T.length();</span><br><span class="line">        <span class="keyword">int</span>[] p=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        不需要判断前后边界字符“^"和“$”，所以循环范围是[1,len-1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="comment">//            第i个字符关于c对称的下标</span></span><br><span class="line">            <span class="keyword">int</span> i_mirror=<span class="number">2</span>*c-i;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;i)&#123;<span class="comment">//如果i小于对称半径r</span></span><br><span class="line">                p[i]=Math.max(r-i,p[i_mirror]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            遇到三种特殊情况时，需要退化到中心扩展法</span></span><br><span class="line">            <span class="keyword">while</span> (T.charAt(i+<span class="number">1</span>+p[i])==T.charAt(i-<span class="number">1</span>-p[i]))&#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            判断是否需要更新c和r</span></span><br><span class="line">            <span class="keyword">if</span> (i+p[i]&gt;r)&#123;</span><br><span class="line">                c=i;</span><br><span class="line">                r=p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        找出p[]数组中最大的值</span></span><br><span class="line">        <span class="keyword">int</span> currentIndex=<span class="number">0</span>,maxLen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i]&gt;maxLen)&#123;</span><br><span class="line">                currentIndex=i;</span><br><span class="line">                maxLen=p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        求子串首字符在原字符串中的下标</span></span><br><span class="line">        <span class="keyword">int</span> start=(currentIndex-maxLen)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    扩充字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">preProsess</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">"$"</span>;</span><br><span class="line">        String result=<span class="string">"^"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            result+=<span class="string">"#"</span>+s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        result+=<span class="string">"#$"</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Manacher算法</tag>
        <tag>中心扩展</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——N皇后</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h2 id="NO-51-N皇后-困难"><a href="#NO-51-N皇后-困难" class="headerlink" title="NO.51 N皇后 困难 "></a>NO.51 N皇后 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/28/3BxeVe.png" alt="3BxeVe.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/28/3Bxn5d.png" alt="3Bxn5d.png"></p>
<p>ps：皇后可以攻击同一行、同一列以及左上角、右上角、左下角、右下角这些角度方向上的任意单位。</p>
<p><strong><font color=red>思路一：回溯法</font></strong> 这道题使用回溯法的思路和<a href="http://www.m1ng.top/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%A7%A3%E6%95%B0%E7%8B%AC/" target="_blank" rel="noopener">NO.37解数独</a>类似，每次填入一个元素就会导致增加后序填写时的约束条件。尝试依次填写的过程中无法继续时，就回溯并继续尝试另一种填写序列。</p>
<p>本题深度遍历回溯方法的骨架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dfs(棋盘board,当前行row,n)&#123;</span><br><span class="line">	if(终止条件)&#123;</span><br><span class="line">		保存当前序列;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    	if(board[row][i]可以填写)&#123;</span><br><span class="line">    		当前格子board[row][i]&#x3D;1;</span><br><span class="line">    		填写下一行dfs(board,row+1,n);</span><br><span class="line">    		擦除填写，验证下一个序列board[row][i]&#x3D;0;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终止条件是什么：棋盘的0~n-1行都填写完毕，即row==n。</p>
<p>如何保存当前序列：棋盘使用int[][]数组表示，0为’.’，1为’Q’。遍历每一行转换为字符串存入list，最后list存入结果。</p>
<p>如何判断当前格子是否可以：遍历当前列上是否已经有皇后；遍历当前左上至右下对角线上是否已经有皇后；遍历当前右上至左下对角线上是否已经有皇后。这些遍历只需要检测小于当前的行，因为大于当前的行还没有填写到一定没有皇后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//棋盘,默认为0表示空，1表示皇后</span></span><br><span class="line">    <span class="keyword">int</span>[][] board=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//row当前填写得的行号</span></span><br><span class="line">    dfs(n,<span class="number">0</span>,board);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0~n-1都填写完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==n)&#123;</span><br><span class="line">        res.add(track(board,n));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsable(board,row,col))&#123;</span><br><span class="line">            board[row][col]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//填写下一行</span></span><br><span class="line">            dfs(n,row+<span class="number">1</span>,board);</span><br><span class="line">            board[row][col]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//board[row][col]是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUsable</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查列上有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查左上至右下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+row-col&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i+row-col][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查右上至左下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row+col-i&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row+col-i][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将int类型棋盘转换成输出格式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">track</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j]==<span class="number">0</span>)temp.append(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">else</span> temp.append(<span class="string">'Q'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(temp.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——不同路径</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="NO-62-不同路径-中等"><a href="#NO-62-不同路径-中等" class="headerlink" title="NO.62 不同路径 中等 "></a>NO.62 不同路径 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/10/8ioaGR.png" alt="8ioaGR.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/10/8ioUi9.png" alt="8ioUi9.png"></p>
<p><strong><font  color=red>思路一：动态规划</font></strong> 只能向下或向右，就是无法后退或者绕路且到达终点的步数是确定的。</p>
<p>dp[][]数组的含义：dp[i][j]就是到到i行j列的位置有多少种走法。</p>
<p>初始化：dp[0][0]~dp[0][n-1]即第一列和dp[0][0]~dp[0][n-1]即第一行因为只有向下或向右移动，所以都只有1走法可以到达。</p>
<p>状态转移：除了第一行、第一列，dp[i][j]=dp[i-1][j]+dp[i][j-1]，还是因为只能向下或向右移动，所以dp[i][j]的一定是从其上面的[i][j-1]或左面的[i-1][j]移动而来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——K个一组翻转链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-25-K个一组翻转链表-困难"><a href="#NO-25-K个一组翻转链表-困难" class="headerlink" title="NO.25 K个一组翻转链表 困难 "></a>NO.25 K个一组翻转链表 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/17/3C5wuV.png" alt="3C5wuV.png"></p>
<p><strong><font color=red>思路一：迭代实现</font></strong> 和<a href="https://blog.csdn.net/qq_42758551/article/details/103796292" target="_blank" rel="noopener">徒手挖地球九周目</a>中NO.24两两交换链表中的节点的迭代法思路一样，不过NO.24题中的k是2而已。</p>
<ol>
<li>哑节点dummy。pre指向待翻转子链表的前驱，end指向待翻转子链表的尾节点。然后，<font color=#3366cc>start</font>指向待翻转子链表的头节点，<font color=#3366cc>next</font>指向待翻转子链表的后继。最后断开待翻转子链表和剩余链表，翻转第一组。<img src="https://s2.ax1x.com/2020/02/17/3PuodI.png" alt="3PuodI.png"></li>
<li>反转完成之后，将<font color=#3366cc>start</font>节点和<font color=#3366cc>next</font>节点连接。移动<font color=#009966>pre</font>指向<font color=#3366cc>start</font>节点，<font color=#009966>end</font>指向<font color=#009966>pre</font>节点，检查<font color=#009966>end.next</font>不为空，所以向后移动<font color=#009966>end</font>到下一组待翻转子链表的尾节点，<font color=#009966>start</font>指向待翻转子链表的头节点，<font color=#009966>next</font>指向待翻转子链表的后继。翻转第二组。<img src="https://s2.ax1x.com/2020/02/17/3PuIeA.png" alt="3PuIeA.png"></li>
<li>第二组翻转完成，将<font color=#009966>start</font>节点和<font color=#009966>next</font>节点连接。移动<font color=#cc9900>pre</font>指向<font color=#009966>start</font>节点，<font color=#cc9900>end</font>指向<font color=#cc9900>pre</font>节点，检查<font color=#cc9900>end.next</font>不为空，所以向后移动<font color=#cc9900>end</font>，但是剩余节点不足k个。所以翻转全部，返回dummy.next。<img src="https://s2.ax1x.com/2020/02/17/3PKv9K.png" alt="3PKv9K.png"></li>
</ol>
<p>这里还有一个问题就是如何翻转子链表reverse(head)？用上述第一组子链表为例：</p>
<p>curr指向当前节点，pre指向curr之前节点，next指向curr之后节点，翻转过程比较简单，直接看图。</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3PGPHg.png" alt="3PGPHg.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/17/3PGSjf.png" alt="3PGSjf.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/17/3PG9u8.png" alt="3PG9u8.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/17/3P8zgP.png" alt="3P8zgP.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">1</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//初始化哑节点、pre、end</span></span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next=head;</span><br><span class="line">    ListNode pre=dummy,end=dummy;</span><br><span class="line">    <span class="keyword">while</span> (end.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//移动end指向待翻转子链表的尾部,如果剩余节点不足k个，则翻转完成返回head</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k&amp;&amp; end!=<span class="keyword">null</span>; i++) end=end.next;</span><br><span class="line">        <span class="keyword">if</span> (end==<span class="keyword">null</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//start指向待翻转子链表头节点，next指向未翻转部分的头节点</span></span><br><span class="line">        ListNode start=pre.next,next=end.next;</span><br><span class="line">        end.next=<span class="keyword">null</span>;</span><br><span class="line">        pre.next=reverse(start);</span><br><span class="line">        <span class="comment">//连接完成翻转部分和未翻转部分</span></span><br><span class="line">        start.next=next;</span><br><span class="line">        <span class="comment">//移动pre和end</span></span><br><span class="line">        pre=start;</span><br><span class="line">        end=pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//翻转子链表</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre=<span class="keyword">null</span>,curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next=curr.next;</span><br><span class="line">        curr.next=pre;</span><br><span class="line">        pre=curr;</span><br><span class="line">        curr=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nk)   n是节点总数。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——跳跃游戏II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
    <content><![CDATA[<h2 id="NO-45-跳跃游戏II-困难"><a href="#NO-45-跳跃游戏II-困难" class="headerlink" title="NO.45 跳跃游戏II 困难 "></a>NO.45 跳跃游戏II <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/26/3an8VP.png" alt="3an8VP.png"></p>
<p><strong><font color=red>思路一：贪心算法</font></strong> nums[i]表示的可以跳入的最大范围，如果当前nums[i]所能跳到的范围不涉及重点，那么就在当前能跳到的范围内选择一个最优的点(可以跳出更远的范围的点)，因为如果这个最优点都不能跳到终点，那么其他的点更不能跳到。</p>
<p>这种每一步都选择最优来保证最终结果的最优性的方法就是典型的贪心算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//end当前能跳到的最远点，steps跳的步数，maxposition能跳的最远的距离</span></span><br><span class="line">    <span class="keyword">int</span> end=<span class="number">0</span>,steps=<span class="number">0</span>,maxPosition=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意是：i&lt;length-1，如果最后一跳最远距离刚好到达终点会导致额外一次steps++</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//在当前可跳的范围内，寻找能跳的最远位置</span></span><br><span class="line">        maxPosition=Math.max(maxPosition,nums[i]+i);</span><br><span class="line">        <span class="comment">//到达当前跳跃最远点</span></span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            end=maxPosition;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——串联所有单词的子串</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="NO-30-串联所有单词的子串-困难"><a href="#NO-30-串联所有单词的子串-困难" class="headerlink" title="NO.30 串联所有单词的子串 困难 "></a>NO.30 串联所有单词的子串 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/19/3E2X5D.png" alt="3E2X5D.png"></p>
<p>这道题要把每个单词看成整体，每个不同的单词看作是不同的字符，单词串就看成是特殊的字符串。</p>
<p>==注意：s中的单词未必是长度相等。words中可能存在相同的单词。==</p>
<p><strong><font color=red>思路一：暴力法</font></strong> words中的单词长度都一样，大幅降低了这道题的难度，所以这个特点要充分利用。所以遍历s的每个子串，分别检查每个字串中是否符合要求。</p>
<p>用一个hashmap存储words中的每个单词及其在words中出现的次数；每遍历一个子串都要用一个hashmap存储被遍历子串中出现的words中存在的单词及其在子串中出现的次数。</p>
<p>重点是理解这个“要求”：1.words中的每个单词都<strong>必须出现一次</strong>。2.words中的每个单词<strong>必须连续出现</strong>。</p>
<p>反言之：检查每个子串的过程中，出现words中的不存在的单词则结束检查；出现与words中相等的单词，但是出现的次数超过其在words中出现的次数则结束检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (words==<span class="keyword">null</span>||words.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//单词个数、单词长度</span></span><br><span class="line">    <span class="keyword">int</span> wordNum = words.length,wordLen=words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="comment">//将words每个单词及其个数存入hashmap</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; allWords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        Integer value = allWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">        allWords.put(word,++value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历s每一个子串,剩余不足wordNum*wordLen个字符的子串不需要遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - wordNum * wordLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//将子串中出现的和words中相等的单词及其出现次数存入hashmap</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; hasWords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录字串中和words中相等单词数量</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计字串中连续和words中相等的单词</span></span><br><span class="line">        <span class="keyword">while</span> (count&lt;wordNum)&#123;</span><br><span class="line">            String word = s.substring(i + count * wordLen, i + (count + <span class="number">1</span>) * wordLen);</span><br><span class="line">            <span class="comment">//如果word匹配words中的单词，就统计其出现次数</span></span><br><span class="line">            <span class="keyword">if</span> (allWords.containsKey(word))&#123;</span><br><span class="line">                Integer value = hasWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">                hasWords.put(word,++value);</span><br><span class="line">                <span class="comment">//如果word出现次数超过words中这个单词的总数量则结束统计</span></span><br><span class="line">                <span class="keyword">if</span> (hasWords.get(word)&gt;allWords.get(word))<span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果字串中出现于words中所有单词都不匹配的word则结束统计</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加成功与words中匹配的单词数量</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count==wordNum)res.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*m)    n是s长度，m是words中单词个数。</p>
<p><strong><font color=red>思路二：滑动窗口优化暴力法</font></strong> 用循环内的map(haswords)来保存窗口中匹配的单词，再用一个指针标记窗口当前的起始位置。</p>
<p>暴力方法中有几个需要优化的地方：</p>
<ol>
<li><p>匹配成功：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3My6je.png" alt="3My6je.png"></p>
<p>判断i=0这个子串符合要求，如果继续按照思路一的方法判断。当i=3的时候，依然一次校验每个单词，但是“foofoo”这两个单词已经在i=0子串的时候校验过了。所以暴力法中的hasword这个map并不需要每次都清空，只需要移除“bar“之后，从i=9的单词开始判断就好了。</p>
</li>
<li><p>匹配失败，有不匹配的单词：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3MyycD.png" alt="3MyycD.png"></p>
<p>判断i=0子串时出现了“the”这个不匹配的单词导致匹配失败。i=3、i=6这些子串都包含“the”这个单词，所以都不能匹配成功，所以窗口直接移动到i=9继续校验即可。</p>
</li>
<li><p>匹配失败，单词匹配但是数量超出：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3Mys1O.png" alt="3Mys1O.png"></p>
<p>i=0字串中“bar”出现两次，但是words中只有一个”bar”所以匹配失败。窗口移动到i=3,移除了“foo”但是“bar”依然多出一个，所以一定不匹配。窗口移动到i=6的时候移除了“bar”，就可以按照正常流程继续判断了。</p>
</li>
</ol>
<p>不难发现，上述几种情况的描述时，不再是每次移动一个字符，而是每次移动单词长度。但是s中的单词不一定都是刚好符合wordLen，如何解决这种情况？</p>
<p>答：分成wordLen种情况，分别进行判断。分别从i=0开始每次移动一个单词长度、从i=1开始每次移动一个单词长度、从i=2开始每次移动一个单词长度、、、直至从i=wordLen-1开始每次移动一个单词长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||words==<span class="keyword">null</span>||words.length==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">int</span> wordsNum = words.length,wordLen=words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="comment">//将words中的单词及其数量存入hashmap</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; allWords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        Integer value = allWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">        allWords.put(word,value+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分成wordLen中情况，分别从0开始每次移动一个单词长度~从wordLen-1开始每次移动一个单词长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;wordLen;j++)&#123;</span><br><span class="line">        <span class="comment">//haswords存放当前子串中匹配的单词及其个数，count当前子串匹配的单词数量</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; haswords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历从j开始的每个子串，每次动一个单词长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=j;i&lt;s.length()-wordLen*wordsNum+<span class="number">1</span>;i+=wordLen)&#123;</span><br><span class="line">            <span class="comment">//防止情况三出现之后，情况一继续移除</span></span><br><span class="line">            <span class="keyword">boolean</span> hasRemoved=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (count&lt;wordsNum)&#123;</span><br><span class="line">                String curWord = s.substring(i + count * wordLen, i + (count + <span class="number">1</span>) * wordLen);</span><br><span class="line">                <span class="comment">//当前单词匹配，加入haswords</span></span><br><span class="line">                <span class="keyword">if</span> (allWords.containsKey(curWord)) &#123;</span><br><span class="line">                    Integer value = haswords.getOrDefault(curWord, <span class="number">0</span>);</span><br><span class="line">                    haswords.put(curWord,value+<span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">//情况三，当前单词匹配，但是数量超了</span></span><br><span class="line">                    <span class="keyword">if</span> (haswords.get(curWord) &gt; allWords.get(curWord)) &#123;</span><br><span class="line">                        hasRemoved=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//从i开始逐个单词，从haswords中移除，removeNum记录移除的单词个数</span></span><br><span class="line">                        <span class="keyword">int</span> removeNum=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">while</span> (haswords.get(curWord) &gt; allWords.get(curWord)) &#123;</span><br><span class="line">                            String fristWord = s.substring(i + removeNum * wordLen, i + (removeNum + <span class="number">1</span>) * wordLen);</span><br><span class="line">                            Integer v = haswords.get(fristWord);</span><br><span class="line">                            haswords.put(fristWord,v-<span class="number">1</span>);</span><br><span class="line">                            removeNum++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//移除完毕之后，更新count</span></span><br><span class="line">                        count-=removeNum;</span><br><span class="line">                        <span class="comment">//移动i的位置(注意removeNum要-1，因为跳出当前循环之后，i还要+wordLen)</span></span><br><span class="line">                        i+=(removeNum-<span class="number">1</span>)*wordLen;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况二，当前单词不匹配</span></span><br><span class="line">                    <span class="comment">//清空haswords</span></span><br><span class="line">                    haswords.clear();</span><br><span class="line">                    <span class="comment">//i移动到当前单词位置(因为跳出当前循环之后，i还要+wordLen)</span></span><br><span class="line">                    i+=count*wordLen;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况一，匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (count==wordsNum)result.add(i);</span><br><span class="line">            <span class="comment">//如果情况三没有出现</span></span><br><span class="line">            <span class="keyword">if</span> (count&gt;<span class="number">0</span>&amp;&amp;!hasRemoved)&#123;</span><br><span class="line">                <span class="comment">//移除成功匹配子串的第一个元素</span></span><br><span class="line">                String fristWord = s.substring(i, i + wordLen);</span><br><span class="line">                Integer v = haswords.get(fristWord);</span><br><span class="line">                haswords.put(fristWord,v-<span class="number">1</span>);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*wordLen)    这个时间复杂度不敢确定算的对。。。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——不同路径II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    <content><![CDATA[<h2 id="NO-63-不同路径II-中等"><a href="#NO-63-不同路径II-中等" class="headerlink" title="NO.63 不同路径II 中等 "></a>NO.63 不同路径II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/10/8iodR1.png" alt="8iodR1.png"></p>
<p><strong><font  color=red>思路一：动态规划</font></strong> 这道题和上一题作为姊妹题，没什么太大变化，只是多了障碍物这个因素。</p>
<p>dp[][]数组的含义：和上一题一样。</p>
<p>初始化：dp[0][0]~dp[0][n-1]即第一列和dp[0][0]~dp[0][n-1]即第一行因为只有向下或向右移动，所以在第一个障碍物之前的位置都是1，障碍物即障碍物之后的位置都是无法到达所以是0。</p>
<p>状态转移：如果[i][j]是障碍物则无法到达所以是0，否则依然是dp[i][j]=dp[i-1][j]+dp[i][j-1]，还是因为只能向下或向右移动，所以dp[i][j]的一定是从其上面的[i][j-1]或左面的[i-1][j]移动而来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length,n=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span>)dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j]==<span class="number">0</span>)dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j]==<span class="number">1</span>)dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——二叉树的直径</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h2 id="NO-543-二叉树的直径-简单"><a href="#NO-543-二叉树的直径-简单" class="headerlink" title="NO.543 二叉树的直径  简单 "></a>NO.543 二叉树的直径  <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/10/8iIWuT.png" alt="8iIWuT.png"></p>
<p><strong><font color=red>思路一：深度优先遍历</font></strong> 这道题比较明显，立刻就能想到深度搜索，关键是怎么找到最长的。</p>
<p>一开始就陷入了一个误区，我觉着最大直径一定有根节点，所以根节点左子树找到最深的路径leftMax、右子树找到最深路径rightMax，最后总的最深路径就是leftMax+rightMax。很朴实的想法，但是明显是错误的。如果树是空的就错了，即使树不空但是根节点的左子树或者右子树为空也可能会出错，形如下图。</p>
<p><img src="https://s2.ax1x.com/2020/03/10/8izEL9.png" alt="8izEL9.png"></p>
<p>最初的这个想法浪费了不少时间，但是通过学习别人的思路发现最初的错误方法有一小部分是正确的。</p>
<p>虽然最大直径不一定经过根节点，但是一定经过某个节点(废话)，这个某节点的左子树最深路径和右子树最深路径之和就是最大直径。</p>
<p>我们要找的是路径和而不是节点和，这一点要牢记。</p>
<p>根据这个左右子树最大深度之和的方式，深度优先遍历将所有节点的最大直径都算出来，取最大即可。递归深搜到每个叶子节点，触底返回节点左右最深的路径+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> ans;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为空，没有路径</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//深搜</span></span><br><span class="line">    <span class="keyword">int</span> leftMax=dfs(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax=dfs(root.right);</span><br><span class="line">    <span class="comment">//每个子树根的最大直径</span></span><br><span class="line">    ans=Math.max(ans,leftMax+rightMax);</span><br><span class="line">    <span class="comment">//+1因为子树的根到父节点之间有一条边</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax,rightMax)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——二进制求和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-67-二进制求和-简单"><a href="#NO-67-二进制求和-简单" class="headerlink" title="NO.67 二进制求和 简单 "></a>NO.67 二进制求和 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/16/8G8PqU.png" alt="8G8PqU.png"></p>
<p><strong><font color=red>思路一：逐位相加进位</font></strong> 这种题其实已经遇到很多了，之前的字符串相加、字符串相乘是一样的。只不过本题换成了二进制而已。</p>
<p>不需要考虑符号位，依然是逆序遍历从低位到高位逐位相加，记录进位情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>,len=Math.max(a.length(),b.length());</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=a.length()-i-<span class="number">1</span>&gt;=<span class="number">0</span>?a.charAt(a.length()-<span class="number">1</span>-i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y=b.length()-i-<span class="number">1</span>&gt;=<span class="number">0</span>?b.charAt(b.length()-<span class="number">1</span>-i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line">        carry=sum/<span class="number">2</span>;</span><br><span class="line">        sb.append(sum%<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)sb.append(carry);</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——岛屿的最大面积</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="NO-695-岛屿的最大面积-中等"><a href="#NO-695-岛屿的最大面积-中等" class="headerlink" title="NO.695 岛屿的最大面积 中等 "></a>NO.695 岛屿的最大面积 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/15/81gBKe.png" alt="81gBKe.png"></p>
<p><strong><font color=red>思路一：广度优先遍历</font></strong> 这道题给我的第一感觉和腐烂的橘子那道题很像，都是多源向外”辐射”寻找。</p>
<p>用一个和grid大小一样的boolean型数组used标识每个位置是否用过，max统计最大岛屿面积。</p>
<p>遍历矩阵，如果当前位置是陆地(1)并且没有被使用过，就从当前位置进行广搜最后更新最大岛屿面积；否则继续遍历。</p>
<p>简陋的BFS模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(队列不空)&#123;</span><br><span class="line">	node=队列.poll();</span><br><span class="line">	<span class="keyword">for</span>(node的邻接节点)&#123;</span><br><span class="line">		<span class="keyword">if</span>(邻接节点m未曾入队)&#123;</span><br><span class="line">			队列.add(m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显这是个模板题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[][] used;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.m=grid.length;</span><br><span class="line">    <span class="keyword">this</span>.n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">this</span>.used=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="comment">//遍历每个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//如果是陆地且没用过</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>&amp;&amp;!used[i][j])&#123;</span><br><span class="line">                <span class="comment">//广搜更新最大岛屿面积</span></span><br><span class="line">                max=Math.max(max,bfs(grid,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广搜</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//广搜队列</span></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);<span class="comment">//当前陆地入队</span></span><br><span class="line">    used[i][j]=<span class="keyword">true</span>;<span class="comment">//更新标记数组</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;<span class="comment">//开始就是一块陆地</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> r=curr[<span class="number">0</span>],c=curr[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断当前出队陆地的上下左右是否是陆地且没使用过</span></span><br><span class="line">        <span class="keyword">if</span> (r-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r-<span class="number">1</span>][c]==<span class="number">1</span>&amp;&amp;!used[r-<span class="number">1</span>][c])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r-<span class="number">1</span>,c&#125;);</span><br><span class="line">            used[r-<span class="number">1</span>][c]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r][c-<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;!used[r][c-<span class="number">1</span>])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c-<span class="number">1</span>&#125;);</span><br><span class="line">            used[r][c-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r+<span class="number">1</span>&lt;m&amp;&amp;grid[r+<span class="number">1</span>][c]==<span class="number">1</span>&amp;&amp;!used[r+<span class="number">1</span>][c])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>,c&#125;);</span><br><span class="line">            used[r+<span class="number">1</span>][c]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c+<span class="number">1</span>&lt;n&amp;&amp;grid[r][c+<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;!used[r][c+<span class="number">1</span>])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c+<span class="number">1</span>&#125;);</span><br><span class="line">            used[r][c+<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<p><strong>使用的这个used数组可以省略，每个使用过的陆地(1)直接置为0就可以了，我看很多人很形象地把这个叫做”沉岛思想”。用这种方式可以自行改进上一题，减少空间使用。</strong></p>
<p><strong><font color=red>思路二：深度优先遍历</font></strong> 虽然改用深度优先遍历，实际上和上文思路一样，应该叫做实现二。</p>
<p>依然是遍历判断是否为1，如果是则采用深搜统计并更新max。</p>
<p>尝试抛弃used数组，改为”沉岛思想”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">//是陆地</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//深搜并更新max</span></span><br><span class="line">                max=Math.max(max,dfs(grid,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深搜</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界都是海水</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i==grid.length||j&lt;<span class="number">0</span>||j==grid[i].length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">        grid[i][j]=<span class="number">0</span>;<span class="comment">//沉岛</span></span><br><span class="line">        <span class="comment">//上下左右四个方向深搜，别忘了开始的一块陆地</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(grid,i+<span class="number">1</span>,j)+dfs(grid,i-<span class="number">1</span>,j)+dfs(grid,i,j+<span class="number">1</span>)+dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——多数元素</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="NO-169-多数元素-简单"><a href="#NO-169-多数元素-简单" class="headerlink" title="NO.169 多数元素 简单 "></a>NO.169 多数元素 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/13/8n497q.png" alt="8n497q.png"></p>
<p><strong><font color=red>思路一：排序法</font></strong> 因为题目中说总是存在多数元素，这个多数元素的个数大于半数，所以无论是升序还是降序排序之后中间元素一定是多数元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)</p>
<p><strong><font color=red>思路二：哈希表</font></strong> 遍历一遍统计不同数字出现次数，然后遍历哈希表找出多数元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计数字出现次数</span></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        Integer value = map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">        map.put(num,value+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历map，打擂台找到多数元素</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,maxNum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; en : map.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (en.getValue()&gt;maxNum)&#123;</span><br><span class="line">            ans=en.getKey();</span><br><span class="line">            maxNum=en.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路三：摩尔投票法</font></strong> 基于题目中说的多数元素一定存在。</p>
<p>简单说就是先定一个候选人和计数器count，然后遍历过程中遇到和候选人相同的就count+1，不同则count-1，当count==0，就更换当前元素为新的候选人并将count置为1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidate=nums[<span class="number">0</span>],count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num==candidate)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)&#123;</span><br><span class="line">            candidate=num;</span><br><span class="line">            count=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
        <tag>摩尔投票算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——插入区间</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="NO-57-插入区间-困难"><a href="#NO-57-插入区间-困难" class="headerlink" title="NO.57 插入区间 困难 "></a>NO.57 插入区间 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/07/3XsAzD.png" alt="3XsAzD.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 先将intervals和新区间都输入到一个数组中，然后对数组中的区间进行合并得到结果。</p>
<p><a href="https://blog.csdn.net/qq_42758551/article/details/104662112" target="_blank" rel="noopener">徒手挖地球二五周目</a>题解中NO.56合并区间中详细描述了如何进行区间合并。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">int</span>[][] input=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//将newInterval和Intervals都输入一个数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        input[i][<span class="number">0</span>]=intervals[i][<span class="number">0</span>];</span><br><span class="line">        input[i][<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    input[n][<span class="number">0</span>]=newInterval[<span class="number">0</span>];</span><br><span class="line">    input[n][<span class="number">1</span>]=newInterval[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//合并区间</span></span><br><span class="line">    <span class="keyword">return</span> merger(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] merger(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(intervals,(o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=intervals[i][<span class="number">0</span>],right=intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;intervals.length-<span class="number">1</span>&amp;&amp;right&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            right=Math.max(right,intervals[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)    将新旧区间输入一个数组中需要遍历一次，合并区间操作需要排序是nlogn复杂度，然后合并本身需要遍历数组一次。</p>
<p><strong><font color=red>思路二：贪心算法</font></strong> 将当前的一小步进行最优处理，从而使整体最优。思路二是针对思路一进行优化。</p>
<p>本题中已经告知旧区间是有序的，所以思路一中的排序只是为了让新区间放置在末尾之后移动到有序的位置上，从而付出了nlogn的代价。</p>
<ol>
<li><p>针对这一点很容易想到，在第一次遍历旧区间合集的时候顺便进行和新区间的比较，就能直接将新区间插入到有序的位置上。如何进行比较？</p>
<p>==新区间应该放置到最后一个右边界小于新区间左边界的旧区间后面==，这样新区间放入位置之前的所有旧区间都不会和新区间重叠且不需要和新区间进行合并。</p>
</li>
<li><p>找到新区间的插入位置后先不要急于将新区间放入，因为此时新区间可能需要和放入位置及其后序连续的旧区间进行合并。什么样的旧区间会和新区间进行合并？</p>
<p>==新区间右边界&gt;=旧区间左边界==则说明新旧区间需要进行合并，例如[4,5]和[2,6]、[4,8]和[8,9]等等。。。</p>
</li>
<li><p>两个区间合并的结果是[min(新区间左,旧区间左)，max(新区间右,旧区间右)]。将合并后的新区间加入结果集。最后将剩余的旧区间加入结果集。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>,n=intervals.length;</span><br><span class="line">    <span class="comment">//找到新区间的放置位置，最后一个右边界小于新区间左边界的旧区间的后面</span></span><br><span class="line">    <span class="keyword">while</span> (index&lt;n&amp;&amp;newInterval[<span class="number">0</span>]&gt;intervals[index][<span class="number">1</span>])&#123;</span><br><span class="line">        res.add(intervals[index++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//temp记录合并后新区间的左右边界值</span></span><br><span class="line">    <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newInterval[<span class="number">0</span>],newInterval[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;n&amp;&amp;newInterval[<span class="number">1</span>]&gt;=intervals[index][<span class="number">0</span>])&#123;</span><br><span class="line">        temp[<span class="number">0</span>]=Math.min(temp[<span class="number">0</span>],intervals[index][<span class="number">0</span>]);</span><br><span class="line">        temp[<span class="number">1</span>]=Math.max(temp[<span class="number">1</span>],intervals[index][<span class="number">1</span>]);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将合并后的新区间放入结果集</span></span><br><span class="line">    res.add(temp);</span><br><span class="line">    <span class="comment">//将剩余区间放入结果集</span></span><br><span class="line">    <span class="keyword">while</span> (index&lt;n)&#123;</span><br><span class="line">        res.add(intervals[index++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——电话号码的字母组合</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="NO-17-电话号码的字母组合-中等"><a href="#NO-17-电话号码的字母组合-中等" class="headerlink" title="NO.17 电话号码的字母组合 中等 "></a>NO.17 电话号码的字母组合 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/19/QLBNwV.png" alt="QLBNwV.png"></p>
<p><font color=red><strong>思路一：回溯法</strong></font> 如果这道题加一个条件：“每次输入3位字符的字符串”。那么这道题就非常简单了，直接三层for循环就解决了。这道题棘手的地方就是如何确定循环的层数，这时候递归就派上用场了（模仿大佬的语气）！</p>
<p>例如输入”2345”这样的字符串：第一次递归处理2，然后处理完第一个字符2之后，将输入的字符改变成”345”并调用第二个递归函数；第二次递归处理3，将字符串改变成”45”后再次递归；第三次递归处理4，将字符串改变成 “5”后继续递归；第四次递归处理5，将字符串改变成””后继续递归；最后发现字符串为空了，将结果放到列表中并返回。</p>
<p>上面是从函数调用的角度去看的，而每次调用下一层递归时，都需要将本层的一些处理结果放到一个临时变量中，再传递给下一层，从这个变量层层传递的变化看，就像一棵树一样，这个算法的时间复杂度很高，是O(3^n)这个级别的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    用数组或hashmap存储数字及其对应的字符表</span></span><br><span class="line">    String[] letters=&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line"><span class="comment">//    结果集</span></span><br><span class="line">    List&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        边界处理</span></span><br><span class="line">        <span class="keyword">if</span> (digits.length()==<span class="number">0</span>||digits==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        backTrack(digits,<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(String str,String combination,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">//        递归终止条件，当index==str.length()时说明str==""</span></span><br><span class="line">        <span class="keyword">if</span> (index==str.length())&#123;</span><br><span class="line">            result.add(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        获取当前index位置的字符，此处和前文的思路中有所不同：没有采用每次将字符串切割的方法</span></span><br><span class="line"><span class="comment">//        subString()每次都会生成新的字符串，而用index方式取当前第一个字符，效率更高一点</span></span><br><span class="line">        <span class="keyword">char</span> c= str.charAt(index);</span><br><span class="line">        String letter=letters[c-<span class="string">'0'</span>];</span><br><span class="line"><span class="comment">//        遍历letter字符串，例如第一次得到的是‘2’，即遍历“abc”</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;letter.length();i++)&#123;</span><br><span class="line"><span class="comment">//            这里是比较值得思考的地方，递归调用</span></span><br><span class="line">            backTrack(str,combination+letter.charAt(i),index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(3^n)</p>
<p><font color=red><strong>思路二：队列法</strong></font> 利用队列先进先出的特点来处理该问题。</p>
<p>直接用一个例子来说明思路：假设输入的还是”23”,先将”2”对应的字符依次放入队列，队列res变为{“a”,”b”,”c”}；将此时队列中的每个字符串依次取出的同时分别和下一个输入数字所对应的字符拼接后重新放入队列，将”a”取出和第二个输入数字”3”对应的字符”def”依次拼接后重新放入队列，队列res变为{“b”,”c”,”ad”,”ae”,”af”}，将”b”取出和第二个输入数字”3”对应的字符”def”依次拼接后重新放入队列，队列res变为{“c”,”ad”,”ae”,”af”,”bd”,”be”,”bf”}，将”c”取出和第二个输入数字”3”对应的字符”def”依次拼接后重新放入队列，队列res变为{“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”}；所有输入数字遍历结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//        边界处理</span></span><br><span class="line">        <span class="keyword">if</span> (digits==<span class="keyword">null</span>||digits.length()==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">//        用数组或hashmap存储数字及其对应的字符表</span></span><br><span class="line">        String[] letters=&#123;<span class="string">""</span>,<span class="string">"#"</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line"><span class="comment">//        先往队列中加入一个空字符，防止第一次循环从队列中取出第一个元素时出现下标越界异常</span></span><br><span class="line">        res.add(<span class="string">""</span>);</span><br><span class="line"><span class="comment">//        遍历输入的字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.length();i++)&#123;</span><br><span class="line"><span class="comment">//            取出当前遍历数字对应的字符串</span></span><br><span class="line">            String letter=letters[digits.charAt(i)-<span class="string">'0'</span>];</span><br><span class="line"><span class="comment">//            获取当前队列的长度，不能在for循环中直接j&lt;res.size()，因为内层循环中队列在不断增长，导致死循环</span></span><br><span class="line">            <span class="keyword">int</span> size = res.size();</span><br><span class="line"><span class="comment">//            遍历队列中每个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line"><span class="comment">//                从队列中取出第一个元素</span></span><br><span class="line">                String temp = res.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//                遍历当前数字对应的字符串的每个字符，依次和取出的第一个元素拼接后重新放入队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;letter.length();k++)&#123;</span><br><span class="line">                    res.add(temp+letter.charAt(k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(3^n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——翻转链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-206-翻转链表-简单"><a href="#NO-206-翻转链表-简单" class="headerlink" title="NO.206 翻转链表 简单 "></a>NO.206 翻转链表 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/02/3R4HGn.png" alt="3R4HGn.png"></p>
<p>本题是K个一组翻转链表这道题的其中一步，学习完本题可以趁热打铁学习NO.25，题解参考<a href="https://blog.csdn.net/qq_42758551/article/details/104362023" target="_blank" rel="noopener">徒手挖地球十八周目</a>。</p>
<p><strong><font color=red>思路一：迭代实现</font></strong> 翻转链表需要三个”指针”：pre指向前驱、curr指向当前节点、next指向后继。</p>
<p>过程比较简单，自己模拟一遍就好了：</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3R4b2q.png" alt="3R4b2q.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/02/3R47Ps.png" alt="3R47Ps.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre=<span class="keyword">null</span>,curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!= <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next=curr.next;</span><br><span class="line">        curr.next=pre;</span><br><span class="line">        pre=curr;</span><br><span class="line">        curr=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：递归实现</font></strong> 每层递归返回已经翻转好的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre=reverseList(head.next);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——腐烂的橘子</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<h2 id="NO-994-腐烂的橘子-简单"><a href="#NO-994-腐烂的橘子-简单" class="headerlink" title="NO.994 腐烂的橘子 简单 "></a>NO.994 腐烂的橘子 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/04/3Io9V1.png" alt="3Io9V1.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IIzr9.png" alt="3IIzr9.png"></p>
<p><strong><font color=red>思路一：广度优先遍历</font></strong> 这道题可以解读为：腐烂橘子到达最远好橘子的最短路径。</p>
<p>写一个很简陋的BFS的框架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(队列不空)&#123;</span><br><span class="line">	node&#x3D;队列.poll();</span><br><span class="line">	for(node的邻接节点)&#123;</span><br><span class="line">		if(邻接节点m未曾入队)&#123;</span><br><span class="line">			队列.add(m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道了BFS，这道题就比较简单了。</p>
<ol>
<li>先遍历一遍，统计初始新鲜橘子的数量并将初始腐烂橘子入队。</li>
<li>然后BFS，同时round记录进行了多少轮次的”传染”。每轮开始都要记录当前轮次开始有多少个坏橘子n。</li>
<li>将本轮开始时的所有坏橘子都出队，并对出队节点的四个邻接节点进行判断和”传染”。</li>
<li>最后检查好橘子还有没有。</li>
</ol>
<p>只有坏橘子才会入队，所以没有框架里邻接节点m未曾入队的检查，因为入过队的都变成坏橘子了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length,col=grid[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历，统计新鲜橘子，坏橘子坐标入队</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j]==<span class="number">2</span>)queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//round传染的轮次</span></span><br><span class="line">    <span class="keyword">int</span> round=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当队列不空并且还存在好橘子就广搜BFS</span></span><br><span class="line">    <span class="keyword">while</span> (count&gt;<span class="number">0</span>&amp;&amp;!queue.isEmpty())&#123;</span><br><span class="line">        round++;</span><br><span class="line">        <span class="comment">//n记录当前坏橘子数量，防止出队入队导致不同轮次之间混乱</span></span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] rc = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r=rc[<span class="number">0</span>],c=rc[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//每个出队的坏橘子的四个正方向上邻接节点是否是好橘子，如果是就传染腐烂并入队</span></span><br><span class="line">            <span class="keyword">if</span> (r-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r-<span class="number">1</span>][c]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r-<span class="number">1</span>][c]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r-<span class="number">1</span>,c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r+<span class="number">1</span>&lt;row&amp;&amp;grid[r+<span class="number">1</span>][c]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r+<span class="number">1</span>][c]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>,c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r][c-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r][c-<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c-<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c+<span class="number">1</span>&lt;col&amp;&amp;grid[r][c+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r][c+<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count&gt;<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> round;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    n数组元素个数，整个过程遍历数组两次。</p>
<p>代码很冗长，但是思路还算清楚。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a>   </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两数之和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-1-两数之和-简单"><a href="#NO-1-两数之和-简单" class="headerlink" title="NO.1 两数之和    简单 "></a>NO.1 两数之和    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMw3c9.png" alt="QMw3c9.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font>    看到题，最先想到的思路就是<strong>暴力解法</strong>，直接两层for循环遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]==target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"no result!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><font color=red><strong>思路二：哈希表法</strong></font>    通过一个哈希表来空间换时间：1.遍历nums数组，判断每个元素和目标值的差temp是否在哈希表中。2.如果在就返回当前遍历元素的下标和哈希表中temp这个key对应的value。3.如果不在就将当前遍历元素作为key、当前遍历元素下标作为value存入哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map =<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=target-nums[i];</span><br><span class="line"><span class="comment">//          所需要的temp是否在map中，如果在就返回map中temp值对应的value(即temp值对应的下标)和i。</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(temp),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//          temp如果不在map中，就将nums[i]作为key、下标i作为value放入map中</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"no twoSum result!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两两交换链表中的节点</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="NO-24-两两交换链表中的节点-中等"><a href="#NO-24-两两交换链表中的节点-中等" class="headerlink" title="NO.24 两两交换链表中的节点 中等 "></a>NO.24 两两交换链表中的节点 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZCWlR.png" alt="lZCWlR.png"></p>
<p><font color=red><strong>思路一：迭代实现</strong></font> 用一个pre指针指向未被交换节点的前驱，交换pre后继和pre后继的后继，直到pre没有后继或者pre的后继没有后继。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode pre=dummy;</span><br><span class="line">        <span class="keyword">while</span> (pre.next!=<span class="keyword">null</span>&amp;&amp;pre.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode start=pre.next,end=pre.next.next;</span><br><span class="line"><span class="comment">//            交换两个节点，注意交换顺序，否则容易死循环</span></span><br><span class="line">            pre.next=end;</span><br><span class="line">            start.next=end.next;</span><br><span class="line">            end.next=start;</span><br><span class="line"><span class="comment">//            移动pre指针，此时已经交换过两个节点的位置</span></span><br><span class="line">            pre=start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red><strong>思路二：递归实现</strong></font> 没有节点或者只有一个节点不需要进行交换，停止递归，此时返回head节点本身。每层递归返回值是交换过之后的链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next=head.next;</span><br><span class="line">    head.next=swapPairs(next.next);</span><br><span class="line">    next.next=head;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两数相除</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h2 id="NO-29-两数相除-中等"><a href="#NO-29-两数相除-中等" class="headerlink" title="NO.29 两数相除 中等 "></a>NO.29 两数相除 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/30/llAbkQ.png" alt="llAbkQ.png"></p>
<p>看了很多人的题解，学习到了很多。但是有些题解我不敢苟同，例如用long存储变量的题解，题目明确说明：我们环境只能存储32位有符号整数；需要用乘法改变正负号的题解，第一句就说了不能用乘法。。等等</p>
<p><font color=red><strong>思路一：二分法除数翻倍</strong></font> 被除数中有N个除数，那么商就是N(用减法来实现除法，新被除数=被除数-除数&amp;商+=1)。如果每次被除数只减一个除数，虽然可以实现除法，但是效率太低，在leetcode上也会TLE。所以采用每次除数翻倍(商也不再是每次+1)的方法。</p>
<p>这道题的思路并不难，但是本题有很多细节需要注意和学习：</p>
<ol>
<li><p>商的范围需要注意，小心溢出。这里可以采用先将除数和被除数转换成负数并且用负数商来进行运算，运算结束再根据除数和被除数原本的符号决定商的符号(负号直接返回，正号需要判断符号转变后是否溢出)。</p>
</li>
<li><p>如何得到商的符号：判断除数和被除数异或之后的符号即可。</p>
</li>
<li><p>如何获得相反数：反码+1=补码。分享一篇文章，对这里有疑惑的同学可以看看——<a href="https://jerrymouse1998.github.io/post/%E8%BD%AC%E8%A1%A5%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D%E5%86%8D%E5%8A%A0%E4%B8%80/">补码(为什么按位取反再加一)</a></p>
<p>举个栗子，17/3，除数和被除数都转换为负数(反码+1=补码)，即-17/-3，先用-17-(-3)=-14，商+=-1；</p>
<p>除数翻倍-14-(-6)=-8，商+=-2；</p>
<p>除数翻倍，此时的除数-12&lt;被除数-8，所以除数重置为-3；</p>
<p>继续-8-(-3)=-5，商+=-1；</p>
<p>除数翻倍，此时的除数-6&lt;被除数-5，所以除数重置为-3；</p>
<p>继续-5-(-3)=-2，商+=-1；</p>
<p>除数翻倍，此时的除数-6&lt;被除数-2，所以除数重置为-3；</p>
<p>但是初始的除数-3&lt;被除数-2，所以计算结束。</p>
<p>最后根据除数和被除数原本的符号决定商的符号，结果应该是”正正得正”，判断此时的负数商符号转变后是否溢出，负数商不等于32位有符号整形最小值-2147483648，所以可以直接转换为正数，返回负数商的相反数。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (divisor==<span class="number">0</span>)<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//将除数和被除数异或之后，得到商的符号</span></span><br><span class="line">    <span class="keyword">boolean</span> isPositive=(dividend^divisor)&gt;=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将除数和被除数都转化为负数</span></span><br><span class="line">    <span class="keyword">if</span> (dividend&gt;<span class="number">0</span>)dividend=opposite(dividend);</span><br><span class="line">    <span class="keyword">if</span> (divisor&gt;<span class="number">0</span>)divisor=opposite(divisor);</span><br><span class="line">    <span class="comment">// 商用负数来表示，这样可以处理Integer.MIN_VALUE的情况</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dividend&lt;=divisor)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempDivisor=divisor;</span><br><span class="line">        <span class="keyword">int</span> count=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里注意需要对tempDivisor是否为负数做判断，因为tempDivisor有可能会溢出</span></span><br><span class="line">        <span class="keyword">while</span> (tempDivisor&lt;<span class="number">0</span>&amp;&amp;dividend&lt;=tempDivisor)&#123;</span><br><span class="line">            <span class="comment">//被除数-除数</span></span><br><span class="line">            dividend-=tempDivisor;</span><br><span class="line">            ans+=count;</span><br><span class="line">            <span class="comment">//除数翻倍</span></span><br><span class="line">            tempDivisor+=tempDivisor;</span><br><span class="line">            count+=count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对返回值进行处理，这里也可以使用三目运算符完成</span></span><br><span class="line">    <span class="keyword">if</span> (isPositive)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans==Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> opposite(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x的反码+1，得到x的相反数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">opposite</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logN)，除数是 1，每次减一个除数，我们将减 n 次，但因为每次除数都翻倍了，所以共减了log(n)次。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——加一</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h2 id="NO-66-加一-简单"><a href="#NO-66-加一-简单" class="headerlink" title="NO.66 加一 简单 "></a>NO.66 加一 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/15/83UxmV.png" alt="83UxmV.png"></p>
<p>这个题的题干给的很迷，不知道是不是翻译的问题。。。</p>
<p><strong><font color=red>思路一：遍历</font></strong> 很容易想到，+1的结果最大就是10，如果是10就进位当前位置剩余0。</p>
<p>只需要注意”9”、”99”、”999”。。。的全9情况就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//当前位是否是9，不是9+1返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (digits[i]!=<span class="number">9</span>)&#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前位是9，+1进位剩余0</span></span><br><span class="line">        digits[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明全是9，新建长度+1数组，最高位是1其余都是0即可</span></span><br><span class="line">    <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-23-合并K个排序链表-困难"><a href="#NO-23-合并K个排序链表-困难" class="headerlink" title="NO.23 合并K个排序链表 困难 "></a>NO.23 合并K个排序链表 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/17/3C5sN4.png" alt="3C5sN4.png"></p>
<p><strong><font color=red>思路一：逐一两两合并</font></strong> 将<a href="https://blog.csdn.net/qq_42758551/article/details/103733958" target="_blank" rel="noopener">NO.21合并两个有序链表</a>中的方法进行k-1次即可。</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3C5BHU.png" alt="3C5BHU.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists==<span class="keyword">null</span>||lists.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (lists.length&lt;<span class="number">2</span>)<span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next=lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lists.length;i++)&#123;</span><br><span class="line">        ListNode head=dummy,p=dummy.next,q=lists[i];</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q.val&lt; p.val)&#123;</span><br><span class="line">                head.next=q;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head.next=p;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q!=<span class="keyword">null</span>)head.next=q;</span><br><span class="line">        <span class="keyword">if</span> (p!=<span class="keyword">null</span>)head.next=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(Nk)   N是节点总数，k是链表数</p>
<p><strong><font color=red>思路二：分治法优化两两合并</font></strong> 每次对折合并，0号链表和length-1号链表合并保存到0、1号链表和length-2号链表合并保存到1。。。第一轮合并后，将0~k/2再次对折两两合并。。。以此类推，最后0号链表就是最终结果。</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3C5y4J.png" alt="3C5y4J.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = lists.length;</span><br><span class="line">    <span class="keyword">if</span> (lists==<span class="keyword">null</span>|| len ==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//中心对称，两两合并</span></span><br><span class="line">            lists[i]=mergeTwoList(lists[i],lists[len-<span class="number">1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        len=(len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并两个链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoList</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode head=dummy,p=l1,q=l2;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="keyword">null</span>&amp;&amp;q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val&lt;q.val)&#123;</span><br><span class="line">            head.next=p;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head.next=q;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q!=<span class="keyword">null</span>)head.next=q;</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span>)head.next=p;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(Nlogk)    N是节点总数，每次对折合并所有节点都参与了，一共对折合并了logk次。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——合并两个有序链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-21-合并两个有序链表-简单"><a href="#NO-21-合并两个有序链表-简单" class="headerlink" title="NO.21 合并两个有序链表 简单 "></a>NO.21 合并两个有序链表 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFVQZ8.png" alt="lFVQZ8.png"></p>
<p><font color=red><strong>思路一：迭代法</strong></font> 这个题目也是学校老师讲述数据结构课程时说的。1. 创建一个新的头结点dummy，用prehead指针指向新创建的dummy头结点，用p指针指向l1链表的头结点，q指针指向l2链表的头结点。2. 比较p指向的节点的值和q指向的节点的值，如果p指向的节点值小，就让prehead的next指向p所指向的节点，然后prehead和p向后移动，反之就让prehead的next指向q所指向的节点，然后prehead和q向后移动。3. 直到p或者q指针有一个为null为止，最后检查p或者q是否有不为null的指针，如果有就让prehead指向非空的p或者q。返回dummy.next即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="keyword">null</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="keyword">null</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode prehead=dummy,p=l1,q=l2;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>&amp;&amp;q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val&lt;q.val)&#123;</span><br><span class="line">                prehead.next=p;</span><br><span class="line">                prehead=prehead.next;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                prehead.next=q;</span><br><span class="line">                prehead=prehead.next;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        最后检查p或者q是否有不为null的指针</span></span><br><span class="line">        <span class="keyword">if</span> (p!=<span class="keyword">null</span>)prehead.next=p;</span><br><span class="line">        <span class="keyword">if</span> (q!=<span class="keyword">null</span>)prehead.next=q;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：递归法</strong></font> 其实递归法不能算是第二个思路，只能说是思路一的另一种实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——合并两个有序数组</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="NO-88-合并两个有序数组-简单"><a href="#NO-88-合并两个有序数组-简单" class="headerlink" title="NO.88 合并两个有序数组 简单 "></a>NO.88 合并两个有序数组 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/03/34CGVO.png" alt="34CGVO.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 没啥说的直接B合并到A后面的预留位置，然后直接API对A进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        A[m+i]=B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((m+n)*log(m+n))    排序的复杂度</p>
<p><strong><font color=red>思路二：双指针法</font></strong> 最直接想到的双指针法就是像合并两个有序链表一样双指针分别指向两个数组开头，从前向后遍历两个数组。</p>
<p>但是本题中A数组要作为最终的结果数组，所以需要将A中的m个元素保存到A2数组中，然后像上述方法一样双指针遍历A2和B数组，合并保存到A数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存nums1的m个元素</span></span><br><span class="line">    <span class="keyword">int</span>[] A2=<span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        A2[i]=nums1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双指针比较并合并保存到nums1中</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;A2.length&amp;&amp;j&lt;nums2.length)&#123;</span><br><span class="line">        nums1[index++]=(A2[i]&lt;nums2[j]?A2[i++]:nums2[j++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个数组有剩余时保存到nums1后面</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;nums2.length)nums1[index++]=nums2[j++];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;A2.length)nums1[index++]=A2[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(m)    保存nums1的m个元素。</p>
<p><strong><font color=red>思路三：逆序双指针法</font></strong> 不使用额外的数组去保存nums1的m个元素，从而优化空间。</p>
<p>方法就是：逆序！其实就是将思路二都逆向进行。</p>
<p>双指针分别指向nums1和nums2的尾部，逆序遍历，比较大的元素优先合并入结果数组；从结果数组的尾部向前保存并入的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指针都指向尾部，比较大的元素优先合并至nums1尾部</span></span><br><span class="line">    <span class="keyword">int</span> i=m-<span class="number">1</span>,j=n-<span class="number">1</span>,index=nums1.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        nums1[index--]=(nums1[i]&gt;nums2[j]?nums1[i--]:nums2[j--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否有剩余</span></span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>)nums1[index--]=nums1[i--];</span><br><span class="line">    <span class="keyword">while</span> (j&gt;=<span class="number">0</span>)nums1[index--]=nums2[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——合并区间</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="NO-56-合并区间-中等"><a href="#NO-56-合并区间-中等" class="headerlink" title="NO.56 合并区间 中等 "></a>NO.56 合并区间 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/04/3IoSbR.png" alt="3IoSbR.png"></p>
<p><strong><font color=red>思路一：排序</font></strong> 将所有区间按照左边界大小进行非递减排序。</p>
<p>什么样的区间是重叠的需要合并？</p>
<p>[1,3]、[2,6] 第1个区间的右边界大于下一个区间的左边界即发生重叠。</p>
<p>需要合并成[第一个区间的左边界,max(第一个区间的右边界,第二个区间的右边界)]这个区间加入结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (intervals==<span class="keyword">null</span>||intervals.length==<span class="number">0</span>)<span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    <span class="comment">//每个区间按照区间左边界升序排序</span></span><br><span class="line">    Arrays.sort(intervals, (o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//遍历每个区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pre = <span class="number">0</span>; pre &lt; intervals.length; pre++) &#123;</span><br><span class="line">        <span class="comment">//记录当前区间的左右边界值</span></span><br><span class="line">        <span class="keyword">int</span> left=intervals[pre][<span class="number">0</span>],right=intervals[pre][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//如果当前区间的右边界大于下一个区间的左边界，即发生重叠</span></span><br><span class="line">        <span class="keyword">while</span> (pre&lt;intervals.length-<span class="number">1</span>&amp;&amp;right&gt;=intervals[pre+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            right=Math.max(right,intervals[pre+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            pre++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*logn)    区间数组只需要遍历一次，主要是排序的时间复杂度。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——回文数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-9-回文数-简单"><a href="#NO-9-回文数-简单" class="headerlink" title="NO.9 回文数    简单 "></a>NO.9 回文数    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/15/QfCVaQ.png" alt="QfCVaQ.png"></p>
<p><font color=red><strong>思路一：字符串法</strong></font> 最简单的解法就是直接将数字转换为字符串s，然后将字符串翻转得到re，最后判断s和rs是否相等，相等则是回文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    String rs = <span class="keyword">new</span> StringBuilder(x + <span class="string">""</span>).reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> (x+<span class="string">""</span>).equals(rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：翻转一半法</strong></font> 题目要求中有说，不能将整数转化为字符串来解决这个问题。但是依然可以使用字符串法的翻转思路，将数字进行翻转也并不难，例如“1221”，我们需要将后半部分“21”翻转为“12”再和前半部分“12”作比较，相同所以“1221”是回文数。</p>
<p>算法步骤：1.如果数字是负数，那么一定不是回文数。如果数字最后一位是”0“，但数字本身并不是”0“，那么该数字也一定不是回文数。2.如何翻转数字的后半部分：例如“x=1221”，先”1221%10“得到1，然后“x/=10”使x=122， 最后”t=t*10+1”得到t=1；再次“122%10”得到2，然后“x/=10”使x=12，“最后”t=t*10+2”得到t=12。3.将数字后半部分翻转后得到的t和前半部分“12”进行比较，相等则为回文数。</p>
<p><font color=green>如何判断翻转数字的位数已经到达原数字位数的一半？</font>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p>
<p><u>参数数字x可能是偶数也可能是基数</u>，如果x是偶数，例如“1221”，只要翻转后的“21”等于前半部分“12”，x就是回文数；如果x是基数，例如“12321”，后半部分翻转得到“123”，剩余的前半部分是”12“，但是原始数字中间的这个数字”3“并不影响回文（它总是与自身相等）,所以可以直接简单的将后半部分翻转得到“123”进行“123/10=12”的操作即可，然后再与前半部分进行比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        两种不是回文数的特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>||(x!=<span class="number">0</span>&amp;&amp;x%<span class="number">10</span>==<span class="number">0</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        后半部分翻转后的数字</span></span><br><span class="line">        <span class="keyword">int</span> reversedNumber=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x&gt;reversedNumber)&#123;</span><br><span class="line">            reversedNumber=reversedNumber*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        x可能是的位数可能是偶数或基数，如果是基数直接reversedNumber/10,简单的去掉中间的数</span></span><br><span class="line">        <span class="keyword">return</span> x==reversedNumber||x==reversedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——将数组分成和相等的三个部分</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="NO-1013-将数组分成和相等的三个部分-简单"><a href="#NO-1013-将数组分成和相等的三个部分-简单" class="headerlink" title="NO.1013 将数组分成和相等的三个部分 简单 "></a>NO.1013 将数组分成和相等的三个部分 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/11/8A3zR0.png" alt="8A3zR0.png"></p>
<p><strong><font color=red>思路一：双指针法</font></strong> 一个数组能分成和相等的三部分，则这个数组元素总sum和必定是3的倍数，如不是则否定。</p>
<p>双指针头尾开始同时遍历，寻找最左部分和最右部分总和等于sum/3的位置，并且寻找过程中要给中间部分留有余地(中间部分至少是一个元素)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//元素总和必须是3的倍数</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">3</span>!=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//双指针找和等于sum/3的左右部分</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=A.length-<span class="number">1</span>,leftSum=A[<span class="number">0</span>],rightSum=A[A.length-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//+1给中间部分留有"余地"</span></span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftSum == sum / <span class="number">3</span> &amp;&amp; rightSum == sum / <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftSum != sum / <span class="number">3</span>) &#123;</span><br><span class="line">            leftSum+=A[++left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightSum != sum / <span class="number">3</span>) &#123;</span><br><span class="line">            rightSum+=A[--right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：计数器法</font></strong> 和思路一差不多，先判断元素总和是否满足条件。</p>
<p>顺序遍历，count计数器记录有多少部分的和等于sum/3。</p>
<p>如果count&gt;=3，则true。为什么是&gt;=？例如[1,-1,1,-1,1,-1,1,-1]，count==4这个数组依然符合要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//元素总和必须是3的倍数</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//顺序遍历找等于sum/3的部分</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, partialSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        partialSum += i;</span><br><span class="line">        <span class="keyword">if</span> (partialSum == sum/<span class="number">3</span>) &#123;</span><br><span class="line">            partialSum=<span class="number">0</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count&gt;=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——括号生成</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="NO-22-括号生成-中等"><a href="#NO-22-括号生成-中等" class="headerlink" title="NO.22 括号生成 中等 "></a>NO.22 括号生成 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZC6kF.png" alt="lZC6kF.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 1. 将2*n个括号的序列全部得到。2. 同时判断其是否为有效序列。如果是则加入结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="string">""</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    深度优先遍历得到所有组合序列，如果是有效序列，则加入结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,String conbination,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index==<span class="number">2</span>*n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(conbination))res.add(conbination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(index+<span class="number">1</span>,conbination+<span class="string">'('</span>,n);</span><br><span class="line">            dfs(index+<span class="number">1</span>,conbination+<span class="string">')'</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    平衡法判断括号序列是否有效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">                balance++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                balance--;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            如果balance&lt;0则说明，)出现在与其对应的(之前，或者)多于(</span></span><br><span class="line">            <span class="keyword">if</span> (balance&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(2^2n*n)</p>
<p><font color=red><strong>思路二：回溯法</strong></font> 该方法是对上面的暴力法的一个优化思路。上面的方法需要组合出所有的序列(有效的和无效的)，思路就是不生成无效的序列(或者说是”剪枝”,剪除无效无效序列)。观察有效序列的特点：1. 因为是括号’对’，所以n对括号序列中的’(‘和’)’的数量都是n个。2. ‘)’不能出现在与其成对的’(‘之前。</p>
<p>针对上述细节，思考回溯算法细节：</p>
<ol>
<li>当’(‘和’)’的数量都是n个的时候，说明已经得到括号序列。</li>
<li>‘(‘数量小于n的时候，可以向序列中继续添加’(‘。</li>
<li>‘)’数量小于n并且当前’)’数量小于当前’(‘数量时，才可以向序列中继续添加’)’。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="string">""</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l 左括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 有括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> combination 当前括号序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 输入n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,String combination,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//        当'('和')'的数量都是n个的时候，说明已经得到括号序列。</span></span><br><span class="line">        <span class="keyword">if</span> (l==n&amp;&amp;r==n)&#123;</span><br><span class="line">            res.add(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        '('数量小于n的时候，可以向序列中继续添加'('。</span></span><br><span class="line">        <span class="keyword">if</span> (l&lt;n)&#123;</span><br><span class="line">            dfs(l+<span class="number">1</span>,r,combination+<span class="string">'('</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        ')'数量小于n并且当前')'数量小于当前'('数量时，才可以向序列中继续添加')'。</span></span><br><span class="line">        <span class="keyword">if</span> (r&lt;n&amp;&amp;r&lt;l)&#123;</span><br><span class="line">            dfs(l,r+<span class="number">1</span>,combination+<span class="string">')'</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(4^n/sqrt(n))。在回溯过程中，每个有效序列最多需要n步。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——接雨水</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="NO-42-接雨水-困难"><a href="#NO-42-接雨水-困难" class="headerlink" title="NO.42 接雨水 困难 "></a>NO.42 接雨水 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/24/3Gi5ge.png" alt="3Gi5ge.png"></p>
<p><strong><font color=red>思路一：按行计算法</font></strong> 计算每一行接的水，相加得到一共接的水。</p>
<p>用一个变量temp记录第i行的水，遍历每个”墙”的高度，遇到<code>第一个大于等于i</code>的”墙”启动temp准备记录；继续遍历遇到<code>小于i</code>的”墙”<code>temp++</code>，否则遇到<code>大于等于i</code>的”墙”<code>ans加上temp并归零temp</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,maxHeight=height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h : height)<span class="keyword">if</span> (h&gt;maxHeight)maxHeight=h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= maxHeight; row++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//是否开始统计temp</span></span><br><span class="line">        <span class="keyword">boolean</span> isStart=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStart&amp;&amp;height[i]&lt;row)temp++;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;=row)&#123;</span><br><span class="line">                ans+=temp;</span><br><span class="line">                temp=<span class="number">0</span>;</span><br><span class="line">                isStart=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(maxHeight<em>n)    *</em>此方法在leetcode上会超时！**</p>
<p><strong><font color=red>思路二：按列计算法</font></strong> 计算出每一列上有多少水，相加得到一共接的水。</p>
<p>想知道第i列上是否有水，我们需要找到第i列的左边和右边最高的”墙”，因为只有形成凹点才能存水；并且”木桶效应”告诉我们存了多少水，只需要考虑第i列左边和右边找到的最高的”墙”中最矮的一个。</p>
<p>第i列的高度<code>x</code>和我们找到的左边和右边最高的”墙”中最矮的一个”墙”的高度<code>y</code>会有三种关系：</p>
<ol>
<li><code>x&lt;y</code>，第i列上存的水应该是y-x。</li>
<li><code>x&gt;y</code>，第i列上一定接不到水。</li>
<li><code>x=y</code>，第i列上依然是不能接到水。</li>
</ol>
<p>知道了这些，编码就很简单了，遍历每一列的同时找到当前列左边和右边最高的两面”墙”中最矮的一个和当前列进行比较，对上述三种情况进行处理即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; height.length; col++) &#123;</span><br><span class="line">        <span class="comment">//找到col左右最高的墙</span></span><br><span class="line">        <span class="keyword">int</span> leftMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) leftMax=Math.max(leftMax,height[i]);</span><br><span class="line">        <span class="keyword">int</span> rightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; height.length; i++) rightMax=Math.max(rightMax,height[i]);</span><br><span class="line">        <span class="comment">//如果最高的墙中最矮的一个大于col的高度，计算当前列上接的水并加入结果</span></span><br><span class="line">        <span class="keyword">if</span> (Math.min(leftMax,rightMax)&gt;height[col])ans+=Math.min(leftMax,rightMax)-height[col];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><strong><font color=red>思路三：动态规划优化按列计算法</font></strong> 思路二中每次寻找第i列的左右最高墙的时候都需要遍历一次整个数组。</p>
<p>思路三就是针对这点进行优化。空间换时间。</p>
<p>以题目中实例来演示：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3U8exO.md.png" alt="3U8exO.md.png"></p>
<p>每次寻找第i列左边做高的”墙”，只需要将”已经记录的i-1列左边最高的墙和i-1列进行比较，取大的即可”。避免了每次遍历整个数组。</p>
<p>寻找第i列右边做高的”墙”同理，只需要将”已经记录的i+1列右边最高的墙和i+1列进行比较，取大的即可”。</p>
<p>所以leftMax[i]的含义就是第i列左边最高的”墙”，rightMax[i]的含义就是第i列右边最高的”墙”(不含第i列本身)。</p>
<p>初始化：顺序遍历一次填写leftMax数组，逆序遍历一次填写rightMax数组。</p>
<p>有了leftMax和rightMax之后，然后计算每一列上接的水和思路二中方法一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算leftMax，rightMax</span></span><br><span class="line">    <span class="keyword">int</span>[] leftMax=<span class="keyword">new</span> <span class="keyword">int</span>[height.length],rightMax=<span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) leftMax[i]=Math.max(leftMax[i-<span class="number">1</span>],height[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=height.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) rightMax[i]=Math.max(rightMax[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//计算每一列上的水</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min=Math.min(leftMax[i],rightMax[i]);</span><br><span class="line">        <span class="keyword">if</span> (min&gt;height[i])&#123;</span><br><span class="line">            ans+=min-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    三次遍历</p>
<p>空间复杂度：O(n)</p>
<p><strong><font color=red>思路四：双指针优化动态规划法</font></strong> 双指针主要是对思路三中的空间复杂度进行优化。</p>
<p>上述方法中，两个数组中的每个元素在计算每一列上的水的时候只会被使用一次。所以完全可以用两个int类型的变量实现。</p>
<p>依然是用题目中的实例来演示：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3UscqI.png" alt="3UscqI.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/26/3Us6sA.png" alt="3Us6sA.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/26/3Us2Zt.md.png" alt="3Us2Zt.md.png"></p>
<p>就按照上述方式计算出每一列上的水并加入结果，直至left&gt;right结束。</p>
<p>双指针法虽然是沿用了思路二思路三的方式去找左右最高”墙”，==但是为什么计算leftMax和rightMax的位置相差这么远依然可以有效判断呢？==</p>
<p>例如，对于left墙height[left]，如果leftMax比height[left]高。那么如果rightMax比leftMax高，那么就说明left右边一定存在比height[left]高的墙，那么left列上面一定可以接到水。</p>
<p>即使rightMax对于left右边来说不是最高的墙也无所谓，因为如果不是最高的墙，那么同样存在另一个比height[left]高的墙，那么left列上同样可以接到水，且接水量同样是leftMax-height[left]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax=<span class="number">0</span>,rightMax=<span class="number">0</span>,ans=<span class="number">0</span>,left=<span class="number">1</span>,right=height.length-<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//计算更新leftMax rightMax</span></span><br><span class="line">        leftMax=Math.max(leftMax,height[left-<span class="number">1</span>]);</span><br><span class="line">        rightMax=Math.max(rightMax,height[right+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//比较leftMax和rightMax，找到较低的那一侧</span></span><br><span class="line">        <span class="keyword">if</span> (leftMax&lt;rightMax)&#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax&gt;height[left])ans+=leftMax-height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rightMax&gt;height[right])ans+=rightMax-height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——罗马数字转整数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-13-罗马数字转整数-简单"><a href="#NO-13-罗马数字转整数-简单" class="headerlink" title="NO.13 罗马数字转整数 简单 "></a>NO.13 罗马数字转整数 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/16/Q4As2Q.png" alt="Q4As2Q.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/16/Q4Ar8g.png" alt="Q4Ar8g.png"></p>
<p><font color=red><strong>思路一：哈希表</strong></font> 1.用一个hash表把所有罗马数字和阿拉伯数字相互匹配的特殊值作为键值对存储起来，例如”M,1000”、”CM,900”、”D,500”、”CD，400”。。。2.然后将字符串逐步分割并去hash表进行查询匹配，因为两位长度的罗马数字优先于一位长度的罗马数字，所以每步循环都需要先两位分割匹配再一位分割匹配。3.匹配到hash表的键之后，将对应的值加入结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        所有罗马数字和阿拉伯数字相互匹配的特殊值作为键值对存储起来</span></span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"M"</span>,<span class="number">1000</span>);</span><br><span class="line">        map.put(<span class="string">"CM"</span>,<span class="number">900</span>);</span><br><span class="line">        map.put(<span class="string">"D"</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">"CD"</span>,<span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">"C"</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">"XC"</span>,<span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">"L"</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">"XL"</span>,<span class="number">40</span>);</span><br><span class="line">        map.put(<span class="string">"X"</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">"IX"</span>,<span class="number">9</span>);</span><br><span class="line">        map.put(<span class="string">"V"</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">"IV"</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"I"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        然后将字符串逐步分割并去hash表进行查询匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length(); )&#123;</span><br><span class="line"><span class="comment">//            两位长度的罗马数字优先于一位长度的罗马数字,所以先进行两位长度罗马数字的判断</span></span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;s.length()&amp;&amp;map.containsKey(s.substring(i,i+<span class="number">2</span>)))&#123;</span><br><span class="line">                ans+=map.get(s.substring(i,i+<span class="number">2</span>));</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans+=map.get(s.substring(i,i+<span class="number">1</span>));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——零钱兑换</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="NO-322-零钱兑换-中等"><a href="#NO-322-零钱兑换-中等" class="headerlink" title="NO.322 零钱兑换 中等 "></a>NO.322 零钱兑换 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/08/3vz7RI.png" alt="3vz7RI.png"></p>
<p><strong><font color=red>思路一：深度优先遍历</font></strong> 暴力方法超时！检查所有的组合方式，找出符合要求的组合中硬币数量最少的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coins==<span class="keyword">null</span>||coins.length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    dfs(coins,amount,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans==Integer.MAX_VALUE?-<span class="number">1</span>:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深搜，count记录硬币数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果小于0，说明当前组合不对，回溯</span></span><br><span class="line">    <span class="keyword">if</span> (amount&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等于0说明当前组合正确，如果硬币数量更少，则更新结果</span></span><br><span class="line">    <span class="keyword">if</span> (amount==<span class="number">0</span>)&#123;</span><br><span class="line">        ans=Math.min(ans,count);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">        dfs(coins,amount-coins[i],count+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(amount^n) n是不同面额硬币的种类</p>
<p><strong><font color=red>思路二：动态规划</font></strong> dp数组的含义：dp[i]=x 表示至少x个硬币组成i元，即i元的最优解。</p>
<p>dp数组初始化：长度为amount+1，即0元~amount元。dp[0]=0，0元自然是不需要硬币。1~amount初始化为amount+1，因为硬币面额都是整数无论如何amount元也不会需要amount+1个硬币进行组合。</p>
<p>状态转移：无论当前目标金额是多少，都要从coins列表中取出一个面额，然后目标金额就会较少这个面额。如果dp[当前金额-取出面额]有解，则dp[当前金额]就是在其子问题dp[当前金额-取出面额]的基础上加一个硬币。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Arrays.fill(dp,amount+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//填写dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="comment">//金额i的所有子问题</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">//不存在这个子问题</span></span><br><span class="line">            <span class="keyword">if</span> (i-coin&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//在子问题的基础上加一个硬币，取最小值</span></span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查amount是否有解</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?-<span class="number">1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(amount*n)    n是不同面额种类</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——三数之和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-15-三数之和-中等"><a href="#NO-15-三数之和-中等" class="headerlink" title="NO.15 三数之和 中等 "></a>NO.15 三数之和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/17/QocMLV.png" alt="QocMLV.png"></p>
<p>这道题有一个麻烦的地方，就是需要去重，如果直接简单的三重循环暴力破解的话，除了时间复杂度问题之外还不便于去重。</p>
<p><font color=red><strong>思路一：双指针法</strong></font> 1. 首先对数组进行排序。2. 依次遍历数组元素，每遍历一个元素nums[i]时，就用左右指针指向nums[i]后面元素部分的两端，即指向nums[L]和nums[R]，判断nums[i]、nums[L]和nums[R]之和sum是否等于0，等于0则加入结果集。如果sum&gt;0，则说明需要较小的数字，即”R–”。如果sum&lt;0，则说明需要较大的数字，即”L++”。循环直至左右指针相遇，即后面元素部分已组合完毕，则本次循环结束。3. 如果遍历到某个元素nums[i]已经大于0，则三数之和必然大于0（充分利用排序后的特点，减少无用的比较），结束循环。</p>
<p>然后是该算法去重的思路：4. 如果nums[i]==nums[i-1]，就会导致结果重复，所以应该跳过。5. 如果sum==0的时候,nums[L]==num[L+1]就会导致结果重复，所以应该跳过，L++。6. 如果sum==0的时候，nums[R]=nums[R-1]就会导致结果重复，所以应该跳过，R–。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">3</span>)<span class="keyword">return</span> ans;</span><br><span class="line"><span class="comment">//        1.排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"><span class="comment">//        2. 依次遍历数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="comment">//            如果当前元素已经大于0，那么之后所有的三数之和一定都大于0。结束循环。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//            4. 如果nums[i]==nums[i-1]，就会导致结果重复，所以应该跳过。</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            用左右指针指向nums[i]后面元素部分的两端</span></span><br><span class="line">            <span class="keyword">int</span> L=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R=len-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//            循环直至左右指针相遇，即后面元素部分已组合完毕，则本次循环结束。</span></span><br><span class="line">            <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span> (sum==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//                    三数之和等于0，等于0则加入结果集。</span></span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line"><span class="comment">//                    5. 如果sum\=\=0的时候,nums[L]\=\=num[L+1]就会导致结果重复，所以应该跳过，L++。</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[L]==nums[L+<span class="number">1</span>])L++;</span><br><span class="line"><span class="comment">//                    6. 如果sum\=\=0的时候，nums[R]=nums[R-1]就会导致结果重复，所以应该跳过，R--。</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[R]==nums[R-<span class="number">1</span>])R--;</span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;<span class="comment">//如果sum&gt;0，则说明需要较小的数字，即"R--"</span></span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;<span class="number">0</span>)&#123;<span class="comment">//如果sum&lt;0，则说明需要较大的数字，即"L++"</span></span><br><span class="line">                    L++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——全排列II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97%20II/</url>
    <content><![CDATA[<h2 id="NO-47-全排列II-中等"><a href="#NO-47-全排列II-中等" class="headerlink" title="NO.47 全排列II 中等 "></a>NO.47 全排列II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10yScq.png" alt="10yScq.png"></p>
<p><font color=red><strong>思路一：深度遍历，回溯法</strong></font> 本题和前文<u>46.全排列</u>相似，区别在于本题的数组中可能包含重复元素。</p>
<p>根据上一题的经验，已经知道<strong>每一条分支路径上每个数组元素只能使用一次</strong>，这个问题已经解决了：使用一个nums.length长度的boolean类型的数组标志每个元素的使用情况，false未使用，true已使用。</p>
<p>但是仅仅依靠判断元素的使用情况是不够的，因为数组中可能存在未被使用但是值相等的元素。根据前文<u>40.组合总和II</u>中的经验，<strong>相等的元素不能作为兄弟节点，但是可以作为父子节点</strong>。于是我们就可以<u>先对nums数组排序</u>，再判断每个节点使用的元素是否和之前一个兄弟节点使用的元素相等，相等则剪枝，语句形如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前元素和之前一个兄弟节点使用的元素相等，且相等元素节点不是当前节点的父节点</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>为什么需要” &amp;&amp;!nums[i-1] “，以示例[1,1’,2]来说(只是简单画出了小部分，领会精神即可)：</p>
<p><a href="https://imgchr.com/i/1s3QlF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/05/1s3QlF.md.png" alt="1s3QlF.md.png"></a></p>
<p>剪枝的地方没什么问题，但是[ 2,1,1’ ]这个节点使用元素” 1’ “，该节点的索引是1、且等于nums[0]，如果没有” &amp;&amp;!nums[i-1] “的限制也应该被剪枝。但是这个节点应该被保留，是因为<strong>相等元素允许作为父子节点</strong>，所以” &amp;&amp;!nums[i-1] “的限制是有必要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="comment">//对数组排序，使重复元素紧凑在一起，方便后续剪枝</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">//标记每个元素的使用情况，默认值false表示未使用</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    dfs(flag,<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] flag, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成组合</span></span><br><span class="line">    <span class="keyword">if</span> (track.size()==nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">new</span> ArrayList&lt;&gt;(track)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//当前元素未被使用，防止一条路径上出现一个元素被重复使用</span></span><br><span class="line">        <span class="keyword">if</span> (!flag[i])&#123;</span><br><span class="line">            <span class="comment">//当前元素和之前一个兄弟节点使用的元素相等，且相等元素节点不是当前节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//将当前元素加入组合中，并将元素对应的标志置为true</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            dfs(flag,track);</span><br><span class="line">            <span class="comment">//每次回溯将最后加入的元素移除，并将被移除元素对应的标志置为false</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p> 本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——全排列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-46-全排列-中等"><a href="#NO-46-全排列-中等" class="headerlink" title="NO.46 全排列 中等 "></a>NO.46 全排列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10uGsf.png" alt="10uGsf.png"></p>
<p><font color=red><strong>思路一：深度优先遍历，回溯法</strong></font> 看到全排列，就想到DFS构建树。重点是<strong>每条分支路径上每个数组元素只能使用一次</strong>。可以使用一个nums.length长度的boolean类型的数组标志每个元素的使用情况，false未使用，true已使用。</p>
<p>递归前先检查当前元素是否被使用过，如果使用过就剪枝；如果未使用过就将当前元素加入集合并将对应的标志设置为true。</p>
<p>每次回溯的时候不仅要将最后加入集合的元素移除，还要将被移除元素对应的标志置为false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="comment">//标记每个元素是否被使用过，默认值false表示未使用</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    dfs(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(),flag);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LinkedList&lt;Integer&gt; combination,<span class="keyword">boolean</span>[] flag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成组合</span></span><br><span class="line">    <span class="keyword">if</span> (combination.size()==nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combination));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//当前元素未使用过，防止一条路径上出现一个元素被重复使用</span></span><br><span class="line">        <span class="keyword">if</span> (!flag[i])&#123;</span><br><span class="line">            <span class="comment">//将当前元素加入组合中，并将元素对应的标志置为true</span></span><br><span class="line">            combination.add(nums[i]);</span><br><span class="line">            flag[i]=!flag[i];</span><br><span class="line">            dfs(combination,flag);</span><br><span class="line">            <span class="comment">//每次回溯将最后加入的元素移除，并将被移除元素对应的标志置为false</span></span><br><span class="line">            flag[i]=!flag[i];</span><br><span class="line">            combination.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N*N!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——删除链表的倒数第N个节点</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="NO-19-删除链表的倒数第N个节点-中等"><a href="#NO-19-删除链表的倒数第N个节点-中等" class="headerlink" title="NO.19 删除链表的倒数第N个节点 中等 "></a>NO.19 删除链表的倒数第N个节点 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFV1Ig.png" alt="lFV1Ig.png"></p>
<p><font color=red><strong>思路一：两次遍历</strong></font> 第一次遍历得到链表的长度L，第二次遍历删除第（L-N+1）个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        依然是借助哑节点</span></span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>),q=head;</span><br><span class="line">        dummy.next=head;</span><br><span class="line"><span class="comment">//        第一次遍历获取链表长度</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        第二次遍历找到待删除节点的前一个节点</span></span><br><span class="line">        q=dummy;</span><br><span class="line">        len-=n;</span><br><span class="line">        <span class="keyword">while</span> (len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            len--;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        删除目标节点</span></span><br><span class="line">        q.next=q.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>操作执行了2L-n步，时间复杂度为O(L)。</p>
<p><font color=red><strong>思路二：双指针一次遍历</strong></font> 1. 用两个指针p、q分别指向链表的开头(哑节点)。2. 先让q指针逐步移动到距离p指针n+1的位置上，也就是上p指针和q指针间隔n个节点。3. 让p指针和q指针同时向后移动，直至q指针为null。4. 此时p指针指向的节点的下一个节点就是待删除节点，p.next=p.next.next删除即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode p=dummy;</span><br><span class="line">        ListNode q=dummy;</span><br><span class="line"><span class="comment">//        首先让q指针移动到和p指针间隔n个元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        此时让p和q保持间距的情况下，同时向后移动，直到q为null</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        删除目标节点</span></span><br><span class="line">        p.next=p.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>操作执行了L+n+1步，时间复杂度为O(L)。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——实现strStr()</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0strStr()/</url>
    <content><![CDATA[<h2 id="NO-28-实现strStr-简单"><a href="#NO-28-实现strStr-简单" class="headerlink" title="NO.28 实现strStr() 简单 "></a>NO.28 实现strStr() <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/30/llALfs.png" alt="llALfs.png"></p>
<p>吐槽一下：这道题的难度标识实在是令人纠结，虽然练习题目才是核心，但是题目的难度标识对于我这样的初学者也是不可缺少的参考标识。</p>
<p>题还没读完，脑海里跳出的第一个想法居然是直接用indexOf()。。。还好立刻就否决了这个想法，但是还是在好奇心的驱使下leetcode提交了一次这个”算法”。。。0ms 100%。。。那就等刷完这道题，读一下indexOf()的源码吧！^_^</p>
<p><font color=red><strong>思路一：双指针暴力法</strong></font> 1. 用i和j分别指向haystack字符串和needle字符串的开头。2. 如果haystack的i号字符等于needle的j号字符，则j和i都向后移动。3. 如果haystack的i号字符不等于needle的j号字符，则j回到needle字符串的开头，i也回溯之后继续比较。4. 循环直至haystack遍历完毕或者needle遍历完毕。5. 最后如果j指针没有遍历我能needle则说明haystack串不包含needle串，返回-1；反之则返回i-j。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack==<span class="keyword">null</span>||needle==<span class="keyword">null</span>)<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;haystack.length()&amp;&amp;j&lt;needle.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i=i-j;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j&lt;needle.length()?-<span class="number">1</span>:i-j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<p><font color=red><strong>思路二：Sunday法</strong></font> 该算法的思路相较于KMP十分容易理解，1. 构建一张偏移表，该表主要记录了模式串中的每一个字符，以及每个字符在模式串中出现的最右位置到尾部的距离+1，未在模式串中出现的字符对应的偏移距离都是”模式串长度+1”。2. 有了偏移表之后开始比较，用idx作为当前查询索引，每次截取目标字符串的[idx，idx+模式串长度]子串和模式串比较，如果相等则返回idx。3. 如果不相等，查看子串在目标串中的后一个字符c是否存在于偏移表中，如果存在则idx=idx+偏移表[c]；如果不存在idx=idx+模式串长度+1。循环直至idx+模式串长度&gt;目标字符串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack,String needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hLen=haystack.length(),nLen=needle.length();</span><br><span class="line">        <span class="keyword">if</span> (hLen&lt;nLen)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//        创建偏移表</span></span><br><span class="line">        Map&lt;Character,Integer&gt; offsetMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nLen;i++)&#123;</span><br><span class="line">            offsetMap.put(needle.charAt(i),nLen-i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        开始查找模式串</span></span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        循环直至idx+模式串长度&gt;目标字符串长度</span></span><br><span class="line">        <span class="keyword">while</span> (idx+nLen&lt;=hLen)&#123;</span><br><span class="line"><span class="comment">//            截取目标字符串</span></span><br><span class="line">            String cutHay = haystack.substring(idx, idx + nLen);</span><br><span class="line"><span class="comment">//            如果子串和模式串相等，则返回idx</span></span><br><span class="line">            <span class="keyword">if</span> (cutHay.equals(needle))&#123;</span><br><span class="line">                <span class="keyword">return</span> idx;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                边界处理，如果子串后面已经没有字符，即已经是最后一组子串，则搜索失败</span></span><br><span class="line">                <span class="keyword">if</span>(idx+nLen&gt;=hLen)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//                如果子串在目标串中的后一个字符c是否存在于偏移表中</span></span><br><span class="line">                <span class="keyword">if</span> (offsetMap.containsKey(haystack.charAt(idx+nLen)))&#123;</span><br><span class="line">                    idx+=offsetMap.get(haystack.charAt(idx+nLen));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    idx+=nLen+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)， 但是该算法的平均情况也可以达到O(n)。</p>
<p><font color=red><strong>思路三：KMP法</strong></font> 数据结构课的时候没学透彻，趁这次机会好好学习一下。作为一只弱鸡，就不瞎扯KMP了，直接找个”巨人肩膀”窥探一下KMP的原理。经过多方查找，最终通过<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">阮一峰的一篇文章</a>艰难入门KMP算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tarsize = needle.length();                <span class="comment">//短字符串</span></span><br><span class="line">            <span class="keyword">int</span> scrsize = haystack.length();              <span class="comment">//长字符串</span></span><br><span class="line">            <span class="keyword">if</span>(tarsize == <span class="number">0</span>)                              <span class="comment">//短字符串是0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(tarsize &gt; scrsize)                         <span class="comment">//短字符串 比 长字符串长</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tarsize == scrsize &amp;&amp; needle.equals(haystack))    <span class="comment">//两个字符串相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> start = <span class="number">0</span>;                             <span class="comment">//长字符串的和短字符串比较的第一个字符</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;                          <span class="comment">//长字符串的和短字符串正在比较的相对第一个位置</span></span><br><span class="line">            <span class="keyword">int</span>[] next = getNext(needle);       <span class="comment">//得到next数组</span></span><br><span class="line">            <span class="keyword">while</span> (start &lt;= scrsize - tarsize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.charAt(start + i) == needle.charAt(i))</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span>(i == tarsize)</span><br><span class="line">                        <span class="keyword">return</span> start;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    start = start + i - next[i];</span><br><span class="line">                    i = i &gt; <span class="number">0</span> ? next[i] : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String needle)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tarsize = needle.length();</span><br><span class="line">            <span class="keyword">int</span>[] next =  <span class="keyword">new</span> <span class="keyword">int</span>[tarsize];</span><br><span class="line">            next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tarsize &gt; <span class="number">1</span>)</span><br><span class="line">                next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; tarsize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(needle.charAt(i-<span class="number">1</span>) == needle.charAt(j))   <span class="comment">//</span></span><br><span class="line">                &#123;</span><br><span class="line">                    next[i] = j+<span class="number">1</span>;</span><br><span class="line">                    j++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    j = next[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    next[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>Sunday算法</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——搜索插入位置</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="NO-35-搜索插入位置-简单"><a href="#NO-35-搜索插入位置-简单" class="headerlink" title="NO.35 搜索插入位置 简单 "></a>NO.35 搜索插入位置 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/05/lr9R3t.png" alt="lr9R3t.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 线性查找，找到目标值或者大于目标值元素则停止。否则插入到返回nums.length。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;        </span><br><span class="line">        <span class="keyword">if</span> (nums[i]==target||nums[i]&gt;target)<span class="keyword">return</span> i;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<p><font color=red><strong>思路二：二分法</strong></font> 和普通的二分法变化不大,主要区别在于最后查找失败后不返回-1，而是返回left。</p>
<p>例[1,3,5,6]、target=4。初始化left=0、right=4-1；第一次循环4&gt;3，left=1+1；第二次循环4&lt;5，right=2-1；left&gt;right循环结束，返回left，即插入位置为2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>需要注意right的初始取值，会影响搜索区间继而影响循环终止条件、right移动。</font></p>
<p>时间复杂度：O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——数字转罗马数字</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="NO-12-数字转罗马数字-中等"><a href="#NO-12-数字转罗马数字-中等" class="headerlink" title="NO.12 数字转罗马数字 中等 "></a>NO.12 数字转罗马数字 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/15/QfXSAI.png" alt="QfXSAI.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfOxHA.png" alt="QfOxHA.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 因为题目中说了输入范围是1~3999，所以我们可以用一个二维数组列出每一位上的所有可能：</p>
<p>roman[4][10]={</p>
<p>​        {“”, “I”, “II”, “III”, “IV”, “V”, “VI”, “VII”, “VIII”, “IX”}</p>
<p>​        {“”, “X”, “XX”, “XXX”, “XL”, “L”, “LX”, “LXX”, “LXXX”, “XC”}</p>
<p>​        {“”, “C”, “CC”, “CCC”, “CD”, “D”, “DC”, “DCC”, “DCCC”, “CM”}</p>
<p>​        {“”, “M”, “MM”, “MMM”,””,””,””,””,””,””}</p>
<p>}</p>
<p>然后用一个list&lt;String&gt;存储每一位上的阿拉伯数字的罗马数字表示，最后将String拼起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String[][] roman=<span class="keyword">new</span> String[][]&#123;</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    StringBuilder result=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    result.append(roman[<span class="number">3</span>][num/<span class="number">1000</span>%<span class="number">10</span>]);<span class="comment">//最高位，千位</span></span><br><span class="line">    result.append(roman[<span class="number">2</span>][num/<span class="number">100</span>%<span class="number">10</span>]);<span class="comment">//百位</span></span><br><span class="line">    result.append(roman[<span class="number">1</span>][num/<span class="number">10</span>%<span class="number">10</span>]);<span class="comment">//十位</span></span><br><span class="line">    result.append(roman[<span class="number">0</span>][num%<span class="number">10</span>]);<span class="comment">//个位</span></span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：贪心算法</strong></font> 先用两个数组分别列出罗马数字和阿拉伯数字的所有特殊点，然后将当前的阿拉伯数字与当前最大的单位作比较，每次转换完一个当前最大单位就减去已转换的当前最大单位；然后再和当前最大的单位作比较如果已不足当前最大单位，就用仅次于当前最大单位的下一个最大单位去比较。。。直到当前的阿拉伯数字等于0。</p>
<p><strong>例如</strong>“2978”，一开始最大单位是”M”表示”1000”，就用两个M转换出2000；</p>
<p>当前阿拉伯数字剩余978，已不足当前最大单位”M”,就用仅次于当前最大单位的”CM”表示”900”去比较，用一个CM转换出900；</p>
<p>当前阿拉伯数字剩余78，已不足当前最大单位”CM”,就用仅次于当前最大单位的”D”表示”500”去比较，还是不足，再用次大的单位”CD”表示”400”去比较，还是不足，再用次大的单位”C”表示”100”去比较，还是不足，再用次大的单位”XC”表示”90”去比较，还是不足，再用次大的单位”L”表示”50”去比较，可以用一个L转换出50；</p>
<p>当前阿拉伯数字剩余28，已不足当前最大单位”L”,就用仅次于当前最大单位的”XL”表示”40”去比较，还是不足，再用次大的单位”X”表示”10”去比较，可以用两个X转换出20；</p>
<p>当前阿拉伯数字剩余8，已不足当前最大单位”X”,就用仅次于当前最大单位的”IX”表示”9”去比较，还是不足，再用次大的单位”V”表示”5”去比较，可以用一个V转换出5；</p>
<p>当前阿拉伯数字剩余3，已不足当前最大单位”V”,就用仅次于当前最大单位的”IV”表示”4”去比较，还是不足，再用次大的单位”I”表示”1”去比较，可以用三个I转换出3；</p>
<p>当前阿拉伯数字剩余0，转换结束，输出两个M、一个CM、一个L、两个XX、一个V、三个I，即“MMCMLXXVIII”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        列出所有罗马数字和阿拉伯数字的特殊点</span></span><br><span class="line">        String[] roman=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arab=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//        贪心算法</span></span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> count=num/arab[index];</span><br><span class="line">            <span class="keyword">while</span> (count--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result+=roman[index];</span><br><span class="line">            &#125;</span><br><span class="line">            num%=arab[index];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——求众数II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%B1%82%E4%BC%97%E6%95%B0II/</url>
    <content><![CDATA[<h2 id="NO-229-求众数II-中等"><a href="#NO-229-求众数II-中等" class="headerlink" title="NO.229 求众数II 中等 "></a>NO.229 求众数II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/13/8nXKh9.png" alt="8nXKh9.png"></p>
<p><strong><font color=red>思路一：摩尔投票法</font></strong> 本题是上一题169的姊妹题，本题没有说一定存在这个”较多的元素”。而且本题的众数的数量需要讨论。</p>
<p>n/k的众数最多有k-1个，本题的符合大于n/3的众数最多有3-1=2个。就像169题中要求的大于n/2，很容易就想到最多存在一个。</p>
<p>知道了本题最多存在两个符合要求的元素，那么根据摩尔头条进行改进：仍然是先定下候选人A、B，然后分别有一个计数器count1、count2。</p>
<p>遍历所有元素，如果当前元素投票给A(和A相等)则count1++，如果是投票给B则count++。</p>
<p>如果不投给A和B，检查两个计数器是否等于0，如果等于0则让被投票的num作为新的候选人且相应的计数器置为1；如果计数器都不等于0，则两个计数器都-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> candidate1=<span class="number">0</span>,candidate2=<span class="number">0</span>,count1=<span class="number">0</span>,count2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">//投给A或者B</span></span><br><span class="line">        <span class="keyword">if</span> (num==candidate1)&#123;</span><br><span class="line">            count1++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不投给A和B且A或B等于0</span></span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">            candidate1=num;</span><br><span class="line">            count1++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            candidate2=num;</span><br><span class="line">            count2++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不投给A和B且A和B不等于0</span></span><br><span class="line">        count1--;</span><br><span class="line">        count2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查A和B是否符合要求</span></span><br><span class="line">    count1=count2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">//必须是else if，防止所有元素都相等的情况</span></span><br><span class="line">        <span class="keyword">if</span> (num == candidate1)&#123;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count1&gt;nums.length/<span class="number">3</span>)res.add(candidate1);</span><br><span class="line">    <span class="keyword">if</span> (count2&gt;nums.length/<span class="number">3</span>)res.add(candidate2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    两次遍历</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>摩尔投票算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——盛最多水的容器</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%20/</url>
    <content><![CDATA[<h2 id="NO-11-盛最多水的容器-中等"><a href="#NO-11-盛最多水的容器-中等" class="headerlink" title="NO.11 盛最多水的容器 中等 "></a>NO.11 盛最多水的容器 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/15/QfYcDK.png" alt="QfYcDK.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 最简单的方法就是将所有的垂直线两两组合，每组计算出容纳的值，返回最大的值即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxarea=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;height.length;j++)</span><br><span class="line"><span class="comment">//                (j-i)一定要记得加括号。。。不要做蠢事</span></span><br><span class="line">                maxarea=Math.max(maxarea,Math.min(height[i],height[j])*(j-i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>共有n(n-1)/2种组合，时间复杂度：O(n^2)</p>
<p><font color=red><strong>思路二：双指针法</strong></font> 用两个指针分别指向数组的开头和结尾，每次较短垂直线那端的指针向较长垂直线那端移动一个下标，每次移动之后用maxarea持续存储目前为止获得的最大面积，直到每个垂直线都被访问过一次为止。</p>
<p>套用语句说烂的话：一个木桶能盛多少水，取决于最短的那根木板。双指针法的形成思路和”短板效应“差不多，<u>两根垂直线之间的面积取决于较短的那根垂直线m，所以想要得到更大的面积，较短的那根垂直线m必须要舍弃</u>，因为如果不舍弃m，高最大就是m，而随着指针的移动宽一直在减少，因此面积只会越来越小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxarea=<span class="number">0</span>,l=<span class="number">0</span>,r=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        maxarea=Math.max(maxarea,Math.min(height[l],height[r])*(r-l));</span><br><span class="line">        <span class="keyword">if</span> (height[l]&lt;height[r])&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个元素被访问一次，时间复杂度:O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——缺失的第一个正数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-41-缺失的第一个正数-困难"><a href="#NO-41-缺失的第一个正数-困难" class="headerlink" title="NO.41 缺失的第一个正数 困难 "></a>NO.41 缺失的第一个正数 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/24/38HH7d.png" alt="38HH7d.png"></p>
<p><strong><font color=red>思路一：两次遍历</font></strong> 第一次遍历将每个元素交换到其元素值对应的下标出，第二次遍历检查每个元素的值和其下标是否相等，如不相等则这个下标就是缺失的第一个正数。</p>
<ol>
<li>第一次遍历：<ul>
<li>将所有符合<code>nums[i]大于0且小于length</code>的元素交换到其值对应的下标位置，例如2应当交换到nums[2]的位置、6应当交换到nums[6]的位置。</li>
<li>如果<code>nums[i]==nums[nums[i]]</code>则不需要移动，例如nums[0]==3但是nums[3]==3就不需要移动了。</li>
<li>交换之后再检查nums[i]是否依然需要交换，如果需要交换继续交换，直至nums[i]无需交换再继续向后遍历。</li>
</ul>
</li>
<li>第二次遍历：<ul>
<li>从1开始，如果<code>nums[i]!=i</code>则i就是缺失的第一个正数。</li>
</ul>
</li>
<li>两次遍历结束后：<ul>
<li>如果没有找到缺失的第一个正数，就检查<code>nums[0]==length</code>如果相等则返回length+1，否则返回length</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i]&gt;<span class="number">0</span>&amp;&amp;nums[i]&lt;nums.length&amp;&amp;nums[i]!=nums[nums[i]])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[nums[i]];</span><br><span class="line">            nums[nums[i]]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]!=i)<span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>]==nums.length)<span class="keyword">return</span> nums.length+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    这道题所用的方法比较简单，重点要学习其中的<a href="https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/10661533?fr=aladdin" target="_blank" rel="noopener">抽屉思想</a>。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——螺旋矩阵</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="NO-54-螺旋矩阵-中等"><a href="#NO-54-螺旋矩阵-中等" class="headerlink" title="NO.54 螺旋矩阵 中等 "></a>NO.54 螺旋矩阵 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/02/3R7fAO.png" alt="3R7fAO.png"></p>
<p><strong><font color=red>思路一：按层模拟法</font></strong> 从[0][0]开始模拟顺时针一层一层的遍历所有元素。</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3WBk34.md.png" alt="3WBk34.md.png"></p>
<p>计算层数count：<code>(Min(row，col)+1)/2</code>，因为每次最多有两行两列组成，最少由一行或一列组成。</p>
<p>遍历每一层curr即<code>[0,count)</code>，每层有四次”转弯”：</p>
<ol>
<li>每一层先从左到右遍历一行，即<code>for(i=curr;i&lt;col-curr;i++)matrix[curr][i]</code>。</li>
<li>再从上到下遍历一列，即<code>for(i=curr+1;i&lt;row-curr;i++)matrix[i][col-1-curr]</code>。</li>
<li>再从右到左遍历一行，即<code>for(i=col-1-curr-1;i&gt;=curr;i--)matrix[row-1-i][i]</code>。</li>
<li>最后从下到上遍历一列，即<code>for(i=row-1-curr-1;i&gt;=curr+1;i--)matrix[i][curr]</code>。</li>
</ol>
<p><u>ps：每一层除了第一行是遍历一整行元素，其余三部分都需要注意不要重复遍历”拐点”元素。</u></p>
<p>上述是常规层(两行两列)的遍历；如果只有一行，从右向左遍历时会重复遍历；如果只有一列，从下向上遍历时会重复遍历，如何解决这个问题？</p>
<p>答：只有一行或只有一列时，不进行右向左或下向上的遍历即可。如何判断？<code>row-1-curr==curr</code>说明当前层只有一行；<code>col-1-curr==curr</code>说明当前层只有一列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length,col=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//计算有多少层</span></span><br><span class="line">    <span class="keyword">int</span> count=(Math.min(row,col)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//当前层</span></span><br><span class="line">    <span class="keyword">int</span> curr=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历每一层</span></span><br><span class="line">    <span class="keyword">for</span> (;curr&lt;count;curr++)&#123;</span><br><span class="line">        <span class="comment">//从左向右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = curr; i &lt; col - curr; i++) &#123;</span><br><span class="line">            res.add(matrix[curr][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = curr+<span class="number">1</span>; i &lt; row-curr; i++) &#123;</span><br><span class="line">            res.add(matrix[i][col-<span class="number">1</span>-curr]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>-curr-<span class="number">1</span>; i &gt;= curr&amp;&amp;(row-<span class="number">1</span>-curr!=curr); i--) &#123;</span><br><span class="line">            res.add(matrix[row-<span class="number">1</span>-curr][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>-curr-<span class="number">1</span>; i &gt;= curr+<span class="number">1</span>&amp;&amp;(col-<span class="number">1</span>-curr!=curr); i--) &#123;</span><br><span class="line">            res.add(matrix[i][curr]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——跳跃游戏</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="NO-55-跳跃游戏-中等"><a href="#NO-55-跳跃游戏-中等" class="headerlink" title="NO.55 跳跃游戏 中等 "></a>NO.55 跳跃游戏 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/03/34FoeP.png" alt="34FoeP.png"></p>
<p><strong><font color=red>思路一：贪心算法</font></strong> NO.45跳跃游戏II的姊妹题，思路一样可以结合学习，题解参考<a href="https://blog.csdn.net/qq_42758551/article/details/104562003" target="_blank" rel="noopener">徒手挖地球二三周目</a>。</p>
<p>每次都在本次跳跃范围内找到下一跳最远的位置。如果最后最远的都为都不能到结尾，则false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//end当前跳跃范围，maxPosition记录当前跳跃范围内下一跳最远的位置</span></span><br><span class="line">    <span class="keyword">int</span> end=<span class="number">0</span>,maxPosition=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//记录当前范围内下一跳最远的位置</span></span><br><span class="line">        maxPosition=Math.max(maxPosition,nums[i]+i);</span><br><span class="line">        <span class="comment">//走到当前跳跃最远点</span></span><br><span class="line">        <span class="keyword">if</span> (i==end)&#123;</span><br><span class="line">            <span class="comment">//跳到最远的位置</span></span><br><span class="line">            end=maxPosition;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end&gt;=nums.length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——通配符匹配</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="NO-44-通配符匹配-困难"><a href="#NO-44-通配符匹配-困难" class="headerlink" title="NO.44 通配符匹配 困难 "></a>NO.44 通配符匹配 <font color=#ff0099>困难</font> <a id="more"></a></h1><p><img src="https://s2.ax1x.com/2020/02/13/1O3D54.png" alt="1O3D54.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/13/1O3sPJ.png" alt="1O3sPJ.png"></p>
<p>这道题和NO.10正则表达式匹配看起来很像，正则匹配的题解可以参考<a href="https://blog.csdn.net/qq_42758551/article/details/104286793" target="_blank" rel="noopener">徒手挖地球十六周目</a>中的记录。</p>
<p>这两道题目的区别在于’*’的处理不同，正则中的星号是星号前的字符可以出现0次、1次或多次，而本题中通配符中的星号则是可以匹配任意字符。但是正则中的’.’和通配符中的’?’作用是一样的。</p>
<p>所以说这道题的难点一样是对于’*’的处理。</p>
<p><strong><font color=red>思路一：双指针贪心算法</font></strong> 重点就是我们如何充分的利用’*’。</p>
<p>我们用i和j分别标记s和p的第一个字符下标，即都初始化为0。用istart和jstart分别标记s和p中’*’匹配过的位置，即初始化为-1。</p>
<p>和普通字符串匹配的思路差不多，<code>已经匹配成功的部分就不再考虑了</code>，所以要用i和j标记当前正在比较的字符；但是<code>最近匹配过的&#39;*&#39;</code>可能会被<code>重复使用去匹配更多的字符</code>，所以我们要用istart和jstart分别标记<code>s和p中最近匹配过&#39;*&#39;的位置</code>。可以参考<a href="https://blog.csdn.net/qq_42758551/article/details/104286793" target="_blank" rel="noopener">徒手挖地球十六周目</a>NO.正则表达式匹配的思路一是如何从普通情况延伸到特殊字符的。</p>
<p>s和p匹配过程中可能会遇到的情况：</p>
<ol>
<li>如果<code>i和j标记的字符正好相等或者j字符是&#39;?&#39;</code>匹配成功，则”移除”i和j元素，即<code>自增i、j</code>。</li>
<li>否则如果<code>j字符是&#39;*&#39;</code>依然可以匹配成功，<code>则用istart和jstart分别标记i元素和j元素</code>之后<code>自增j</code>。</li>
<li>再否则如果<code>istart&gt;-1</code>说明之前匹配过’*‘，因为’*‘可以匹配多个字符，所以这里要再次利用这个最近匹配过的’*‘匹配更多的字符，<code>移动i标记istart的下一个字符，再让istart重新标记i元素</code>同时<code>移动j标记jstart的下一个字符</code>。</li>
<li>上述三种情况都不满足，则匹配失败，<code>返回false</code>。</li>
</ol>
<p>最后当s中的字符都判断完毕，则认为s为空，此时需要p为空或者p中只剩下星号的时候，才能成功匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span>||p.isEmpty())<span class="keyword">return</span> s==<span class="keyword">null</span>||s.isEmpty();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,istart=-<span class="number">1</span>,jstart=-<span class="number">1</span>,slen=s.length(),plen=p.length();</span><br><span class="line">    <span class="comment">//判断s的所有字符是否匹配</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;slen)&#123;</span><br><span class="line">        <span class="comment">//三种匹配成功情况以及匹配失败返回false</span></span><br><span class="line">        <span class="keyword">if</span> (j&lt;plen&amp;&amp;(s.charAt(i)==p.charAt(j)||p.charAt(j)==<span class="string">'?'</span>))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j&lt;plen&amp;&amp;p.charAt(j)==<span class="string">'*'</span>)&#123;</span><br><span class="line">            istart=i;</span><br><span class="line">            jstart=j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (istart&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            i=++istart;</span><br><span class="line">            j=jstart+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s中的字符都判断完毕，则认为s为空，此时需要p为空或者p中只剩下星号的时候，才能成功匹配。</span></span><br><span class="line">    <span class="comment">//如果p中剩余的都是*，则可以移除剩余的*</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;plen&amp;&amp;p.charAt(j)==<span class="string">'*'</span>)j++;</span><br><span class="line">    <span class="keyword">return</span> j==plen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(mn)      m、n分别是s和p的长度。</p>
<p><strong><font color=red>思路二：动态规划法</font></strong> 分析步骤依然按照<a href="https://blog.csdn.net/qq_42758551/article/details/104286793" target="_blank" rel="noopener">徒手挖地球十六周目</a>NO.正则表达式匹配思路二的步骤来。</p>
<p>dp数组的含义：dp[i][j]意思是s的前i个元素能否被p的前j个元素成功匹配。</p>
<p>知道了dp数组的含义之后，我们就知道了初始化细节：</p>
<ol>
<li><code>boolean类型</code>的dp数组，大小是<code>[s.length+1][p.length+1]</code>，因为存在s前0个字符和p前0个字符的情况。</li>
<li><code>dp[0][0]一定是true</code>，因为s空串和p空串是可以匹配成功的；<code>dp[1][0]~dp[s.length][0]一定都是false</code>，因为s不为空串而p为空串是不能匹配成功的。</li>
<li><code>dp[0][1]~dp[0][p.length]</code>当s为空串的时候，而p不是空串的时候，当且仅当p的j字符以及前面都为’*’才为true。</li>
<li><code>dp[s.length][p.length]</code>就得到了s和p最终的匹配情况。</li>
</ol>
<p>有了上述理解之后，就可以初始化dp数组了。</p>
<p>然后填写dp数组剩余部分即可，状态转移方程：</p>
<ol>
<li>当<code>s[i]==p[j]或者p[j]==&#39;?&#39;</code>，则<code>dp[i][j]=dp[i-1][j-1]</code>。可以理解为当前字符成功匹配后，只需要考虑之前的字符串是否匹配即可；也可以理解为当前字符匹配成功之后，”移除”当前元素(即不需要再考虑当前元素)。</li>
<li>当<code>p[j]==&#39;*&#39;</code>，则<code>dp[i][j]=dp[i-1][j]||dp[i][j-1]</code>。可以理解为当字符为’*‘的时候会出现两种情况，第一种是’<em>‘需要作为一个字母与s[i]进行匹配；第二种是’\</em>‘需要作为空字符(即不需要’*‘可以直接”移除”)，所以dp[i][j-1]；用逻辑或将两种情况连接，是因为只要有一种情况可以匹配成功则当前匹配成功，有点暴力算法的感觉。</li>
<li>最后当<code>s[i]!=p[j]&amp;&amp;p[j]!=&#39;*&#39;</code>，<code>dp[i][j]=false</code>。这步可以省略，因为dp数组元素的默认值就是false，所以不必要进行显式的赋值为false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span>||p.isEmpty())<span class="keyword">return</span> s==<span class="keyword">null</span>||s.isEmpty();</span><br><span class="line">    <span class="keyword">int</span> slen = s.length(),plen=p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[slen+<span class="number">1</span>][plen+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化dp数组,dp[1][0]~dp[s.length][0]默认值flase不需要显式初始化为false</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//dp[0][1]~dp[0][p.length]只有p的j字符以及前面所有字符都为'*'才为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=plen;j++)dp[<span class="number">0</span>][j]=p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span>&amp;&amp;dp[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//填写dp数组剩余部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> si = s.charAt(i - <span class="number">1</span>),pj=p.charAt(j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (si==pj||pj==<span class="string">'?'</span>)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pj==<span class="string">'*'</span>)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]||dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(mn)    m、n分别是s和p的长度。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——下一个排列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-31-下一个排列-中等"><a href="#NO-31-下一个排列-中等" class="headerlink" title="NO.31 下一个排列 中等 "></a>NO.31 下一个排列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/30/llAom8.png" alt="llAom8.png"></p>
<p><font color=red><strong>思路一：一次遍历法</strong></font> 经过观察发现，降序序列没有更大的排序，例如[9,4,3,2,1]、[7,5,4,2,]等等。</p>
<ol>
<li>从数组nums的最后一个元素开始，逆序遍历寻找第一个非递增元素nums[i]。例如[1,5,4,7,6,5,3,1]，逆序遍历到第一个非递增元素是4。</li>
<li>此时nums[i]元素的右边是一个递减序列，逆序遍历这个递减序列找到大于nums[i]的元素中最小的一个nums[j](此时右边这个序列是有序的，利用这一性质)。例如，上例中4右边的序列中找到5。</li>
<li>交换nums[i]和nums[j]，此时序列变为[1,5,5,7,6,4,3,1]。然而这个序列并不是我们需要的”下一个排列”，将i之后的元素序列翻转后得到[1,5,5,1,3,4,6,7]才是最终结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        逆序找到第一个非递增元素nums[i]</span></span><br><span class="line">        <span class="keyword">int</span> i=nums.length-<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        如果nums本身不是递减序列，逆序找到nums[i]元素右边的递减序列中第一个大于nums[i]的元素</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> j=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span>&amp;&amp;nums[j]&lt;=nums[i])&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            交换nums[i]和nums[j]</span></span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        最后翻转nums[i]右边的元素序列，得到参数数组nums的下一个更大的排列</span></span><br><span class="line">        reverse(nums,i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    从start号索引开始翻转nums数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=start,j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">            swap(nums,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    交换nums数组的i和j号索引元素</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[i];</span><br><span class="line">        nums[i]=nums[j];</span><br><span class="line">        nums[j]=temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，在最坏的情况下，只需要对整个数组进行两次扫描</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——外观数列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-38-外观数列-简单"><a href="#NO-38-外观数列-简单" class="headerlink" title="NO.38 外观数列 简单 "></a>NO.38 外观数列 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/28/1Kc7Q0.png" alt="1Kc7Q0.png"></p>
<p>这道题读题花了我好一会儿，最后还是在别人的帮助下理解题意。。。这个外观数列的意思是：第一项 “1”；第二项描述第一项：1个1，“11”；第三项描述第二项：2个1，“21”；第四项描述第三项：1个2和1个1，“1211”；第五项描述第四项：1个1和1个2和2个1，“111221”。。。。</p>
<p><font color=red><strong>思路一：按序生成每个数列</strong></font> 按顺序依次生成每个“外观数列”，其实就是BF。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">countAndSay</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一项外观数列为"1"</span></span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)<span class="keyword">return</span> <span class="string">"1"</span>;</span><br><span class="line">    String s=<span class="string">"1"</span>;</span><br><span class="line">    <span class="comment">//按序生成n个外观数列，从第二项开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="comment">//temp是当前生成的外观数列、c初始化为前一项的第一个字符、count记录前一项连续相等的的字符</span></span><br><span class="line">        StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">char</span> c = s.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历前一项外观数列的每个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="comment">//如果连续的字符相等，则count计数器增加</span></span><br><span class="line">            <span class="keyword">if</span> (c==s.charAt(j))&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果连续字符不相等，则将连续字符数量和字符拼接至temp</span></span><br><span class="line">                temp.append(count).append(c);</span><br><span class="line">                <span class="comment">//c更新为当前遍历的字符，计数器重置为1</span></span><br><span class="line">                c=s.charAt(j);</span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意，很容易遗漏的一步：将最后未拼接的字符加入temp</span></span><br><span class="line">        temp.append(count).append(c);</span><br><span class="line">        <span class="comment">//更新s</span></span><br><span class="line">        s=temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度不会算。。。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——在排序数组中查找元素的第一个和最后一个位置</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="NO-34-在排序数组中查找元素的第一个和最后一个位置-中等"><a href="#NO-34-在排序数组中查找元素的第一个和最后一个位置-中等" class="headerlink" title="NO.34 在排序数组中查找元素的第一个和最后一个位置 中等 "></a>NO.34 在排序数组中查找元素的第一个和最后一个位置 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/05/lr9WgP.png" alt="lr9WgP.png"></p>
<p>如果不要求时间复杂度，只需要分别正序遍历找左边target和逆序遍历找右边target即可。但是根据题目要求的时间复杂度O(log n)，看出这依然是一个二分查找的变种。</p>
<p><font color=red><strong>思路一：二分法再线性法</strong></font></p>
<ol>
<li>二分法找到target，如果不存在则返回[-1,-1]。</li>
<li>如果nums[mid]==target，利用数组有序的特点， 以mid为中心分别向左向右线性查找，找到最左和最右的target值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result=&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先二分法找到target的下标</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果找到target的下标mid，就以mid为中心分别向左向右线性查找</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">int</span> left_key=mid,right_key=mid;</span><br><span class="line">            <span class="comment">//向左向右线性查找，直至找到不等于target</span></span><br><span class="line">            <span class="keyword">while</span> (left_key&gt;=<span class="number">0</span>&amp;&amp;nums[left_key]==target)left_key--;</span><br><span class="line">            <span class="keyword">while</span> (right_key&lt;nums.length&amp;&amp;nums[right_key]==target)right_key++;</span><br><span class="line">            <span class="comment">//保存最左和最右的target值的下标</span></span><br><span class="line">            result[<span class="number">0</span>]=left_key+<span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>]=right_key-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//终止二分法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">           left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏情况，有序数组中元素都等于target，例如target=8，[8,8,8,8,8,8]，则线性寻找最左最右时需要遍历每个元素。所以时间复杂度是：O(n)。但是因为测试数据的关系，leetcode中这种思路也是可以通过的。</p>
<p><font color=red><strong>思路二：直接二分法分别查找</strong></font></p>
<p>嘴笨，说的比较抽象，其实根据下述方法，动笔在纸上画一画模拟一下就很清晰明了了。</p>
<ol>
<li><p>二分法查找最左target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：<u>当中间值等于target，不能直接返回，而是要收缩right减小搜索区间继续逐步锁定最左的target。</u></p>
<p>最终得到的left(因为循环终止条件时right==left，所以最终left和right是相等的)可以理解成：数组中比target小的元素的个数。所以最终进行简单的判断即可，如果’left==nums.length’说明所有的数都比target小则返回-1，如果’nums[left]==target’则nums[left]就是最左的target，否则数组中没有target返回-1。</p>
</li>
<li><p>二分法查找最右target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：<u>当中间值等于target，不能直接返回，而是要增加left减小搜索区间继续逐步锁定最右的target。</u></p>
<p>因为搜索区间是[0，nums.length)为左闭右开，所以最后判断和返回时需要对left或者right减一，防止越界。这个”减一”也可以这么理解：’if (nums[mid]==target)left=mid+1;’当while循环结束的时候nums[left]的值一定不是target，但是nums[left-1]的值有可能是，所以返回‘nums[right-1]==target?right-1:-1’即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result=&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    result[<span class="number">0</span>]=searchLeft(nums,target);</span><br><span class="line">    result[<span class="number">1</span>]=searchRight(nums,target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最左target</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchLeft</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length;</span><br><span class="line">    <span class="comment">//这里是&lt;而不是&lt;=，因为搜索区间是[0，length)，终止条件是left==right</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid =(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//因为是寻找最左target，所以这里不能直接返回，而是收缩right去锁定左侧边界</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">            <span class="comment">//这里是=mid而不是=mid-1，因为搜索区间是左闭右开</span></span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果target比所有数都大，则返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (left==nums.length)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//终止条件是left==right，所以返回left或者right都可</span></span><br><span class="line">    <span class="keyword">return</span> nums[left]==target?left:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找最右target</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRight</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length;</span><br><span class="line">    <span class="comment">//这里是&lt;而不是&lt;=，因为搜索区间是[0，length)</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//因为是寻找最右target，所以不能直接返回，而是要增大left去锁定左侧边界</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于每次收紧左侧边界都是left=mid+1（因为搜索区间是左闭右开），所以无论是left还是right都需要-1</span></span><br><span class="line">    <span class="keyword">return</span> nums[right-<span class="number">1</span>]==target?right-<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log n)</p>
<p><font color=red><strong>注意事项：</strong></font></p>
<ol>
<li><p><font color=red>二分法中比较麻烦容易出错的点就是搜索区间的确定，因为这会影响到循环条件和搜索区间端点(left和right)的移动。</font></p>
</li>
<li><p><font color=red>思路一中：left=0，right=length-1所以搜索区间是[0，length-1]左闭右闭的，所以循环终止的条件是left&gt;right即while(left&lt;=right)，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid-1排除了mid并且新的搜索区间是[0，mid-1]或者[mid+1，lenght-1]依然是左闭右闭。</font></p>
</li>
<li><p><font color=red>思路二中：left=0，right=length所以搜索区间是[0，length)左闭右开的，所以循环终止的条件是left==right所以while(left&lt;right)即可，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid排除了mid并且新的搜索区间是[0，mid)或者[mid+1，lenght)依然是左闭右闭。</font></p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
</li>
</ol>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——寻找两个有序数组的中位数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-4-寻找两个有序数组的中位数-困难"><a href="#NO-4-寻找两个有序数组的中位数-困难" class="headerlink" title="NO.4 寻找两个有序数组的中位数 困难 "></a>NO.4 寻找两个有序数组的中位数 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><a href="https://imgchr.com/i/1h9jjs" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/09/1h9jjs.png" alt="1h9jjs.png"></a></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 直接合并两个有序数组，然后根据奇偶性找到中位数。但是这种笨办法不能满足时间复杂度的要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] num=<span class="keyword">new</span> <span class="keyword">int</span>[nums1.length+nums2.length];</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//合并两个有序数组</span></span><br><span class="line">    <span class="keyword">while</span> (count&lt;(nums1.length+nums2.length))&#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;nums1.length&amp;&amp;j&lt;nums2.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">                num[count++]=nums1[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                num[count++]=nums2[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i&lt;nums1.length)&#123;</span><br><span class="line">            num[count++]=nums1[i++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j&lt;nums2.length)&#123;</span><br><span class="line">            num[count++]=nums2[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断合并后的数组元素个数的奇偶性</span></span><br><span class="line">    <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//注意这里是2.0，如果是2会导致结果为int类型丢失精度</span></span><br><span class="line">        <span class="keyword">return</span> (num[count/<span class="number">2</span>-<span class="number">1</span>]+num[count/<span class="number">2</span>])/<span class="number">2.0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num[count/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n+m)</p>
<p><strong><font color=red>思路二：二分法</font></strong> 根据题目中要求的时间复杂度O(log(m+n))想到要使用二分法。因此我们就不能合并两个数组了。</p>
<p><u>其实根据上一题我们就不难发现是否合并两个数组并不重要，我们知道两个数组的长度总和是count，知道中位数是第count/2个或者(num[count/2-1]+num[count/2])/2.0就够了。我们困难的是怎样在不同的数组之间进行二分法。</u></p>
<p>我们换个思考方向：我们把“找中位数”看作是”找第k小的数“的特殊情况。可以充分利用数组是有序的这一特点去找第k小的数，每次排除掉k/2个元素。</p>
<p><strong>看一个”寻找第k小的数“例子：</strong></p>
<ol>
<li>假设我们现在要从A和B两个有序数组中找第7小的数字，我们先比较两个数组的第k/2个元素的大小。3&lt;4所以A数组[1,2,3]这三个元素必然不是第7小的数字，所以排除掉。<img src="https://s2.ax1x.com/2020/02/11/1o5FLF.png" alt="1o5FLF.png"></li>
<li>已经排除了3个，所以我们现在需要在两个数组剩余的部分寻找第4小的数。同样的，我们先比较两个数组剩余元素的第k/2个元素的大小，5&gt;3所以B数组[1,3]这两个元素必然不是第4小的元素，所以排除。<img src="https://s2.ax1x.com/2020/02/11/1o5EdJ.png" alt="1o5EdJ.png"></li>
<li>我们继续在两个数组剩余部分寻找第2小的数。我们比较两个数组剩余元素的第k/2个元素，4=4去掉哪个都行，我们统一处理即可，去掉B的4元素。<img src="https://s2.ax1x.com/2020/02/11/1o4zin.png" alt="1o4zin.png"></li>
<li>此时k=1，只需要判断两个数组剩余部分的第一个元素哪个小即可，找到A数组的4就是第7小的数。<img src="https://s2.ax1x.com/2020/02/11/1o5PMT.png" alt="1o5PMT.png"></li>
</ol>
<p>按照上述例子中的算法，会出现一个问题：每次循环都需要取两个数组剩余部分的第k/2个元素进行比较，如果此时<u>某个数组剩余部分不足k/2个元素怎么办？？？</u></p>
<p><strong>再看一个例子：</strong></p>
<ol>
<li>依然是找第7小的数，但是B数组不能取到第k/2个元素，此时取出B数组的最后一个元素和A数组的第k/2个元素作比较即可。<img src="https://s2.ax1x.com/2020/02/11/1o7m7D.png" alt="1o7m7D.png"></li>
<li>此时B数组已空，所以直接返回A数组的第5个元素即可。<img src="https://s2.ax1x.com/2020/02/11/1o7e0O.png" alt="1o7e0O.png"></li>
</ol>
<p>回到本题“寻找中位数”！有了这个”寻找第k小的数“的算法，去寻找两个有序数组的中位数就容易多了。可以看到无论是找第奇数个还是找第偶数个对上述算法并无影响，最终都会因为k==1或一个数组空了，返回寻找结果。</p>
<p><strong>最终，</strong>“寻找中位数”这个算法我们就以递归的方式进行，为了防止数组长度小于k/2，所以每次比较数组的第min(k/2,数组剩余len)个元素，将小的那部分排除之后，将两个新数组继续送入递归，并将k减去排除的元素个数。递归的出口就是k==1或其中一个数组剩余长度为0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = nums1.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = nums2.length;</span><br><span class="line">    <span class="comment">//将奇数和偶数情况统一处理，如果是奇数情况就求两次。这部分也可以用判断分别处理</span></span><br><span class="line">    <span class="keyword">int</span> Kth1=(len1+len2+<span class="number">1</span>)/<span class="number">2</span>,Kth2=(len1+len2+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//注意最后结果是double，如果/2会丢失精度</span></span><br><span class="line">    <span class="keyword">return</span> (findKth(nums1,<span class="number">0</span>,len1-<span class="number">1</span>,nums2,<span class="number">0</span>,len2-<span class="number">1</span>,Kth1)</span><br><span class="line">            +findKth(nums1,<span class="number">0</span>,len1-<span class="number">1</span>,nums2,<span class="number">0</span>,len2-<span class="number">1</span>,Kth2))/<span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums1,<span class="keyword">int</span> start1,<span class="keyword">int</span> end1,<span class="keyword">int</span>[] nums2,<span class="keyword">int</span> start2,<span class="keyword">int</span> end2,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//计算两个数组剩余部分长度</span></span><br><span class="line">    <span class="keyword">int</span> len1=end1-start1+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2=end2-start2+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//很巧妙的一步，让len1总是剩余长度较小的那个，如果出现为空的情况一定是len1</span></span><br><span class="line">    <span class="keyword">if</span> (len1&gt;len2)<span class="keyword">return</span> findKth(nums2,start2,end2,nums1,start1,end1,k);</span><br><span class="line">    <span class="comment">//递归的出口，当某个数组剩余长度为0或者k==1的时候</span></span><br><span class="line">    <span class="keyword">if</span> (len1==<span class="number">0</span>)<span class="keyword">return</span> nums2[start2+k-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">1</span>)<span class="keyword">return</span> Math.min(nums1[start1],nums2[start2]);</span><br><span class="line">    <span class="comment">//比较两个数组剩余部分的第k/2个元素大小，如果越界则取数组最后一个元素进行比较即可</span></span><br><span class="line">    <span class="keyword">int</span> i=start1+Math.min(len1,k/<span class="number">2</span>)-<span class="number">1</span>,j=start2+ Math.min(len2,k/<span class="number">2</span>)-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//排除较小的元素部分，k减去排除元素的个数</span></span><br><span class="line">    <span class="keyword">if</span> (nums1[i]&lt;nums2[j])&#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1,i+<span class="number">1</span>,end1,nums2,start2,end2,k-(i-start1+<span class="number">1</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1,start1,end1,nums2,j+<span class="number">1</span>,end2,k-(j-start2+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log(n+m))</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——整数反转</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="NO-7-整数反转-简单"><a href="#NO-7-整数反转-简单" class="headerlink" title="NO.7 整数反转 简单 "></a>NO.7 整数反转 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/10/QDB4wd.png" alt="QDB4wd.png"></p>
<p>看到题目的第一个想法：先定义一个保存结果数的变量ans，将参数x不断地对10取余，每次取余将余数加上ans*10，当x=0的时候循环结束，取得最终反转后的数ans。</p>
<p>但是这个想法有个问题就是当“ans<em>10+余数”这个操作时可能会溢出，但庆幸的是检查此操作是否会溢出并不是难事，如果”ans\</em>10+余数“会溢出，那么一定有“ans&gt;=IntMax/10”。</p>
<p>即：<u>参数x为整数</u> 1.“ans&gt;IntMax/10”一定会溢出。2.“ans==IntMax/10”由于IntMax=2^31-1=2147483647，所以此时余数如果大于7也会溢出。 <u>参数x为负数</u> 1.“ans&lt;IntMin/10”一定会溢出。2.“ans==IntMin/10”由于IntMin=-2^31=-2147483648 ,所以此时余数如果小于-8也会溢出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans&gt;Integer.MAX_VALUE/<span class="number">10</span>||(ans==Integer.MAX_VALUE/<span class="number">10</span>&amp;&amp;temp&gt;<span class="number">7</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans&lt;Integer.MIN_VALUE/<span class="number">10</span>||(ans==Integer.MIN_VALUE/<span class="number">10</span>&amp;&amp;temp&lt;-<span class="number">8</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            ans=ans*<span class="number">10</span>+temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——旋转图像</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</url>
    <content><![CDATA[<h2 id="NO-48-旋转图像-中等"><a href="#NO-48-旋转图像-中等" class="headerlink" title="NO.48 旋转图像 中等 "></a>NO.48 旋转图像 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/07/1gK3uQ.png" alt="1gK3uQ.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/07/1gKQgS.png" alt="1gKQgS.png"></p>
<p><strong><font color=red>思路一：先转置矩阵，再列对换</font></strong> 很好理解先将图像矩阵转置，再将转置之后的图像矩阵列对换就得到了顺时针旋转90°的效果。把示例在纸上模拟一下就很清楚了：</p>
<p><a href="https://imgchr.com/i/1RJS61" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/08/1RJS61.png" alt="1RJS61.png"></a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//转置矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;matrix[i].length;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=matrix[i][j];</span><br><span class="line">            matrix[i][j]=matrix[j][i];</span><br><span class="line">            matrix[j][i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//列对换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;matrix.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;matrix.length;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=matrix[j][i];</span><br><span class="line">            matrix[j][i]=matrix[j][matrix.length-<span class="number">1</span>-i];</span><br><span class="line">            matrix[j][matrix.length-<span class="number">1</span>-i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——搜索旋转排序数组</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="NO-33-搜索旋转排序数组-中等"><a href="#NO-33-搜索旋转排序数组-中等" class="headerlink" title="NO.33 搜索旋转排序数组 中等 "></a>NO.33 搜索旋转排序数组 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/05/lr9fjf.png" alt="lr9fjf.png"></p>
<p>根据题目的时间复杂度O(log n)，可以排除遍历的想法(遍历的时间复杂度O(n))，需要用二分查找。</p>
<p><font color=red><strong>思路一：二分法</strong></font> 二分查找一个很关键的点就是数组必须是有序的，本题的思路就是先找到有序的那一半，然后进行二分。思路的关键点就是找到有序的那一半，经过观察，数组中间元素左边部分或者右边部分必然有一半是有序的。</p>
<p>mid元素&gt;start元素时左半部分是有序的；否则，右半部分是有序的。如果target不在有序的那半边，则继续二分，并且继续判断剩余部分元素的有序的一半(判断方法一样)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=nums.length-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//        开始二分</span></span><br><span class="line">        <span class="keyword">while</span> (start&lt;=end)&#123;</span><br><span class="line"><span class="comment">//            得到中间元素的下标</span></span><br><span class="line">            <span class="keyword">int</span> mid=start+(end-start)/<span class="number">2</span>;</span><br><span class="line"><span class="comment">//            如果中间元素等于target，返回mid</span></span><br><span class="line">            <span class="keyword">if</span> (target==nums[mid])<span class="keyword">return</span> mid;</span><br><span class="line"><span class="comment">//            如果中间元素大于第一个元素，说明前半部分是有序的,注意这里是&gt;=</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=nums[start])&#123;</span><br><span class="line">                <span class="keyword">if</span> (target&gt;=nums[start]&amp;&amp;target&lt;nums[mid])&#123;</span><br><span class="line">                    end=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    start=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//否则就是后半部分是有序的</span></span><br><span class="line">                <span class="keyword">if</span> (target&lt;=nums[end]&amp;&amp;target&gt;nums[mid])&#123;</span><br><span class="line">                    start=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    end=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5II/</url>
    <content><![CDATA[<h2 id="NO-59-旋转矩阵II-中等"><a href="#NO-59-旋转矩阵II-中等" class="headerlink" title="NO.59 旋转矩阵II 中等 "></a>NO.59 旋转矩阵II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/07/3XskRO.png" alt="3XskRO.png"></p>
<p><strong><font color=red>思路一：按层模拟法</font></strong> 和<a href="https://blog.csdn.net/qq_42758551/article/details/104618018" target="_blank" rel="noopener">徒手挖地球二四周目</a>的NO.54螺旋矩阵的处理方法类似，一层一层遍历，从左到右、由上到下、由右到左、由下到上从1开始每次自增1进行填充。</p>
<p>既然是四次方向变化，那么就需要四个”标记”分别标识上面一行，右边一列，下边一行，左边一列填充到的位置，标识分别叫做t，r，b，l。</p>
<p>有了标识之后从左向右就可以写作<code>for(i=l;i&lt;=r;i++)</code>，即从左开始到右结束；遍历完上面这一行就将标识t++，即t行填充完毕。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] generateMatrix(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span>[][] res=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> num=<span class="number">1</span>,t=<span class="number">0</span>,r=n-<span class="number">1</span>,b=n-<span class="number">1</span>,l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num&lt;=n*n)&#123;</span><br><span class="line">        <span class="comment">//从左到右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) res[t][i]=num++;</span><br><span class="line">        t++;</span><br><span class="line">        <span class="comment">//从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= b; i++) res[i][r]=num++;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="comment">//从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = r; i &gt;= l; i--) res[b][i]=num++;</span><br><span class="line">        b--;</span><br><span class="line">        <span class="comment">//从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = b; i &gt;= t; i--) res[i][l]=num++;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——旋转链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-61-旋转链表-中等"><a href="#NO-61-旋转链表-中等" class="headerlink" title="NO.61 旋转链表 中等 "></a>NO.61 旋转链表 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/09/3zzHQ1.png" alt="3zzHQ1.png"></p>
<p><strong><font color=red>思路一：成环再断</font></strong> 先将链表首尾相连形成环，然后找到旋转后的新链表的新头节点和尾节点，从两者之间断开形成需要的结果。</p>
<p><img src="https://s2.ax1x.com/2020/03/09/8prla4.png" alt="8prla4.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/09/8prurT.png" alt="8prurT.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">rotateRight</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//标记初始链表的结尾，n记录节点数</span></span><br><span class="line">    ListNode oldTail=head;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (oldTail.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        oldTail=oldTail.next;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表成环</span></span><br><span class="line">    oldTail.next=head;</span><br><span class="line">    <span class="comment">//旋转之后的新结尾</span></span><br><span class="line">    ListNode newTail=head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - k % n; i++) &#123;</span><br><span class="line">        newTail=newTail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新头节点</span></span><br><span class="line">    ListNode newHead=newTail.next;</span><br><span class="line">    <span class="comment">//新尾节点和新头节点之间断开</span></span><br><span class="line">    newTail.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——无重复字符的最长子串</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="NO-3-无重复字符的最长子串-中等"><a href="#NO-3-无重复字符的最长子串-中等" class="headerlink" title="NO.3 无重复字符的最长子串 中等 "></a>NO.3 无重复字符的最长子串 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/05/Q8Z9it.png" alt="Q8Z9it.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 先双层for循环划分出所有子串并依次进行是否含有重复子符的判断，如果不含重复字符且子串长度大于当前count所记录的子串长度值，就更新count：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        用两个for循环枚举所有子串。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=s.length();j++)&#123;</span><br><span class="line"><span class="comment">//                调用allUnique方法校验子串中是否都是唯一的字符。</span></span><br><span class="line">                <span class="keyword">if</span> (allUnique(s,i,j))</span><br><span class="line">                    count=Math.max(count,j-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    校验子串中是否都是唯一的字符。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">allUnique</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        Set set=<span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span> (;start&lt;end;start++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(s.charAt(start)))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            set.add(s.charAt(start));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)</p>
<p><font color=red><strong>思路二：滑动窗口法</strong></font> 滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i, j)[i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 [i, j)[i,j) 向右滑动 11 个元素，则它将变为 [i+1, j+1)[i+1,j+1)（左闭，右开）。</p>
<p>1.用一个hashset作为滑动窗口来存储当前窗口 [i , j)。2.检查j索引处的元素是否在已经在滑动窗口set中？3.如果已存在，就将i索引处的元素从滑动窗口中移除，并将i向右滑动一步。4.set中如果不存在j索引元素的重复元素，就将j元素放入滑动窗口中，并将j向右滑动一步，并更新count。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">          Set set=<span class="keyword">new</span> HashSet();</span><br><span class="line">          <span class="keyword">int</span> count=<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span> (i&lt;s.length()&amp;&amp;j&lt;s.length())&#123;</span><br><span class="line">  <span class="comment">//            如果s.charAt(j))已经在set中，</span></span><br><span class="line">              <span class="keyword">if</span> (set.contains(s.charAt(j)))&#123;</span><br><span class="line"><span class="comment">//                将i元素从滑动窗口中移除，并将i向右滑动一步。                  </span></span><br><span class="line">                  set.remove(s.charAt(i++));</span><br><span class="line">              &#125;<span class="keyword">else</span> &#123;    <span class="comment">//s.charAt(j))不在set中，</span></span><br><span class="line"><span class="comment">//                将j元素放入滑动窗口中，并将j向右滑动一步，               </span></span><br><span class="line">                  set.add(s.charAt(j++));</span><br><span class="line"><span class="comment">//                更新count。            </span></span><br><span class="line">                  count = Math.max(j-i,count);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red>优化滑动窗口法：</font>上述方法最坏情况需要执行2n次，我们可以将它减少为执行n次。上述方法中滑动窗口当第j个元素在窗口中发生重复时，<u>就删除第i个元素并且将i向前移动一步</u>，有时候需要i多次移动之后才能使第j个元素不重复。我们可以使用<strong>hashmap</strong>代替hashset，就可以<u>将元素及其下标组成k-v对存入hashmap</u>，当发生第j个元素重复时，就<u>可以一次将i移动到位</u>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,i=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=s.charAt(j);</span><br><span class="line"><span class="comment">//          无论是否更新start，都会更新其map数据结构和结果ans。</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(c))&#123;</span><br><span class="line"><span class="comment">//              移动到集合中重复字符下标的下一位。</span></span><br><span class="line">                i=Math.max(i,map.get(c)+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(c,j);</span><br><span class="line">            count=Math.max(j-i+<span class="number">1</span>,count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路三：预测字符集法</strong></font> 就题说题，针对这道题有一种思路：假设字符集较小（只有字母和符号等等，不含中文等等），我们可以用一个整数数组作为直接的访问表来代替map。例如：<strong>假设</strong>参数字符集只含有字母’a’-‘z’或’A’-‘Z’，就用一个int[24]来包含所有字符集；<strong>假设</strong>参数字符集只含有ASCII，就用一个int[128]来包含所有字符集；<strong>假设</strong>参数字符集只含有扩展ASCII，就用一个int[256]来包含所有字符集。</p>
<p>针对这道题，我们假设字符集只含有ASCII：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        数组作为直接访问表代替map。</span></span><br><span class="line">        <span class="keyword">int</span>[] index=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>,i=<span class="number">0</span>;j&lt;s.length();j++)&#123;</span><br><span class="line"><span class="comment">//            如果index[s.charAt(j)]的值大于i，则说明当前窗口中元素与第j个字符重复了，</span></span><br><span class="line"><span class="comment">//            就让i=index[s.charAt(j)]，使窗口一次性移动到不含重复元素的位置。</span></span><br><span class="line">            i=Math.max(i,index[s.charAt(j)]);</span><br><span class="line"><span class="comment">//            记录窗口中元素个数,如果不重复元素个数大于之前的记录值,就更新count。</span></span><br><span class="line">            count=Math.max(count,j-i+<span class="number">1</span>);</span><br><span class="line"><span class="comment">//            使当前元素作为数组下标并将该元素的下标+1更新至数组,形成类似于hashmap中k-v对的形式。</span></span><br><span class="line">            index[s.charAt(j)]=j+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效数独</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="NO-36-有效数独-中等"><a href="#NO-36-有效数独-中等" class="headerlink" title="NO.36 有效数独 中等 "></a>NO.36 有效数独 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/28/1KcHyV.png" alt="1KcHyV.png"></p>
<p><img src="https://s2.ax1x.com/2020/01/28/1Kcozq.png" alt="1Kcozq.png"></p>
<p><img src="https://s2.ax1x.com/2020/01/28/1KcIWn.png" alt="1KcIWn.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 依次遍历完每一行，每一列，每一个一个子数独。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (board==<span class="keyword">null</span>||board.length&lt;<span class="number">9</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历每一行判断是否有重复</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//遍历完一行之后清空set</span></span><br><span class="line">            set.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="comment">//如果这个元素是1-9，则判断是否重复元素</span></span><br><span class="line">                <span class="keyword">if</span> (board[i][j]&gt;=<span class="string">'1'</span>&amp;&amp;board[i][j]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (set.contains(board[i][j]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        set.add(board[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历每一列判断是否有重复元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">            set.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j]&gt;=<span class="string">'1'</span>&amp;&amp;board[i][j]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (set.contains(board[i][j]))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        set.add(board[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历每一个3*3矩阵是否有重复元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m=<span class="number">0</span>;m&lt;<span class="number">3</span>;m++)&#123;</span><br><span class="line">                set.clear();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">                        <span class="keyword">if</span> (board[i+(<span class="number">3</span>*m)][j+(<span class="number">3</span>*k)]&gt;=<span class="string">'1'</span>&amp;&amp;board[i+(<span class="number">3</span>*m)][j+(<span class="number">3</span>*k)]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                            <span class="keyword">if</span> (set.contains(board[i+(<span class="number">3</span>*m)][j+(<span class="number">3</span>*k)]))&#123;</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                                set.add(board[i+(<span class="number">3</span>*m)][j+(<span class="number">3</span>*k)]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：对所有元素进行三次遍历，O(3n)，在这个题目的约束下(都是9*9的数独)，对81个元素三次遍历，时间复杂度可以看做常数次，即O(1)。</p>
<p><font color=red><strong>思路二：优化暴力法，一次遍历</strong></font> 空间换时间，定义27个数组(9行+9列+9个子数独)。只需要遍历一次，将每个元素与其对应的行数组、列数组、子数独数组中判断是否出现重复即可。</p>
<p><img src="https://s2.ax1x.com/2020/01/31/13aMLD.gif" alt="13aMLD.gif"></p>
<p>判断元素所属的行和列是很容易的，如何判断每个元素属于第几个子数独需要思考：<font color=red><strong>box_index=(i/3)*3+j/3</strong></font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用三个二维数组分别分别记录9行、9列、9个子数独中的元素，用来判断是否重复</span></span><br><span class="line">        <span class="keyword">int</span>[][] rows=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] cols=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] boxes=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="comment">//遍历数独中每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">char</span> c = board[i][j];</span><br><span class="line">                <span class="comment">//如果被遍历元素是数字，则添加到其对应的数组中进行记录</span></span><br><span class="line">                <span class="keyword">if</span> (c&gt;=<span class="string">'1'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                    <span class="keyword">int</span> box_index=(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>;</span><br><span class="line">                    rows[i][c-<span class="string">'0'</span>-<span class="number">1</span>]++;</span><br><span class="line">                    cols[j][c-<span class="string">'0'</span>-<span class="number">1</span>]++;</span><br><span class="line">                    boxes[box_index][c-<span class="string">'0'</span>-<span class="number">1</span>]++;</span><br><span class="line">                    <span class="comment">//判断是否出现重复</span></span><br><span class="line">                    <span class="keyword">if</span> (rows[i][c-<span class="string">'0'</span>-<span class="number">1</span>]&gt;<span class="number">1</span>||cols[j][c-<span class="string">'0'</span>-<span class="number">1</span>]&gt;<span class="number">1</span>||boxes[box_index][c-<span class="string">'0'</span>-<span class="number">1</span>]&gt;<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：数独中9<em>9个元素遍历一次，O(n)，但是在这个题目的约束下(都是9\</em>9的数独)，对81个元素一次遍历，时间复杂度可以看做常数次，即O(1)。</p>
<p><font color=red><strong>思路三：一次遍历，移位编码，位图法</strong></font> 思路二相对于思路一虽然只需要一次遍历，但是空间上付出的“代价”让人不爽，可以借助位图进行优化。这里就不赘述各种算术运算符的作用了，有需要的请百度，都比我说得好。</p>
<p>很容易发现，导致空间浪费的原因是我们申请了int(32位)类型的数组，但是每个元素最大只需要表示到2，也就是每个元素<u>数值部分</u>实际上只需要2位即可。那么我们很容易想到：申请byte(8位)类型就好了。这确实是一种方法，但是我们使用<strong>位图</strong>这种数据结构来完成，节省空间的同时，还可以使算法的速度得到优化。</p>
<p>我们需要申请一个int类型的数组map，但是我们将每个32位元素的<u>前0-8位分别表示同一数字出现在第几行中，9-17位分别表示同一数字出现在第几列中，18-26位分别表示数字出现在第几个子数独中，对应位上0表示该数字未出现过，1表示该数字出现过。</u><font>上述情况可以使用<strong>左移运算</strong>来实现，还需要使用<strong>按位与运算</strong>实现判断某行、某列、某子数独是否存在重复情况，使用<strong>按位或运算</strong>将数字加入对应的数组元素。</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] map=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;<span class="number">9</span>;row++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;<span class="number">9</span>;col++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = board[row][col];</span><br><span class="line">            <span class="keyword">if</span> (c!=<span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="comment">//0-8位表示行号，9-17位表示列号，18-26位表示第几个子数独</span></span><br><span class="line">                <span class="keyword">int</span> index=<span class="number">1</span>&lt;&lt;(<span class="number">0</span>+row)|<span class="number">1</span>&lt;&lt;(<span class="number">9</span>+col)|<span class="number">1</span>&lt;&lt;(<span class="number">18</span>+row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>);</span><br><span class="line">                <span class="comment">//按位与等于0说明该数字不曾在同一行、列、子数独中出现过</span></span><br><span class="line">                <span class="keyword">if</span> ((map[c-<span class="string">'0'</span>-<span class="number">1</span>]&amp;index)==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//按位或将数字加入数组对应元素</span></span><br><span class="line">                    map[c-<span class="string">'0'</span>-<span class="number">1</span>]|=index;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：数独中9<em>9个元素遍历一次，O(n)，但是在这个题目的约束下(都是9\</em>9的数独)，对81个元素一次遍历，时间复杂度可以看做常数次，即O(1)。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>位图</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——用队列实现栈</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    <content><![CDATA[<h2 id="NO-225-用队列实现栈-简单"><a href="#NO-225-用队列实现栈-简单" class="headerlink" title="NO.225 用队列实现栈 简单 "></a>NO.225 用队列实现栈 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/01/3g45b4.png" alt="3g45b4.png"></p>
<p><strong><font color=red>思路一：使用队列API</font></strong> 其实没有太搞明白这个题目的意思。。。leetcode打卡活动第一天题目。</p>
<p>主要是push()方法每次将新加入元素x之前的元素都按序出队并重新入队，这样新元素x就在队头。</p>
<p>然后pop()、top()、empty()直接调用队列API就好。。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; queue.size(); i++) &#123;</span><br><span class="line">            queue.add(queue.remove());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：push()是O(n)，其余三个方法时O(1)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——移除元素</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="NO-27-移除元素-简单"><a href="#NO-27-移除元素-简单" class="headerlink" title="NO.27 移除元素 简单 "></a>NO.27 移除元素 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/29/lK1La6.png" alt="lK1La6.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/29/lK1qVx.png" alt="lK1qVx.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 这道题和第26题如出一辙，题目中的关键点也一样。算法的区别在于对数组第一个元素的处理，26题中第一个元素是不需要”覆盖”的，但是本题的第一个元素有可能需要进行”覆盖”。</p>
<p>用两个指针i和j同时指向0号元素，如果j号指针不等于val，就先将j号元素”覆盖”i号元素再移动i指针，如果j号元素等于val则移动j指针，循环直至j指针遍历完所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line"><span class="comment">//            如果j号指针不等于val，就先将j号元素"覆盖"i号元素再移动i指针</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j]!=val)&#123;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red><strong>思路二：优化双指针法</strong></font> 思路一有一个很明显的弊端，当数组元素和val相等的元素很少时，依然需要移动很多数组元素，例如{[1,2,3,4,5]，val=4}这组输入中”1,2,3”并不需要移动，但是依然会进行自身赋值操作；亦或是{[1,2,3,4,5]，val=1}只需要将5覆盖到1的位置即可，但是思路一的算法并不是这样的。</p>
<p>真对上述出现的问题，对思路一进行优化：1. 双指针i和j分别等于0和nums.length。2. 当i指向的元素等于val时，就先让j-1指向的元素覆盖i指向的元素再进行j–移动。3. 如果i指向元素不等于val，就进行i++移动。4. 循环直至i&gt;=j。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=nums.length;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]==val)&#123;</span><br><span class="line">            nums[i]=nums[j-<span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)，i和j最多遍历j步。在这个方法中，赋值操作的次数等于要删除的元素的数量。因此，如果要移除的元素很少，效率会更高。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字符串的最大公因子</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</url>
    <content><![CDATA[<h2 id="NO-1071-字符串的最大公因子-简单"><a href="#NO-1071-字符串的最大公因子-简单" class="headerlink" title="NO.1071 字符串的最大公因子 简单 "></a>NO.1071 字符串的最大公因子 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/12/8Z46zj.png" alt="8Z46zj.png"></p>
<h3 id="思路一：辗转相除"><a href="#思路一：辗转相除" class="headerlink" title="思路一：辗转相除"></a><strong><font  color=red>思路一：辗转相除</font></strong></h3><p>提示很重要:1&lt;=length</p>
<p>如果两个字符串存在最大公因子X，那么str1就是m个X连接组成的，同样str2就是n个X连接组成的。</p>
<p>即m+n=n+m是两个字符串存在最大公因子的充要条件。</p>
<p>如果确定两个字符串存在最大公因子，就知道两个字符串分别是m或n个X连接组成的。只需要求出两个字符串长度之间的最大公约数即可。</p>
<p>求最大公约数自然是用辗转相除法(欧几里得算法)，具体做法就是： 用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。举例：</p>
<p><img src="https://s1.ax1x.com/2020/03/12/8Zq7se.png" alt="8Zq7se.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">gcdOfStrings</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断是否存在最大公因子</span></span><br><span class="line">    <span class="keyword">if</span> (!(str1+str2).equals(str2+str1))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="comment">//求最大公因子长度</span></span><br><span class="line">    <span class="keyword">int</span> maxLen=GCD(str1.length(),str2.length());</span><br><span class="line">    <span class="keyword">return</span> str1.substring(<span class="number">0</span>,maxLen);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//求辗转相除法求最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">GCD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>?a:GCD(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)    字符串拼接后比较O(n),辗转相除法O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>欧几里得算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字符串相乘</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h2 id="NO-43-字符串相乘-中等"><a href="#NO-43-字符串相乘-中等" class="headerlink" title="NO.43 字符串相乘 中等 "></a>NO.43 字符串相乘 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10uteS.png" alt="10uteS.png"></p>
<p><font color=red><strong>思路一：竖式法</strong></font> 想一想竖式是怎么一步一步进行的，模拟这个过程。两个步骤：</p>
<ol>
<li><u><strong>逆序</strong>(从低位向高位)遍历</u>乘数num2的每个元素，依次与num1相乘。这个过程中需要注意除了num2的第一个元素(个位数)其他元素都需要在低位补充相应数量的0。<strong>每次相乘的结果temp是逆序的。</strong></li>
<li>将num2的每个元素与num1相乘得到的结果temp和ans相加，此时是<u>顺序遍历</u>两个参数。</li>
</ol>
<p>遍历结束之后返回逆序结果的翻转。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num1==<span class="keyword">null</span>||num2==<span class="keyword">null</span>||num1.equals(<span class="string">"0"</span>)||num2.equals(<span class="string">"0"</span>)||num1.equals(<span class="string">""</span>)||num2.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//遍历num2的每个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num2.length();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x = num2.charAt(num2.length()-i-<span class="number">1</span>)-<span class="string">'0'</span>,carry=<span class="number">0</span>;</span><br><span class="line">        StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//除了第一次个位数，其他位需要在低位补相应数量的0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)temp.append(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//依次与num1的每个元素相乘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;num1.length();j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> y = num1.charAt(num1.length()-j-<span class="number">1</span>)-<span class="string">'0'</span>;</span><br><span class="line">            <span class="comment">//注意加上进位值</span></span><br><span class="line">            <span class="keyword">int</span> sum=x*y+carry;</span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line">            temp.append(sum%<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意检查进位值，不要遗漏</span></span><br><span class="line">        <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)temp.append(carry);</span><br><span class="line">        <span class="comment">//将每位上的乘法结果和ans相加</span></span><br><span class="line">        ans=sum(ans,temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后需要将ans翻转，变成正确顺序</span></span><br><span class="line">    <span class="keyword">return</span> ans.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将两个字符串相加</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> StringBuilder <span class="title">sum</span><span class="params">(StringBuilder num1, StringBuilder num2)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>,len=Math.max(num1.length(),num2.length());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//两个字符串长度不相等的时候，短的那个在高位补0</span></span><br><span class="line">        <span class="keyword">int</span> x=i&lt;num1.length()?num1.charAt(i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y=i&lt;num2.length()?num2.charAt(i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意加上进位</span></span><br><span class="line">        <span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line">        carry=sum/<span class="number">10</span>;</span><br><span class="line">        ans.append(sum%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环结束也要检查进位，防止遗漏</span></span><br><span class="line">    <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)ans.append(carry);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(MN)</p>
<p><font color=red><strong>思路二：优化竖式法</strong></font> 该算法是通过两数相乘时，乘数某位与被乘数某位相乘，与产生结果的位置的规律来完成。具体规律如下：</p>
<ol>
<li>乘数 num1 位数为 MM，被乘数 num2 位数为 NN， num1 x num2 结果 res 最大总位数为 M+N。</li>
<li>num1[i] x num2[j] 的结果为 tmp(位数为两位，”0x”,”xy”的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。</li>
</ol>
<p><img src="https://s2.ax1x.com/2020/02/06/166SQe.png" alt="166SQe.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num1==<span class="keyword">null</span>||num2==<span class="keyword">null</span>||num1.equals(<span class="string">"0"</span>)||num2.equals(<span class="string">"0"</span>)||num1.equals(<span class="string">""</span>)||num2.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="comment">//两数相乘积最多为M+N位</span></span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[num1.length()+num2.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=num1.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x = num1.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=num2.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> y = num2.charAt(j) - <span class="string">'0'</span>;</span><br><span class="line">                <span class="keyword">int</span> sum=x*y+res[i+j+<span class="number">1</span>];</span><br><span class="line">                res[i+j+<span class="number">1</span>]=sum%<span class="number">10</span>;</span><br><span class="line">                res[i+j]+=sum/<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            <span class="comment">//积的最高位可能为零，省去不要</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;res[<span class="number">0</span>]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            ans.append(res[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(MN)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字符串转换整数 (atoi)</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%20(atoi)%20/</url>
    <content><![CDATA[<h2 id="NO-8-字符串转换整数-atoi-中等"><a href="#NO-8-字符串转换整数-atoi-中等" class="headerlink" title="NO.8 字符串转换整数 (atoi) 中等 "></a>NO.8 字符串转换整数 (atoi) <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/13/QgMsVP.png" alt="QgMsVP.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/13/QgMDbt.png" alt="QgMDbt.png"></p>
<p><font color=red><strong>思路一：三步串行法</strong></font> 瞎起了一个名字，其实就是简单的三个步骤逐一进行即可：1.跳过所有空格。2.确定正负号。3.找出连续的数字并进行溢出判断。</p>
<p>判断每个字符是否是数字时，.<strong>第一个</strong>字符可以是‘+’或‘-’，其余字符都必须是数字，循环才能继续。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myAtoi</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        如果字符串为空直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        1.去掉所有空格</span></span><br><span class="line">        String s = str.trim();</span><br><span class="line"><span class="comment">//        如果去掉空格之后字符串为空，就返回0</span></span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        2.判断正负号</span></span><br><span class="line">        <span class="keyword">int</span> flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>)==<span class="string">'-'</span>)flag=-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//        3.找出连续的数字</span></span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c=s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>)&#123;<span class="comment">//数字</span></span><br><span class="line">    <span class="comment">//            溢出判断</span></span><br><span class="line">                <span class="keyword">if</span> (flag==<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (ans&gt;Integer.MAX_VALUE/<span class="number">10</span>||(ans==Integer.MAX_VALUE/<span class="number">10</span>&amp;&amp;c-<span class="string">'0'</span>&gt;<span class="number">7</span>))</span><br><span class="line">                        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ans*flag&lt;Integer.MIN_VALUE/<span class="number">10</span>||(ans*flag==Integer.MIN_VALUE/<span class="number">10</span>&amp;&amp;c-<span class="string">'0'</span>&gt;<span class="number">8</span>))</span><br><span class="line">                        <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">                ans=ans*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ((c==<span class="string">'-'</span>||c==<span class="string">'+'</span>)&amp;&amp;i&lt;<span class="number">1</span>)&#123;<span class="comment">//第一个字符c不是数字，但c可以是正负号</span></span><br><span class="line"><span class="comment">//             空方法体，什么也不操作，进入第二次循环</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//既不是数字，也不是第一个正负号字符，直接结束循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans*flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最坏情况每个字符访问一次，所以时间复杂度是：O(n)</p>
<p><font color=red><strong>思路二：正则表达式法</strong></font> 这道题在leetcode上解答很少，因为题比较简单，大神都不屑于留恋。。</p>
<p>最简单的方法直接用正则，贴一个别人的python解法，一行代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> max(min(int(*re.findall(<span class="string">'^[\+\-]?\d+'</span>, s.lstrip())), <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span>), <span class="number">-2</span>**<span class="number">31</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最后一个单词的长度</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="NO-58-最后一个单词的长度-简单"><a href="#NO-58-最后一个单词的长度-简单" class="headerlink" title="NO.58 最后一个单词的长度 简单 "></a>NO.58 最后一个单词的长度 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/06/3qBaB6.png" alt="3qBaB6.png"></p>
<h3 id="思路一：逆序"><a href="#思路一：逆序" class="headerlink" title="思路一：逆序"></a><strong><font color=red>思路一：逆序</font></strong></h3><p>没什么好说的，从后往前找。注意trim()去空格</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLastWord</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    String str = s.trim();</span><br><span class="line">    <span class="keyword">int</span> i=str.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(i)==<span class="string">' '</span>)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str.length()-i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字母异位词分组</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h2 id="NO-49-字母异位词分组-中等"><a href="#NO-49-字母异位词分组-中等" class="headerlink" title="NO.49 字母异位词分组 中等 "></a>NO.49 字母异位词分组 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/07/1gKM38.png" alt="1gKM38.png"></p>
<p><strong><font color=red>思路一：算术基本定理法</font></strong> 这是一个非常巧妙的方法。</p>
<p>算术基本定理(唯一分解定理)： 任何一个大于 1 的自然数都可以分解成一些素数的乘积；并且在不计次序的情况下，这种分解方式是唯一的。 ——欧几里得</p>
<ol>
<li>先申请一个包含26个不重复素数的数组prime[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103 ]，一个HashMap&lt;Interger,List&lt;String&gt;&gt;。</li>
<li>将字符串的每个字符减去’a’映射出对应的素数，将字符串和其映射出的素数的乘积作为键值对保存到哈希表中，最后哈希表中的所有List&lt;String&gt;作为结果集即可。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//26个字母分别对应一个素数</span></span><br><span class="line">    <span class="keyword">int</span>[] prime=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>, <span class="number">103</span>&#125;;</span><br><span class="line">    HashMap&lt;Integer,List&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> key=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs[i].length();j++)&#123;</span><br><span class="line">            <span class="comment">//字符串的每个字符对应的素数的乘积key</span></span><br><span class="line">            key*=prime[strs[i].charAt(j)-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            map.get(key).add(strs[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            map.put(key,<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">            map.get(key).add(strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><u>ps：此方法有一个严重的问题，key很容易发生溢出。</u></strong>最直接的解决方法就是采用大数类型的key。</p>
<p>时间复杂度：O(n*k)，k是字符串的最大长度</p>
<p><strong><font color=red>思路二：排序数组分类法</font></strong> 申请一个HashMap&lt;String,List&gt;，将每个字符串中的字符按照字典顺序排序后作为key、字符串本身作为value中的集合的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历每个字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">        <span class="comment">//将么个字符串中的字符按字典排序后作为key</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = strs[i].toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        String key = String.valueOf(chars);</span><br><span class="line">        <span class="comment">//key作为key，strs[i]作为value集合中的元素</span></span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))map.put(key,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        map.get(key).add(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*klogk) n为元素个数，k为最长字符串长度，klogk是排序的时间复杂度</p>
<p><strong><font color=red>思路三：字符计数分类法</font></strong> 和思路三差不多的想法，申请一个HashMap&lt;String,List&gt;，将每个字符串中字符出现的字数统计之后转换成”n#n#n#n#….”形式的字符串作为key。例如abc转换为”1#1#1#0#0#…”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    <span class="keyword">if</span> (strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    HashMap&lt;String,List&lt;String&gt;&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">        <span class="comment">//统计字符串中每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">int</span>[] count=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;strs[i].length();j++)&#123;</span><br><span class="line">            count[strs[i].charAt(j)-<span class="string">'a'</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将计数器转换成n#n#n#n#格式</span></span><br><span class="line">        String key=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;count.length;k++)&#123;</span><br><span class="line">            key+=count[k]+<span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))map.put(key,<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        map.get(key).add(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(map.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nk)，k是最长字符串的长度</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>算术基本定理法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最大子序和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%20/</url>
    <content><![CDATA[<h2 id="NO-53-最大子序和-简单"><a href="#NO-53-最大子序和-简单" class="headerlink" title="NO.53 最大子序和 简单 "></a>NO.53 最大子序和 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/01/3g44rF.png" alt="3g44rF.png"></p>
<p><strong><font color=red>思路一：动态规划法</font></strong> 分析dp那就要先分析dp[i]的含义：以第i元素结尾的最大序列和。</p>
<p>初始化：dp[0]以第0号元素结尾的序列只有nums[0]本身，所以<code>dp[0]=nums[0]</code>。</p>
<p>转移方程：<code>dp[i]=Max(dp[i-1]+nums[i],nums[i])</code>，因为dp[i-1]是以i-1为结尾的序列和中的最大值，所以我们想找nums[i]结尾的最大序列和只需要比较”前一个最大序列和+nums[i]”和”nums[i]”。举个例子：</p>
<p><img src="https://s2.ax1x.com/2020/03/01/3g4oVJ.md.png" alt="3g4oVJ.md.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//填写dp数组同时用max记录当前最大的序列和</span></span><br><span class="line">    <span class="keyword">int</span> max=dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i]=Math.max(nums[i],dp[i-<span class="number">1</span>]+nums[i]);</span><br><span class="line">        max=Math.max(max,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过思考不难发现，并不需要开辟一个数组来保存每一个子序和。每次填写只需要关心上一次状态值即可，且每个状态值只需要使用一次。所以我们可以用一个int变量代替dp数组即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">int</span> dp=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//更新当前i结尾的最大序列和同时用max记录最大的序列和</span></span><br><span class="line">    <span class="keyword">int</span> max=dp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp=Math.max(nums[i],dp+nums[i]);</span><br><span class="line">        max=Math.max(max,dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最小路径和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-64-最小路径和-中等"><a href="#NO-64-最小路径和-中等" class="headerlink" title="NO.64 最小路径和 中等 "></a>NO.64 最小路径和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/12/8Z4gQs.png" alt="8Z4gQs.png"></p>
<p><strong><font  color=red>思路一：动态规划</font></strong> 我们要找最小路径和，一定是走数值较小的位置并且不往回走不绕路，又因为是从左上走到右下，所以每次都向右或者向下移动。</p>
<p>dp数组的含义：dp[i][j]走到[i][j]位置的最小路径和。</p>
<p>初始化：dp[0][0]=[0][0]</p>
<p>状态转移：dp[i][j]=Min(dp[i-1][j]+dp[i][j-1])+[i][j]，因为每次只能向右或向下移动，所以[i][j]选择上方[i-1][j]或者左方[i][j-1]较小的路径走过来加上当前位置本身的值。要注意第一行没有上方、第一列没有左方。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length,col=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[row][col];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="comment">//第一行</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;j!=<span class="number">0</span>)dp[i][j]=dp[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">            <span class="comment">//第一列</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)dp[i][j]=dp[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">            <span class="comment">//中间部分</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j!=<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)dp[i][j]=Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            <span class="comment">//第一个元素[0][0]</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(row<em>col)    空间复杂度：O(row\</em>col)</p>
<p><strong><font  color=red>优化空间复杂度</font></strong> 直接在grid数组自身每个位置记录对应的最小路径和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length,col=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="comment">//第一行</span></span><br><span class="line">            <span class="keyword">if</span> (i==<span class="number">0</span>&amp;&amp;j!=<span class="number">0</span>)grid[i][j]=grid[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">            <span class="comment">//第一列</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j==<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)grid[i][j]=grid[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">            <span class="comment">//中间部分</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j!=<span class="number">0</span>&amp;&amp;i!=<span class="number">0</span>)grid[i][j]=Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>])+grid[i][j];</span><br><span class="line">            <span class="comment">//第一个元素[0][0]</span></span><br><span class="line">            <span class="keyword">else</span> grid[i][j]=grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grid[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(row*col)    空间复杂度：O(1)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-16-最接近的三数之和-中等"><a href="#NO-16-最接近的三数之和-中等" class="headerlink" title="NO.16 最接近的三数之和 中等 "></a>NO.16 最接近的三数之和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/18/QHphH1.png" alt="QHphH1.png"></p>
<h3 id="思路一：暴力破解法"><a href="#思路一：暴力破解法" class="headerlink" title="思路一：暴力破解法"></a><font color=red><strong>思路一：暴力破解法</strong></font></h3><p>用list保存所有的三数之和的情况，然后找出最接近target的数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">    	<span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">3</span>)<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"error of argument!"</span>);</span><br><span class="line"><span class="comment">//        用list保存所有的三数之和</span></span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=j+<span class="number">1</span>;k&lt;len;k++)&#123;</span><br><span class="line">                    list.add(nums[i]+nums[j]+nums[k]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        遍历list找出最接近target的数</span></span><br><span class="line">        <span class="keyword">int</span> ans=list.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(target-ans)&gt;Math.abs(target-i))</span><br><span class="line">                    ans=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)</p>
<h3 id="思路二：双指针法"><a href="#思路二：双指针法" class="headerlink" title="思路二：双指针法"></a><font color=red><strong>思路二：双指针法</strong></font></h3><p>和第15题的双指针法思路类似，本题免去了去重的操作。1. 先对数组排序，时间复杂度O(nlogn)。2. 依次遍历每个元素nums[i]。3. 然后用前后指针L=i+1和R=nums.length-1分别指向nums[i]后面部分的开头nums[L]和结尾nums[R]。4. 得到sum=nums[i]+nums[L]+nums[R]，如果sum更接近target，就更新ans。5. 如果sum==target，就已经找到最接近target的三数之和，返回sum；如果sum&gt;target，说明需要小一点的数来组合，即R–；如果sum&lt;target，说明需要大一点的数来组合，即L++。6. 如果没有得到sum==target，那么每次双指针都需要遍历所有”后面所有元素”，即while(L&lt;R)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len= nums.length,ans=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">3</span>)<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"error of argument!"</span>);</span><br><span class="line"><span class="comment">//        对数组排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"><span class="comment">//        依次遍历每个元素nums[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="comment">//            然后用前后指针L和R分别指向nums[i]后面部分的开头和结尾</span></span><br><span class="line">            <span class="keyword">int</span> L=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R=len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum=nums[i]+nums[L]+nums[R];</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(target-ans)&gt;Math.abs(target-sum))&#123;</span><br><span class="line">                    ans=sum;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum==target)&#123;<span class="comment">//如果sum==target，那就已经找到最接近target的三数之和</span></span><br><span class="line">                    <span class="keyword">return</span> ans;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;target)&#123;<span class="comment">//如果sum&lt;target，说明需要大一点的数来组合，即L++</span></span><br><span class="line">                    L++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;target)&#123;<span class="comment">//如果sum&lt;target，说明需要小一点的数来组合，即R--；</span></span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)       整个遍历过程，固定值为 n 次，双指针为 n 次。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长上升子序列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-65-最长上升子序列-中等"><a href="#NO-65-最长上升子序列-中等" class="headerlink" title="NO.65 最长上升子序列 中等 "></a>NO.65 最长上升子序列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8QQPq1.png" alt="8QQPq1.png"></p>
<p>刚看到题，我以为寻找的这个上升子序列需要是连续的递增元素，所以我想双指针。发现行不通，重新审题发现，示例中的子序列元素不是连续的。。。</p>
<h3 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a><strong><font color=red>思路一：动态规划</font></strong></h3><p>dp数组含义：dp[i]nums前i个元素中最长上升子序列的长度。</p>
<p>初始化：初始状态全部为1，因为每个元素自身至少是长度为1子序列。</p>
<p>状态转移：填写dp[i]时遍历j∈[0,i，</p>
<p>如果i元素&gt;j元素则当前元素i可以接在j元素之后作为上升子序列dp[i]=Max(dp[i],dp[j]+1)；</p>
<p>否则i元素&lt;=j元素当前元素i不能拼接在j元素之后就忽略。</p>
<p>每次填写完dp[i]更新当前最长上升子序列长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">//如果i元素&gt;j元素，则i可以接在j元素后面作为上升子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[j])dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最大长度</span></span><br><span class="line">        maxLen=Math.max(maxLen,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h3 id="思路二：TreeSet"><a href="#思路二：TreeSet" class="headerlink" title="思路二：TreeSet"></a><strong><font color=red>思路二：TreeSet</font></strong></h3><p>JAVA Api中的TreeSet有ceiling(x)方法，取大于x的数，如果不存在则返回null。(此方法时间复杂度O(logn)，但是最坏情况下会退化到O(n))</p>
<p>按序遍历nums，到TreeSet中取大于num的数x，如果存在x则删除x并将num加入set，如果不存在就是所有的数都小于num就将num加入set。</p>
<p>最后返回set的大小即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TreeSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        Integer x = set.ceiling(num);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.remove(x);</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏时间复杂度仍然是：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长公共前缀</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<h2 id="NO-14-最长公共前缀-简单"><a href="#NO-14-最长公共前缀-简单" class="headerlink" title="NO.14 最长公共前缀 简单 "></a>NO.14 最长公共前缀 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/20/QX69xS.png" alt="QX69xS.png"></p>
<p><font color=red><strong>思路一：依次LCP法</strong></font>假设输入数组为[“leetcode”,”leetcodes”,”leetgo”,”letsgo”]：1. 我们先让0号元素和1号元素求公共前缀 LCP(0号元素，1号元素)求出最长公共前缀prefix=”leetcode”。2. 然后prefix=LCP[prefix，2号元素]求出prefix=leet。3. prefix=LCP[prefix，3号元素]求出prefix=le。求出最终的答案”le”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        如果数组元素个数为0，返回""</span></span><br><span class="line">        <span class="keyword">if</span> (strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="comment">//        假设最长公共前缀是数组第一个元素</span></span><br><span class="line">        String prefix=strs[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//        从前向后数组元素依次和当前最长公共前缀比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;strs.length;i++)&#123;</span><br><span class="line">            <span class="comment">//如果当前被比较的元素不含有当前最长前缀，就将当前最长前缀从后面减少一位</span></span><br><span class="line">            <span class="keyword">while</span> (strs[i].indexOf(prefix)!=<span class="number">0</span>)&#123;</span><br><span class="line">                prefix=prefix.substring(<span class="number">0</span>,prefix.length()-<span class="number">1</span>);</span><br><span class="line"><span class="comment">//                如果当前最长前缀已经为空，则说明数组中的元素没有公共前缀，直接返回""</span></span><br><span class="line">                <span class="keyword">if</span> (prefix.isEmpty())<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prefix;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(s)  s是数组中每个字符串的字符个数之和</p>
<p>空间复杂度:O(1)</p>
<p><font color=red><strong>思路二：优化依次LCP法</strong></font> 上述方法中，无论数组每个元素的长短我们都需要从第一个数组元素比较到最后一个数组元素，所以有一个明显的问题：如果数组中最后一个元素非常短，但是我们仍然需要比较s次。</p>
<p>可以将思路一的算法改为从前往后枚举字符串的每一列，先比较每个字符串相同列上的字符（即不同字符串相同下标的字符）然后再进行对下一列的比较。 </p>
<p>依然假设输入数组为[“leetcode”,”leetcodes”,”leetgo”,”letsgo”]：1. 第一次循环i=0先用0号元素的第一个字符”l”，去和1号元素的第一个字符比较，相等；继续去和第2号元素的第一个字符比较，相等；继续去和第3号元素的第一个字符比较，相等；2. 第二次循环i=1再用0号元素的第二个字符”e”，去和1号元素的第二个字符比较，相等；继续去和第2号元素的第二个字符比较，相等；继续去和第3号元素的第二个字符比较，相等；3. 第三次循环i=2再用0号元素的第三个字符”e”，去和1号元素的第三个字符比较，相等；继续去和第2号元素的第三个字符比较，相等；继续去和第3号元素的第三个字符比较，不相等，则返回数组0号元素[0,i)字符，即”le”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs==<span class="keyword">null</span>||strs.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line"><span class="comment">//        将数组的0号元素的每个字符逐一取出进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strs[<span class="number">0</span>].length();i++)&#123;</span><br><span class="line"><span class="comment">//            取出数组0号元素的i号字符</span></span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line"><span class="comment">//            将c和数组的每个元素的i号字符进行比较</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;strs.length;j++)&#123;</span><br><span class="line"><span class="comment">//                如果某个元素的所有字符都已比较完毕（即最短的元素）或者某个元素的第i个字符和c不相等</span></span><br><span class="line">                <span class="keyword">if</span> (i==strs[j].length()||strs[j].charAt(i)!=c)&#123;</span><br><span class="line"><span class="comment">//                    则0号元素的[0，i)号字符就是公共前缀</span></span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>,i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(s)  s是数组中每个字符串的字符个数之和。在最坏情况下，本算法的效率与算法一相同，但是最好的情况下，算法只需要进行 n*minLen 次比较，其中minLen是数组中最短字符串的长度。</p>
<p>空间复杂度:O(1)</p>
<p><font color=red><strong>思路三：分治法</strong></font> 其实这方法也是上述的依次LCP法的一种优化方法，LCP(s1,s2,…,sn)=LCP(LCP(s1,s2,…,smid),LCP(smid+1,smid+2,…sn))。</p>
<p>先将数组元素分成两部分，分别求LCP得到lcpLeft和lcpRight，最后求LCP(lcpLeft，lcpRight)得到prefix。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;    </span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span> , strs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">        String lcpRight =  longestCommonPrefix(strs, mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">commonPrefix</span><span class="params">(String left,String right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(left.length(), right.length());       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">            <span class="keyword">return</span> left.substring(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.substring(<span class="number">0</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(S)，S是所有字符串中字符数量的总和，S=m∗n。</p>
<p>空间复杂度：O(m*log(n))</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>分治算法</tag>
        <tag>LCP</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="NO-32-最长有效括号-困难"><a href="#NO-32-最长有效括号-困难" class="headerlink" title="NO.32 最长有效括号 困难 "></a>NO.32 最长有效括号 <font color=#ff0099>困难</font> <a id="more"></a></h1><p><img src="https://s2.ax1x.com/2020/02/22/3QkcHf.png" alt="3QkcHf.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 遍历所有偶数长度的子串，得到最长的有效括号序列。但是此方法会超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//只要偶数长度的，奇数长度一定无效</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;=s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(s.substring(i,j)))&#123;</span><br><span class="line">                maxLen=Math.max(maxLen,j-i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断括号序列是否有效</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">            stack.push(<span class="string">'('</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)</p>
<p><strong><font color=red>思路二：优化暴力法</font></strong> 简单的优化上面的方法，暴力法会有很多可以避免的判断，例如我们判断下标为0长度是2的序列是有效的，接下来判断长度为4、为6。。。的序列的时候，依然要从0开始判断，实际上并不需要，因为每个序列的前一个序列已经判断过之前的部分是有效的了。</p>
<p>因为题目中说只有’(‘和’)’两种字符，所以我们用1表示’(‘、用-1表示’)’。用count记录每个序列的和，如果小于0则说明’)’过多了当前序列无效，如果最终count等于0，则说明当前序列有效，更新有效序列长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历所有子串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="comment">// ( +1,) -1</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(j)==<span class="string">'('</span>)count++;</span><br><span class="line">            <span class="keyword">else</span> count--;</span><br><span class="line">            <span class="comment">//小于0说明 )比(多，无效序列</span></span><br><span class="line">            <span class="keyword">if</span> (count&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//有效序列，更新maxLen</span></span><br><span class="line">            <span class="keyword">if</span> (count==<span class="number">0</span>)maxLen=Math.max(maxLen,j-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><strong><font color=red>思路三：动态规划</font></strong> dp数组的含义：dp[i]以下标为i结尾的有效序列的最大长度。</p>
<p>初始化：dp数组元素都初始化为0。</p>
<p>填写dp数组，状态转移方程：</p>
<ol>
<li><p>如果i是’(‘，以左括号结尾的序列一定是无效序列，所以<code>依然为0</code>。</p>
</li>
<li><p>如果i是’)’，以有括号结尾的序列分两种情况：</p>
<ul>
<li><p>如果i-1是’(‘，组成形如”()”。<code>dp[i]=dp[i-2]+2</code>，意思是在前一个有效序列的长度基础上加上当前结尾长度为2的”()”。</p>
<p>例如，dp[2]=dp[2-2]+2=2、dp[4]=dp[4-2]+2=4</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31i82j.png" alt="31i82j.png"></p>
</li>
<li><p>如果i-1是’)’，组成形如”))”。需要检查<code>i-dp[i-1]-1</code>是否为’(‘，意思是检查i的前一个有效序列之前是否为’(‘。<u>如果是左括号</u>，则可以和i组成”()”，则<code>dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2</code>意思是<code>i之前的有效序列长度</code>加上<code>与i进行匹配的左括号前面的有效序列长度</code>加上<code>新增的序列长度2</code>。<u>如果不是左括号</u>，则无法与i进行匹配，即当前i结尾的是无效序列，<code>依然为0</code>。</p>
<p>例如，dp[6]=dp[6-1]+dp[6-dp[6-1]-2]+2=6</p>
<p><img src="https://s2.ax1x.com/2020/02/23/31AOdx.png" alt="31AOdx.png"></p>
</li>
</ul>
</li>
</ol>
<p>==实现的时候要注意判断下标越界。==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line">    <span class="comment">//遍历每个字符并填写dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="comment">//如果i是')'，分两种情况</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">            <span class="comment">//情况一，i-1是'('。则可以和i有效组合。</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i-<span class="number">1</span>)==<span class="string">'('</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (i-<span class="number">2</span>&gt;=<span class="number">0</span>) dp[i]=dp[i-<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i]=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//情况二，i-1是')'</span></span><br><span class="line">                <span class="comment">//如果i之前的有效序列之前是个左括号，则可以和i有效组合。否则i结尾的序列无效</span></span><br><span class="line">                <span class="keyword">if</span> (i-dp[i-<span class="number">1</span>]-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;s.charAt(i-dp[i-<span class="number">1</span>]-<span class="number">1</span>)==<span class="string">'('</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i-dp[i-<span class="number">1</span>]-<span class="number">2</span>&gt;=<span class="number">0</span>)dp[i]=dp[i-<span class="number">1</span>]+dp[i-dp[i-<span class="number">1</span>]-<span class="number">2</span>]+<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i]=dp[i-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新maxLen</span></span><br><span class="line">        maxLen=Math.max(maxLen,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    大量的if else可以用三元运算符优化。</p>
<p>空间复杂度：O(n)</p>
<p>   <strong><font color=red>思路四：两次遍历</font></strong> 到这里，这个找最长有效括号的算法已经从n^3优化到了n。但是通过学习大佬的题解，发现另一种解法，时间复杂度是O(n)的同时将空间复杂度降至了常数。</p>
<p>先顺序扫描一遍，同时用left和right保存左右括号的个数：</p>
<ul>
<li>如果left&gt;right，则继续扫描。</li>
<li>如果left&lt;right，则一定是无效序列，归零left、right。</li>
<li>如果left==right，则是有效序列，更新maxLen。</li>
</ul>
<p>归零left、right。再逆序扫描一遍，同样的校验方法(逆序遍历则是left&gt;right无效)。</p>
<p>最终得到maxLen。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=<span class="number">0</span>,maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//正序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">//统计左右括号数量</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右括号数量相等，则有效序列，更新maxLen</span></span><br><span class="line">        <span class="keyword">if</span> (left==right)&#123;</span><br><span class="line">            maxLen=Math.max(maxLen,right+left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (left&lt;right)&#123;<span class="comment">//右括号多于左括号，无效序列，重置计数</span></span><br><span class="line">            left=<span class="number">0</span>;</span><br><span class="line">            right=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    left=<span class="number">0</span>;</span><br><span class="line">    right=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//逆序遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//统计数量</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)==<span class="string">')'</span>)&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果左右括号数量相等，有效序列，更新maxLen</span></span><br><span class="line">        <span class="keyword">if</span> (left==right)&#123;</span><br><span class="line">            maxLen=Math.max(maxLen,right+left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (left&gt;right)&#123;<span class="comment">//如果左括号多于有括号，无效序列，重置计数</span></span><br><span class="line">            left=<span class="number">0</span>;</span><br><span class="line">            right=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    </p>
<p>空间复杂度：O(1)</p>
<p>最开始很迷惑为什么两次遍历可以得到正确的maxLen，后来在纸上写了几种不同情况的括号序列模拟了一下，不由得感叹：妙啊！牛逼的算法就是简单！有效！</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——组合总和II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%20II/</url>
    <content><![CDATA[<h2 id="NO-40-组合总和-II-中等"><a href="#NO-40-组合总和-II-中等" class="headerlink" title="NO.40 组合总和 II 中等 "></a>NO.40 组合总和 II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10uUoQ.png" alt="10uUoQ.png"></p>
<p>本题和<a href="https://blog.csdn.net/qq_42758551/article/details/104161792" target="_blank" rel="noopener">徒手挖地球十二周目</a>中<u>组合总和</u>的思路一样只是少量变化，区别在于本题candidate数组中的元素不能重复使用(只能使用一次)，本题数组中有重复元素。</p>
<p><font color=red><strong>思路一：深度优先遍历，回溯法</strong></font> 从39题组合总和的基础上进行分析改进：</p>
<ol>
<li>本题数组中的每个元素不能重复使用，但是数组中存在重复元素(每个相等元素都可以使用一次)</li>
<li>每个节点的孩子应该使用下一个元素开始，即不再是index而是index+1；</li>
<li>本题数组中存在重复元素，所以仅仅采用<u>”每个孩子从下一个元素(index+1)开始”</u>是不够的，因为index之后的元素依然可能重复，因此我们不能让<strong>相等元素不能作为兄弟节点，但是可以作为父子</strong>。根据这个发现，我们可以先将candidates排序，然后每次搜索时如果本节点和前面的兄弟节点相等，则剪枝。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] candidates;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum2(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">this</span>.candidates=candidates;</span><br><span class="line">    <span class="comment">//排序，将重复元素紧凑在一起</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    dfs(target,<span class="number">0</span>,<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> index, LinkedList&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//说明找到符合要求的路径</span></span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(ans));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">        <span class="comment">//本节点和前面的兄弟节点相等,则小剪枝，跳过这条路径</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果减数大于目标值则差为负数，不符合结果，且后续元素都大于目标值，大剪枝，结束后序搜索</span></span><br><span class="line">        <span class="keyword">if</span> (target&lt;candidates[i]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(candidates[i]);</span><br><span class="line">        <span class="comment">//不能重复使用同一元素，所以下次搜索起点从index+1开始</span></span><br><span class="line">        dfs(target-candidates[i],i+<span class="number">1</span>,ans);</span><br><span class="line">        <span class="comment">//每次回溯移除最后一次添加的元素</span></span><br><span class="line">        ans.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="NO-10-正则表达式匹配-困难"><a href="#NO-10-正则表达式匹配-困难" class="headerlink" title="NO.10 正则表达式匹配 困难 "></a>NO.10 正则表达式匹配 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/11/1TQmNV.png" alt="1TQmNV.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/11/1TQeA0.png" alt="1TQeA0.png"></p>
<p><strong><font color=red>思路一：回溯法</font></strong> 这种匹配思路其实就是不断地减掉s和p的可以匹配首部，直至一个或两个字符串被减为空的时候，根据最终情况来得出结论。</p>
<p>如果只是两个普通字符串进行匹配，按序遍历比较即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( s.charAt(i) == p.charAt(i) )</span><br></pre></td></tr></table></figure>

<p>如果正则表达式字符串p只有一种”.”一种特殊标记，依然是按序遍历比较即可 ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( s.charAt(i) == p.charAt(i) || p.charAt(i) == <span class="string">'.'</span> )</span><br></pre></td></tr></table></figure>

<p>上述两种情况实现时还需要判断字符串长度和字符串判空的操作。</p>
<p>但是，”*“这个特殊字符需要特殊处理，<u>当p的第i个元素的下一个元素是星号时</u>会有两种情况：</p>
<ol>
<li>i元素需要出现0次，<u>我们就保持s不变，将p的减掉两个元素，调用isMatch。</u>例如s：bc、p：a<em>bc，我们就保持s不变，减掉p的”a\</em>“，调用isMatch(s:bc,p:bc)。</li>
<li>i元素需要出现一次或更多次，<u>先比较i元素和s首元素，相等则保持p不变，s减掉首元素，调用isMatch。</u>例如s：aabb、p：a<em>bb，就保持p不变，减掉s的首元素，调用isMatch(s:abb,p:a\</em>bb)。</li>
</ol>
<p>此时存在一些需要思考的情况，例如s：abb、p：a*abb，会用两种方式处理：</p>
<ol>
<li>按照上述第二种情况比较i元素和s首元素，发现相等就会减掉s的首字符，调用isMatch(s:bb,p:a*abb)。在按照上述第一种情况减去p的两个元素，调用isMatch(s:bb,p:abb)，最终导致false。</li>
<li>直接按照上述第一种情况减去p的两个元素，调用isMatch(s:abb,p:abb)，最终导致true。</li>
</ol>
<p>所以说这算是一种暴力方法，会将所有的情况走一边，看看是否存在可以匹配的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果正则串p为空字符串s也为空这匹配成功，如果正则串p为空但是s不是空则说明匹配失败</span></span><br><span class="line">    <span class="keyword">if</span> (p.isEmpty())<span class="keyword">return</span> s.isEmpty();</span><br><span class="line">    <span class="comment">//判断s和p的首字符是否匹配，注意要先判断s不为空</span></span><br><span class="line">    <span class="keyword">boolean</span> headMatched=!s.isEmpty()&amp;&amp;(s.charAt(<span class="number">0</span>)==p.charAt(<span class="number">0</span>)||p.charAt(<span class="number">0</span>)==<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (p.length()&gt;=<span class="number">2</span>&amp;&amp;p.charAt(<span class="number">1</span>)==<span class="string">'*'</span>)&#123;<span class="comment">//如果p的第一个元素的下一个元素是*</span></span><br><span class="line">        <span class="comment">//则分别对两种情况进行判断</span></span><br><span class="line">        <span class="keyword">return</span> isMatch(s,p.substring(<span class="number">2</span>))||</span><br><span class="line">            (headMatched&amp;&amp;isMatch(s.substring(<span class="number">1</span>),p));</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (headMatched)&#123;<span class="comment">//否则，如果s和p的首字符相等</span></span><br><span class="line">        <span class="keyword">return</span> isMatch(s.substring(<span class="number">1</span>),p.substring(<span class="number">1</span>));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((n+m)*2^(n+m/2)) n和m分别是s和p的长度</p>
<p><strong><font color=red>思路二：动态规划法</font></strong> 本题的dp数组的含义就是：dp[i][j]就是s的前i个元素是否可以被p的前j个元素所匹配。</p>
<p>我们知道了dp数组的含义之后就知道了dp数组的几个细节：</p>
<ol>
<li>dp[0][0]一定是true，因为s为空且p也为空的时候一定是匹配的；dp[1][0]一定是false，因为s有一个字符但是p为空的时候一定是不匹配的。</li>
<li>这个boolean类型的dp数组的大小应该是dp[s.length+1][p.length+1]，因为我们不仅仅要分别取出s和p的所有元素，还要表示分别取s和p的0个元素时候(都为空)的情况。</li>
<li>当写到dp[s.length][p.length]的时候，我们就得到了最终s和p的匹配情况。</li>
<li>dp[1][0]~dp[s.length][0]这一列都是false，因为s不为空但是p为空一定不能匹配。</li>
</ol>
<p>所以创建好dp数组之后，初始化dp[0][0]=true、dp[0][1]=false、dp[1][0]~dp[s.length][0]都是false。然后将第一行即dp[0][2]到dp[0][p.length]的元素初始化。</p>
<p>第一行初始化思路：如果不为空的p想要匹配上为空的s，因为此时p已经不为空，则需要p是”a*“、”b*“、”c*“。。。这种形式的才能匹配上。</p>
<p>然后填写数组的其余部分，这个过程中如果p.charAt(j)==’*&#39;依然是遵循上题中的两种情况；否则就判断两个字符串的i和j号字符是否相等，相等则分别减除当前字符继续判断，不相等则直接等于false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//需要分别取出s和p为空的情况，所以dp数组大小+1</span></span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>][p.length()+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化dp[0][0]=true,dp[0][1]和dp[1][0]~dp[s.length][0]默认值为false所以不需要显式初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//填写第一行dp[0][2]~dp[0][p.length]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=p.length();k++)&#123;</span><br><span class="line">        <span class="comment">//p字符串的第2个字符是否等于'*',此时j元素需要0个，所以s不变p减除两个字符</span></span><br><span class="line">        dp[<span class="number">0</span>][k]=p.charAt(k-<span class="number">1</span>)==<span class="string">'*'</span>&amp;&amp;dp[<span class="number">0</span>][k-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//填写dp数组剩余部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;p.length();j++)&#123;</span><br><span class="line">            <span class="comment">//p第j个字符是否为*</span></span><br><span class="line">            <span class="keyword">if</span> (p.charAt(j)==<span class="string">'*'</span>)&#123;</span><br><span class="line">                <span class="comment">//两种情况:1.s不变[i+1],p移除两个元素[j+1-2]。</span></span><br><span class="line">                <span class="comment">// 2.比较s的i元素和p的j-1(因为此时j元素为*)元素,相等则移除首元素[i+1-1],p不变。</span></span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i+<span class="number">1</span>][j-<span class="number">1</span>]||</span><br><span class="line">                    (dp[i][j+<span class="number">1</span>]&amp;&amp;headMatched(s,p,i,j-<span class="number">1</span>));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//s的i元素和p的j元素是否相等,相等则移除s的i元素[i+1-1]和p的j元素[j+1-1]</span></span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>]=dp[i][j]&amp;&amp;headMatched(s,p,i,j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[s.length()][p.length()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断s第i个字符和p第j个字符是否匹配</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">headMatched</span><span class="params">(String s,String p,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.charAt(i)==p.charAt(j)||p.charAt(j)==<span class="string">'.'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*m) n和m分别是s和p的长度</p>
<p>有了第一题总结的”经验”之后，这道题逻辑上不难理解，但是细节上尤其各种下标值非常的恶心。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>回溯</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——组合总数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BB%84%E5%90%88%E6%80%BB%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-39-组合总数-中等"><a href="#NO-39-组合总数-中等" class="headerlink" title="NO.39 组合总数 中等 "></a>NO.39 组合总数 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/28/1Kc5Js.png" alt="1Kc5Js.png"></p>
<p><font color=red><strong>思路一：深度遍历，回溯法</strong></font> 深度遍历得到”全排列“的过程中回溯剪枝。目标值作为根节点，每个分做减法，如果目标值被减为0则结算此分支路径上的减数集合，如果目标值被减为负数则剪枝即可。</p>
<p>去重：每个分支节点上的减数的下标不能比本分支上一层节点的减数的下标小。即，上层节点的减数下标为3，则同分支下一层节点的减数下标要从3开始。(这样每个分支就不会重复使用之前使用过的元素)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">if</span> (candidates==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">    dfs(target,<span class="number">0</span>,<span class="keyword">new</span> Stack&lt;Integer&gt;(),candidates);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> index, Stack&lt;Integer&gt; pre, <span class="keyword">int</span>[] candidates)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//等于零说明结果符合要求</span></span><br><span class="line">    <span class="keyword">if</span> (target==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(pre));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历，index为本分支上一节点的减数的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=index;i&lt;candidates.length;i++)&#123;</span><br><span class="line">        <span class="comment">//如果减数大于目标值，则差为负数，不符合结果</span></span><br><span class="line">        <span class="keyword">if</span> (candidates[i]&lt;=target)&#123;</span><br><span class="line">            pre.push(candidates[i]);</span><br><span class="line">            <span class="comment">//目标值减去元素值</span></span><br><span class="line">            dfs(target-candidates[i],i,pre, candidates);</span><br><span class="line">            <span class="comment">//每次回溯将最后一次加入的元素删除</span></span><br><span class="line">            pre.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——字符串压缩</title>
    <url>/2020/03/14/%5B%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9D%A2%E8%AF%95%E9%87%91%E5%85%B8%5D%E2%80%94%E2%80%94%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/</url>
    <content><![CDATA[<h2 id="NO-01-06-字符串压缩-简单"><a href="#NO-01-06-字符串压缩-简单" class="headerlink" title="NO.01.06 字符串压缩 简单 "></a>NO.01.06 字符串压缩 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/16/8G1O91.png" alt="8G1O91.png"></p>
<p><strong><font color=red>思路一：遍历</font></strong> 看到题，没什么好的思路，直接遍历统计。最后比较两个字符串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">compressString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S==<span class="keyword">null</span>||S.length()&lt;<span class="number">2</span>)<span class="keyword">return</span> S;</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c = S.charAt(i);</span><br><span class="line">        <span class="keyword">while</span> (i&lt;S.length()-<span class="number">1</span>&amp;&amp;c==S.charAt(i+<span class="number">1</span>))&#123;</span><br><span class="line">            count++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(c).append(count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.length()&lt;S.length()?sb.toString():S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两数相加</title>
    <url>/2019/10/01/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="NO-2-两数相加-中等"><a href="#NO-2-两数相加-中等" class="headerlink" title="NO.2 两数相加    中等 "></a>NO.2 两数相加    <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMw8XR.png" alt="QMw8XR.png"></p>
<p><font color=red><strong>思路一：转换法</strong></font>    1.将两个链表先转化成int或long类型数值x和y。2.x和y相加后的值再转换成链表。</p>
<p><strong>缺点</strong>：当参数中两个链表足够长时，得到的结果很有可能会超出int或long类型的范围发生溢出。</p>
<p>可以将x和y用BigDecimal类型来存储尽可能避免发生溢出，<strong><u>需要注意的是题目中链表都是逆序的</u></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">""</span>;</span><br><span class="line">        String s2=<span class="string">""</span>;</span><br><span class="line">        ListNode q=l1,p=l2;</span><br><span class="line"><span class="comment">//        将两个链表转化为字符串</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s1=q.val+s1;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s2=p.val+s2;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        BigDecimal x=<span class="keyword">new</span> BigDecimal(s1);</span><br><span class="line">        BigDecimal y=<span class="keyword">new</span> BigDecimal(s2);</span><br><span class="line">        BigDecimal z=x.add(y);</span><br><span class="line"><span class="comment">//        将结果转换成链表</span></span><br><span class="line">        <span class="keyword">char</span>[] chars=z.toString().toCharArray();</span><br><span class="line">        ListNode result=<span class="keyword">new</span> ListNode(Integer.parseInt(String.valueOf(chars[chars.length-<span class="number">1</span>])));</span><br><span class="line">        ListNode t=result;</span><br><span class="line"><span class="comment">//        因为链表是逆序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=chars.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ListNode temp=<span class="keyword">new</span> ListNode(Integer.parseInt(String.valueOf(chars[i])));</span><br><span class="line">            t.next=temp;</span><br><span class="line">            t=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：初等数学法</strong></font>    1.因为链表本身就是逆序的，所以从后向前按位依次加。2.用一个int变量carry来记录前一位相加后得到的进位。3.如果一个链表已经遍历完毕，在后续的按位相加时，该链表的节点值就是0。4.每次按位相加之后更新进位值carry，并将进位之后的数值加入结果链表。5.<u>两个链表遍历相加结束之后，需要再次判断进位值，防止遗漏最高位的进位。</u></p>
<p><strong><u>需要注意的是每次按位相加时，不要忘记加上进位值carry。</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        用哑节点来简化代码，如果没有使用哑节点就需要额外的代码来初始化表头的值</span></span><br><span class="line">        ListNode dummyHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode q=l1,p=l2,curr=dummyHead;</span><br><span class="line"><span class="comment">//        进位标志carry</span></span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>||p!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//          获取节点值，如果节点为空，值就为0</span></span><br><span class="line">            <span class="keyword">int</span> x=q==<span class="keyword">null</span>?<span class="number">0</span>:q.val;</span><br><span class="line">            <span class="keyword">int</span> y=p==<span class="keyword">null</span>?<span class="number">0</span>:p.val;</span><br><span class="line"><span class="comment">//          两个节点值和进位相加</span></span><br><span class="line">            <span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line"><span class="comment">//          获取相加之后的进位值</span></span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line"><span class="comment">//          将相加后结果加入结果链表</span></span><br><span class="line">            curr.next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line"><span class="comment">//          移动到下一个节点</span></span><br><span class="line">            curr=curr.next;</span><br><span class="line">            <span class="keyword">if</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        最后判断是否仍有进位，防止进位被遗漏</span></span><br><span class="line">        <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            curr.next=<span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        因为第一个节点是哑节点，</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(max(m,n))</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——计算质数</title>
    <url>/2019/10/01/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-204-计算质数-简单"><a href="#NO-204-计算质数-简单" class="headerlink" title="NO.204 计算质数    简单 "></a>NO.204 计算质数    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMwlp4.png" alt="QMwlp4.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font>    双层for循环。1.第一层循环遍历逐个判断[2,n)。2.第二层循环判断参数是否为素数。：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime(i))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^2)</p>
<p><strong>可改进点：</strong>例如，12=2*6、12=3*4、12=sqrt(12)*sqrt(12)、12=4*3、12=6<em>2，可以观察到后面就是前面两个数反过来，说明查找可以整除12的因子时只需要找到“一半”的位置即可，如果前“一半”没有可以整除的因子，那么后“一半”也没有，这个临界点“一半”就是sqrt(12)。所以上述isPrime()方法的循环条件可以写为“i\</em>i&lt;n”即可，该方法时间复杂度降到了O(sqrt(n))。</p>
<p><font color=red><strong>思路二：厄拉多塞筛法</strong></font>    不难想象，所有质数的倍数都不是质数。例如，2是质数，2的倍数4、6、8、10、12。。。都不是质数；3是质数，3的倍数6、9、12、15。。。都不是质数；可以看一下维基百科中一个厄拉多塞筛的gif图：</p>
<p><img src="https://s2.ax1x.com/2019/12/03/QMw11J.gif" alt="QMw11J.gif"></p>
<p>这种方法大概就是“排除法”，每确定一个质数，就可以排除一批非质数，那么算法就可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isPrimes[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrimes,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//		将所有质数的倍数设置为false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;n;j+=i)&#123;</span><br><span class="line">                isPrimes[j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//      统计所有质数，即isPrimes[i]==true的为质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述算法还存在两处冗余：</p>
<ol>
<li>在本题的暴利算法下说的：只需要判断到sqrt(n)即可。</li>
<li>例如，12不是质数，所以会被设置为false，但是12既是2的倍数，也是3的倍数，所以它被标记了两次。</li>
</ol>
<p>解决上述两处冗余后的算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isPrimes[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrimes,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//        只需要判断小于sqrt(n)的数是否为质数即可，所以i*i&lt;n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;n;i++)&#123;</span><br><span class="line"><span class="comment">//            这样可以把质数i的整数倍都标记为false，但是仍然存在计算冗余。</span></span><br><span class="line"><span class="comment">//            比如n=25，i=4时算法会标记4×2=8，4×3=12等等数字，</span></span><br><span class="line"><span class="comment">//            但是这两个数字已经被i=2和i=3的2×4和3×4标记了。所以使用j=i*i减少此计算的冗余。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i*i;j&lt;n;j+=i)&#123;</span><br><span class="line">                isPrimes[j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//      统计所有质数，即isPrimes[i]==true的为质数</span></span><br><span class="line"><span class="comment">//        这里要注意从2开始，因为0,1不是质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>厄尔拉塞筛法的时间复杂度：O(nloglogn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>厄拉多塞筛</tag>
      </tags>
  </entry>
  <entry>
    <title>c3p0版本太低导致的错误</title>
    <url>/2019/06/18/c3p0%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E%E5%AF%BC%E8%87%B4%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>今天做了一个<strong>jsp、servlet、mybatis、spring ioc</strong>的简单复习（大概就是在web上最简单的增删改查）。出现了一个错误让我调试了好一会儿，最终百度解决。。。的问题。<a id="more"></a></p>
<p>我开始时配置<strong>DataSource</strong>用的是<strong>c3p0-0.9.1.2版本</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/05/28/Vnk44P.png" alt="c3p0-0.9.1.2版本"></p>
<p><strong>运行时报错信息</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/05/28/Vnko38.png" alt="运行时出现错误"></p>
<p>检查了一边代码，捋了一遍逻辑，找不出问题。索性换成dbcp的数据源（BasicDataSource ），就正常运行了。（开始怀疑是c3p0的jar包有毛病，毕竟我那么吊，怎么可能会写错！！！）</p>
<p><strong>百度了一下，果然是因为c3p0版本太低</strong>（跟不上我的技术了，哈哈）。</p>
<p>下载了一个高版本的c3p0jar包（c3p0-0.9.5.2），问题迎刃而解。</p>
<p><img src="https://s2.ax1x.com/2019/05/28/VnkI9f.png" alt="高版本c3p0"></p>
<p><img src="https://s2.ax1x.com/2019/05/28/VnkbuQ.png" alt="耶~问题解决！"></p>
<p>最烦<strong>jar包不匹配</strong>或者<strong>开发环境有问题</strong>导致的错误，实在是不好找原因！！！</p>
<p>记录一下百度百科上<strong>c3p0和dbcp的区别</strong>：</p>
<p><img src="https://s2.ax1x.com/2019/05/28/VnkTgS.png" alt="c3p0和dbcp的区别"></p>
]]></content>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC中的集合参数绑定</title>
    <url>/2019/06/09/SpringMVC%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>绑定数组参数和集合参数<a id="more"></a></p>
<h2 id="1-绑定数组参数"><a href="#1-绑定数组参数" class="headerlink" title="1. 绑定数组参数"></a>1. 绑定数组参数</h2><p><u>语言匮乏，组织不好语言。。。直接上例子。。</u></p>
<p>例子：页面中多个checkbox<strong>组件</strong>的<strong>name</strong>都是ids。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/queryItem.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">查询条件：</span><br><span class="line">&lt;table width=<span class="string">"100%"</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;商品id&lt;input type="text" name="item.id" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;商品名称&lt;input type="text" name="item.name" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">商品列表：</span><br><span class="line">&lt;table width=<span class="string">"100%"</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;选择&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品名称&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品价格&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;生产日期&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品描述&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;操作&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;itemList &#125;"</span> <span class="keyword">var</span>=<span class="string">"item"</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;&lt;input type="checkbox" name="ids" value="$&#123;item.id&#125;"/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.name &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.price &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>controller方法可以用一个数组做形参，MVC的处理器适配器就会自动绑定参数。</p>
<p>对应以上的例子，controller方法的形参可以是<strong>Integer[ ]</strong> 类型，表单提交后被选中的checkbox的<strong>value</strong>就会被自动绑定到方法的形参中去。</p>
<h2 id="2-绑定集合参数"><a href="#2-绑定集合参数" class="headerlink" title="2.  绑定集合参数"></a>2.  绑定集合参数</h2><p>依然是上面的jsp文件，controller方法的形参直接改为<strong>List&lt;Integer&gt;</strong>,表单提交后会报错！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报错信息：Failed to instantiate [java.util.List]: Specified class is an interface</span><br></pre></td></tr></table></figure>

<p>此时需要一个pojo对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemVo</span> </span>&#123;</span><br><span class="line">	。</span><br><span class="line">    。</span><br><span class="line">    。</span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line">	</span><br><span class="line">	getter/setter。。。</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>将controller方法的形参改为ItemVo类型，会自动将表单提交来的参数，按参数名绑定到pojo类的集合属性中。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller方法的返回值</title>
    <url>/2019/06/09/Controller%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<h3 id="1-返回ModelAndView"><a href="#1-返回ModelAndView" class="headerlink" title="1. 返回ModelAndView"></a>1. 返回ModelAndView<a id="more"></a></h3><p>最开始学习的时候就是返回这个类，可以给这个类添加model数据和指定view。</p>
<h3 id="2-返回void"><a href="#2-返回void" class="headerlink" title="2. 返回void"></a>2. 返回void</h3><p>返回值为空，那么model数据和view怎么办呢？</p>
<p>可以在形参中使用request和response，完成域对象存取数据、重定向、转发。。。（这里就有点像最初的servlet了）</p>
<h3 id="3-返回字符串"><a href="#3-返回字符串" class="headerlink" title="3. 返回字符串"></a>3. 返回字符串</h3><p>controller方法返回字符串可以指定<strong>逻辑视图名</strong>，通过<strong>视图解析器</strong>解析为<strong>物理视图地址</strong>。（类似于指定view）</p>
<p>可以在字符串前加<strong>Redirect</strong>或者<strong>forward</strong>完成<strong>重定向</strong>或<strong>转发</strong>。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>@RequestMapping注解的作用</title>
    <url>/2019/06/09/@RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-URL路径映射"><a href="#1-URL路径映射" class="headerlink" title="1. URL路径映射"></a>1. URL路径映射<a id="more"></a></h3><p>最常用，用的最多的属性value</p>
<p>@RequestMapping(value=”item”)或@RequestMapping(“/item”）</p>
<p>value的值是数组，可以将多个url映射到同一个方法</p>
<h3 id="2-添加在类上面"><a href="#2-添加在类上面" class="headerlink" title="2. 添加在类上面"></a>2. 添加在类上面</h3><p>在<strong>class</strong>上添加<strong>@RequestMapping(url)</strong>指定<strong>通用请求前缀</strong>， <u>限制此类下的所有方法请求url必须以请求前缀开头</u>。</p>
<p><font color="red"><strong>可以使用此方法对url进行分类管理。</strong></font></p>
<h3 id="3-请求方法限定"><a href="#3-请求方法限定" class="headerlink" title="3. 请求方法限定"></a>3. 请求方法限定</h3><p>method属性，可以限制请求的方法GET、POST。。。</p>
<p>并且该方法也是一个数组，可以指定多个请求的方法。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
