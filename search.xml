<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>新建文件夹/[LeetCode]——合并两个有序数组</title>
    <url>/2020/03/16/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="NO-88-合并两个有序数组-简单"><a href="#NO-88-合并两个有序数组-简单" class="headerlink" title="NO.88 合并两个有序数组 简单 "></a>NO.88 合并两个有序数组 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/03/34CGVO.png" alt="34CGVO.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 没啥说的直接B合并到A后面的预留位置，然后直接API对A进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        A[m+i]=B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((m+n)*log(m+n))    排序的复杂度</p>
<p><strong><font color=red>思路二：双指针法</font></strong> 最直接想到的双指针法就是像合并两个有序链表一样双指针分别指向两个数组开头，从前向后遍历两个数组。</p>
<p>但是本题中A数组要作为最终的结果数组，所以需要将A中的m个元素保存到A2数组中，然后像上述方法一样双指针遍历A2和B数组，合并保存到A数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存nums1的m个元素</span></span><br><span class="line">    <span class="keyword">int</span>[] A2=<span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        A2[i]=nums1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双指针比较并合并保存到nums1中</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;A2.length&amp;&amp;j&lt;nums2.length)&#123;</span><br><span class="line">        nums1[index++]=(A2[i]&lt;nums2[j]?A2[i++]:nums2[j++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个数组有剩余时保存到nums1后面</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;nums2.length)nums1[index++]=nums2[j++];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;A2.length)nums1[index++]=A2[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(m)    保存nums1的m个元素。</p>
<p><strong><font color=red>思路三：逆序双指针法</font></strong> 不使用额外的数组去保存nums1的m个元素，从而优化空间。</p>
<p>方法就是：逆序！其实就是将思路二都逆向进行。</p>
<p>双指针分别指向nums1和nums2的尾部，逆序遍历，比较大的元素优先合并入结果数组；从结果数组的尾部向前保存并入的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指针都指向尾部，比较大的元素优先合并至nums1尾部</span></span><br><span class="line">    <span class="keyword">int</span> i=m-<span class="number">1</span>,j=n-<span class="number">1</span>,index=nums1.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        nums1[index--]=(nums1[i]&gt;nums2[j]?nums1[i--]:nums2[j--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否有剩余</span></span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>)nums1[index--]=nums1[i--];</span><br><span class="line">    <span class="keyword">while</span> (j&gt;=<span class="number">0</span>)nums1[index--]=nums2[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(1)</p>
]]></content>
  </entry>
  <entry>
    <title>新建文件夹/[LeetCode]——在排序数组中查找元素的第一个和最后一个位置 </title>
    <url>/2020/03/16/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%20/</url>
    <content><![CDATA[<h2 id="NO-34-在排序数组中查找元素的第一个和最后一个位置-中等"><a href="#NO-34-在排序数组中查找元素的第一个和最后一个位置-中等" class="headerlink" title="NO.34 在排序数组中查找元素的第一个和最后一个位置 中等 "></a>NO.34 在排序数组中查找元素的第一个和最后一个位置 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/05/lr9WgP.png" alt="lr9WgP.png"></p>
<p>如果不要求时间复杂度，只需要分别正序遍历找左边target和逆序遍历找右边target即可。但是根据题目要求的时间复杂度O(log n)，看出这依然是一个二分查找的变种。</p>
<p><font color=red><strong>思路一：二分法再线性法</strong></font></p>
<ol>
<li>二分法找到target，如果不存在则返回[-1,-1]。</li>
<li>如果nums[mid]==target，利用数组有序的特点， 以mid为中心分别向左向右线性查找，找到最左和最右的target值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result=&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先二分法找到target的下标</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//如果找到target的下标mid，就以mid为中心分别向左向右线性查找</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">int</span> left_key=mid,right_key=mid;</span><br><span class="line">            <span class="comment">//向左向右线性查找，直至找到不等于target</span></span><br><span class="line">            <span class="keyword">while</span> (left_key&gt;=<span class="number">0</span>&amp;&amp;nums[left_key]==target)left_key--;</span><br><span class="line">            <span class="keyword">while</span> (right_key&lt;nums.length&amp;&amp;nums[right_key]==target)right_key++;</span><br><span class="line">            <span class="comment">//保存最左和最右的target值的下标</span></span><br><span class="line">            result[<span class="number">0</span>]=left_key+<span class="number">1</span>;</span><br><span class="line">            result[<span class="number">1</span>]=right_key-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//终止二分法</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">           left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏情况，有序数组中元素都等于target，例如target=8，[8,8,8,8,8,8]，则线性寻找最左最右时需要遍历每个元素。所以时间复杂度是：O(n)。但是因为测试数据的关系，leetcode中这种思路也是可以通过的。</p>
<p><font color=red><strong>思路二：直接二分法分别查找</strong></font></p>
<p>嘴笨，说的比较抽象，其实根据下述方法，动笔在纸上画一画模拟一下就很清晰明了了。</p>
<ol>
<li><p>二分法查找最左target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：<u>当中间值等于target，不能直接返回，而是要收缩right减小搜索区间继续逐步锁定最左的target。</u></p>
<p>最终得到的left(因为循环终止条件时right==left，所以最终left和right是相等的)可以理解成：数组中比target小的元素的个数。所以最终进行简单的判断即可，如果’left==nums.length’说明所有的数都比target小则返回-1，如果’nums[left]==target’则nums[left]就是最左的target，否则数组中没有target返回-1。</p>
</li>
<li><p>二分法查找最右target：如果中间值(nums[mid])不等于target，则根据情况移动left或者right来减半搜索区间范围即可。需要改变的是：<u>当中间值等于target，不能直接返回，而是要增加left减小搜索区间继续逐步锁定最右的target。</u></p>
<p>因为搜索区间是[0，nums.length)为左闭右开，所以最后判断和返回时需要对left或者right减一，防止越界。这个”减一”也可以这么理解：’if (nums[mid]==target)left=mid+1;’当while循环结束的时候nums[left]的值一定不是target，但是nums[left-1]的值有可能是，所以返回‘nums[right-1]==target?right-1:-1’即可。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result=&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    result[<span class="number">0</span>]=searchLeft(nums,target);</span><br><span class="line">    result[<span class="number">1</span>]=searchRight(nums,target);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找最左target</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchLeft</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length;</span><br><span class="line">    <span class="comment">//这里是&lt;而不是&lt;=，因为搜索区间是[0，length)，终止条件是left==right</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid =(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//因为是寻找最左target，所以这里不能直接返回，而是收缩right去锁定左侧边界</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">            <span class="comment">//这里是=mid而不是=mid-1，因为搜索区间是左闭右开</span></span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果target比所有数都大，则返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (left==nums.length)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//终止条件是left==right，所以返回left或者right都可</span></span><br><span class="line">    <span class="keyword">return</span> nums[left]==target?left:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//寻找最右target</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchRight</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length;</span><br><span class="line">    <span class="comment">//这里是&lt;而不是&lt;=，因为搜索区间是[0，length)</span></span><br><span class="line">    <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//因为是寻找最右target，所以不能直接返回，而是要增大left去锁定左侧边界</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid]==target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于每次收紧左侧边界都是left=mid+1（因为搜索区间是左闭右开），所以无论是left还是right都需要-1</span></span><br><span class="line">    <span class="keyword">return</span> nums[right-<span class="number">1</span>]==target?right-<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(log n)</p>
<p><font color=red><strong>注意事项：</strong></font></p>
<ol>
<li><p><font color=red>二分法中比较麻烦容易出错的点就是搜索区间的确定，因为这会影响到循环条件和搜索区间端点(left和right)的移动。</font></p>
</li>
<li><p><font color=red>思路一中：left=0，right=length-1所以搜索区间是[0，length-1]左闭右闭的，所以循环终止的条件是left&gt;right即while(left&lt;=right)，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid-1排除了mid并且新的搜索区间是[0，mid-1]或者[mid+1，lenght-1]依然是左闭右闭。</font></p>
</li>
<li><p><font color=red>思路二中：left=0，right=length所以搜索区间是[0，length)左闭右开的，所以循环终止的条件是left==right所以while(left&lt;right)即可，区间端点移动时因为mid不是需要的值所以排除，即left=mid+1，right=mid排除了mid并且新的搜索区间是[0，mid)或者[mid+1，lenght)依然是左闭右闭。</font></p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！  </p>
<p>更多题解和学习记录博客:<a href="![img](file:///C:\Users\ZQC\AppData\Roaming\Tencent\QQTempSys%W@GJ$ACOF(TYDYECOKVDYB.png)https://blog.csdn.net/qq_42758551)、[github](![img](file:///C:\Users\ZQC\AppData\Roaming\Tencent\QQTempSys%W@GJ$ACOF(TYDYECOKVDYB.png)https://github.com/Jerrymouse1998/learning-record-of-leetcode">博客</a>   </p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>[LeetCode]——有效数字</title>
    <url>/2020/03/14/LeetCode-%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>什么是面向测试编程？试试本题就知道了！</p>
<h2 id="NO-65-有效数字-困难"><a href="#NO-65-有效数字-困难" class="headerlink" title="NO.65 有效数字 困难 "></a>NO.65 有效数字 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8Q6Wd0.png" alt="8Q6Wd0.png"></p>
<p>没有get到这道题目的点，这样的题目很搞心态。尤其是看了<a href="https://leetcode.com/problems/valid-number/discuss/23977/A-clean-design-solution-By-using-design-pattern" target="_blank" rel="noopener">作者的解答</a>之后更懵逼了，作者使用了责任链的设计模式，从来没想到解算法题还能用到设计模式。大牛的思维方式就适合我不一样，解个算法题都能考虑到扩展性和复用性。</p>
<h3 id="思路一：暴力法"><a href="#思路一：暴力法" class="headerlink" title="思路一：暴力法"></a><strong><font color=red>思路一：暴力法</font></strong></h3><p>按序遍历字符串，逐位判断是否合法。注意要去除首尾空格。</p>
<p>这种方法就是比较恶心，很容易有考虑不到的情况。</p>
<p>而且测试用例中有：”.1”、”.2”、”+.8”、”46.”、”2e0”等等，预期输出都是true。真的恶心到了。。。</p>
<p>切身感受什么是面向测试编程！！！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="keyword">if</span> (s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> pointSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 .</span></span><br><span class="line">    <span class="keyword">boolean</span> eSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 e</span></span><br><span class="line">    <span class="keyword">boolean</span> numberSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 0-9</span></span><br><span class="line">    <span class="keyword">boolean</span> numberAfterE = <span class="keyword">true</span>;<span class="comment">//e之后是否出现 0-9</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'0'</span> &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= <span class="string">'9'</span>) &#123;<span class="comment">//当前元素是数字</span></span><br><span class="line">            numberSeen = <span class="keyword">true</span>;</span><br><span class="line">            numberAfterE = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'.'</span>) &#123;<span class="comment">//当前元素是 .</span></span><br><span class="line">            <span class="keyword">if</span>(eSeen || pointSeen) &#123;<span class="comment">//已经出现过 e或者.，则非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pointSeen = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'e'</span>) &#123;<span class="comment">//当前元素 e</span></span><br><span class="line">            <span class="keyword">if</span>(eSeen || !numberSeen) &#123;<span class="comment">//已经出现过 e或者e之前没出现过数字，则非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numberAfterE = <span class="keyword">false</span>;<span class="comment">//注意这点很重要，现在开始记录e之后是否有数字</span></span><br><span class="line">            eSeen = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'-'</span> || s.charAt(i) == <span class="string">'+'</span>) &#123;<span class="comment">//当前元素是-或+</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) != <span class="string">'e'</span>) &#123;<span class="comment">//如果-或+不是第一个元素 或者 之前不是 e</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//当前元素不是0-9、. 、e 、- 、+，非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否有数字并且e之后也有数字</span></span><br><span class="line">    <span class="keyword">return</span> numberSeen &amp;&amp; numberAfterE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>写完暴力法，忍不住给下面这个骚操作点了个赞 : )</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            key=float(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="思路二：确定有限自动机-DFA"><a href="#思路二：确定有限自动机-DFA" class="headerlink" title="思路二：确定有限自动机(DFA)"></a><strong><font color=red>思路二：确定有限自动机(DFA)</font></strong></h3><p>下面搬运自leetcode社区windliang，我不是大佬，我只是大佬的搬运工。</p>
<p>先画出状态转换图：</p>
<p><img src="https://s1.ax1x.com/2020/03/14/8QIq3t.png" alt="8QIq3t.png"></p>
<p>如上图，从 0 开始总共有 9 个状态，橙色代表可接受状态，也就是表示此时是合法数字。总共有四大类输入，数字，小数点，e 和 正负号。我们只需要将这个图实现就够了。</p>
<p>这种方式思路清晰多了，但是之前没有接触过这种方法实现起来还是很生疏的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">0</span>;<span class="comment">//当前状态</span></span><br><span class="line">    s = s.trim();<span class="comment">//去除头尾的空格</span></span><br><span class="line">    <span class="comment">//遍历所有字符，当做输入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line">                <span class="comment">//输入正负号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                    state = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">4</span>) &#123;</span><br><span class="line">                    state = <span class="number">6</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//输入数字</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'6'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'7'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'9'</span>:</span><br><span class="line">                <span class="comment">//根据当前状态去跳转</span></span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        state = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        state = <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                        state = <span class="number">5</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                        state = <span class="number">8</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                        state = <span class="number">8</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//小数点</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        state = <span class="number">7</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        state = <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//e</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                        state = <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//橙色部分的状态代表合法数字</span></span><br><span class="line">    <span class="keyword">return</span> state == <span class="number">2</span> || state == <span class="number">3</span> || state == <span class="number">5</span> || state == <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h3 id="思路三：责任链模式"><a href="#思路三：责任链模式" class="headerlink" title="思路三：责任链模式"></a><strong><font color=red>思路三：责任链模式</font></strong></h3><p>解法二看起来已经很清晰明了了，只需要把状态图画出来，然后实现代码就很简单了。但是缺点是，如果状态图少考虑了东西，再改起来就会很麻烦。</p>
<p>这里作者提出来，利用责任链的设计模式，会使得写出的算法扩展性以及维护性更高。这里用到的思想就是，每个类只判断一种类型。比如判断是否是正数的类，判断是否是小数的类，判断是否是科学计数法的类，这样每个类只关心自己的部分，出了问题很好排查，而且互不影响。</p>
<p>虽然代码变多了，但是维护性，扩展性变的很强了。比如，题目新增了一种情况，”0x123” 16 进制也算是合法数字。这样的话，解法一和解法二就没什么用了，完全得重新设计。但对于解法三，我们只需要新增一个类，专门判断这种情况，然后加到执行者的数组里就够了，很牛逼！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个类都实现这个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NumberValidate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个抽象类，用来检查一些基础的操作，是否为空，去掉首尾空格，去掉 +/-</span></span><br><span class="line"><span class="comment">//doValidate 交给子类自己去实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>  <span class="title">NumberValidateTemplate</span> <span class="keyword">implements</span> <span class="title">NumberValidate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkStringEmpty(s))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = checkAndProcessHeader(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doValidate(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkStringEmpty</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">checkAndProcessHeader</span><span class="params">(String value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = value.trim();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value.startsWith(<span class="string">"+"</span>) || value.startsWith(<span class="string">"-"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            value = value.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是整数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String integer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integer.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(integer.charAt(i)) == <span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是科学计数法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SienceFormatValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> pos = s.indexOf(<span class="string">"e"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String first = s.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String second = s.substring(pos+<span class="number">1</span>, s.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validatePartBeforeE(first) == <span class="keyword">false</span> || validatePartAfterE(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePartBeforeE</span><span class="params">(String first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.equals(<span class="string">""</span>) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHeadAndEndForSpace(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate integerValidate = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        NumberValidate floatValidate = <span class="keyword">new</span> FloatValidate();</span><br><span class="line">        <span class="keyword">if</span> (integerValidate.validate(first) == <span class="keyword">false</span> &amp;&amp; floatValidate.validate(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkHeadAndEndForSpace</span><span class="params">(String part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (part.startsWith(<span class="string">" "</span>) ||</span><br><span class="line">            part.endsWith(<span class="string">" "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePartAfterE</span><span class="params">(String second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (second.equals(<span class="string">""</span>) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHeadAndEndForSpace(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate integerValidate = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        <span class="keyword">if</span> (integerValidate.validate(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是小数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String floatVal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = floatVal.indexOf(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (floatVal.length() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        String first = floatVal.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String second = floatVal.substring(pos + <span class="number">1</span>, floatVal.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkFirstPart(first) == <span class="keyword">true</span> &amp;&amp; checkFirstPart(second) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkFirstPart</span><span class="params">(String first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.equals(<span class="string">""</span>) == <span class="keyword">false</span> &amp;&amp; checkPart(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPart</span><span class="params">(String part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(part.charAt(<span class="number">0</span>)) == <span class="keyword">false</span> ||</span><br><span class="line">            Character.isDigit(part.charAt(part.length() - <span class="number">1</span>)) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        <span class="keyword">if</span> (nv.validate(part) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个执行者，我们把之前实现的各个类加到一个数组里，然后依次调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberValidator</span> <span class="keyword">implements</span> <span class="title">NumberValidate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;NumberValidate&gt; validators = <span class="keyword">new</span> ArrayList&lt;NumberValidate&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberValidator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        addValidators();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">addValidators</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line"></span><br><span class="line">        nv = <span class="keyword">new</span> FloatValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//nv = new HexValidate();</span></span><br><span class="line">        <span class="comment">//validators.add(nv);</span></span><br><span class="line"></span><br><span class="line">        nv = <span class="keyword">new</span> SienceFormatValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (NumberValidate nv : validators)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nv.validate(s) == <span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    NumberValidate nv = <span class="keyword">new</span> NumberValidator();</span><br><span class="line">    <span class="keyword">return</span> nv.validate(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>确定有限自动机</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——最长上升子序列</title>
    <url>/2020/03/14/LeetCode-%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-300-最长上升子序列-中等"><a href="#NO-300-最长上升子序列-中等" class="headerlink" title="NO.300 最长上升子序列 中等 "></a>NO.300 最长上升子序列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8QQPq1.png" alt="8QQPq1.png"></p>
<p>刚看到题，我以为寻找的这个上升子序列需要是连续的递增元素，所以我想双指针。发现行不通，重新审题发现，示例中的子序列元素不是连续的。。。</p>
<h3 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a><strong><font color=red>思路一：动态规划</font></strong></h3><p>dp数组含义：dp[i]nums前i个元素中最长上升子序列的长度。</p>
<p>初始化：初始状态全部为1，因为每个元素自身至少是长度为1子序列。</p>
<p>状态转移：填写dp[i]时遍历j∈[0,i，</p>
<p>如果i元素&gt;j元素则当前元素i可以接在j元素之后作为上升子序列dp[i]=Max(dp[i],dp[j]+1)；</p>
<p>否则i元素&lt;=j元素当前元素i不能拼接在j元素之后就忽略。</p>
<p>每次填写完dp[i]更新当前最长上升子序列长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">//如果i元素&gt;j元素，则i可以接在j元素后面作为上升子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[j])dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最大长度</span></span><br><span class="line">        maxLen=Math.max(maxLen,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h3 id="思路二：TreeSet"><a href="#思路二：TreeSet" class="headerlink" title="思路二：TreeSet"></a><strong><font color=red>思路二：TreeSet</font></strong></h3><p>JAVA Api中的TreeSet有ceiling(x)方法，取大于x的数，如果不存在则返回null。(此方法时间复杂度O(logn)，但是最坏情况下会退化到O(n))</p>
<p>按序遍历nums，到TreeSet中取大于num的数x，如果存在x则删除x并将num加入set，如果不存在就是所有的数都小于num就将num加入set。</p>
<p>最后返回set的大小即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TreeSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        Integer x = set.ceiling(num);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.remove(x);</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏时间复杂度仍然是：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——N皇后II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20N%E7%9A%87%E5%90%8EII/</url>
    <content><![CDATA[<h2 id="NO-52-N皇后II-困难"><a href="#NO-52-N皇后II-困难" class="headerlink" title="NO.52 N皇后II 困难 "></a>NO.52 N皇后II <font color=#ff0099>困难</font> <a id="more"></a></h2><p>NO.52是NO.51的姊妹题，区别在于NO.51要求返回包含”棋子摆放”的List&lt;List&lt;String&gt;&gt;集合，而本题NO.52只需要返回一共有多少种摆法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO.51:public List&lt;List&lt;String&gt;&gt; solveNQueens(int n)</span><br><span class="line">NO.52:public int totalNQueens(int n)</span><br></pre></td></tr></table></figure>

<p><strong><font color=red>思路一：回溯法</font></strong> 看到题的第一反应是直接把上一题回溯法的终止处理”res.add”改成”计数器+1”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//棋盘,默认为0表示空，1表示皇后</span></span><br><span class="line">    <span class="keyword">int</span>[][] board=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//row当前填写得的行号</span></span><br><span class="line">    dfs(n,<span class="number">0</span>,board);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0~n-1都填写完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==n)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsable(board,row,col))&#123;</span><br><span class="line">            board[row][col]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//填写下一行</span></span><br><span class="line">            dfs(n,row+<span class="number">1</span>,board);</span><br><span class="line">            board[row][col]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//board[row][col]是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUsable</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查列上有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查左上至右下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+row-col&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i+row-col][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查右上至左下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row+col-i&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row+col-i][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%20%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="NO-20-有效括号-简单"><a href="#NO-20-有效括号-简单" class="headerlink" title="NO.20 有效括号 简单 "></a>NO.20 有效括号 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFVldS.png" alt="lFVldS.png"></p>
<p><font color=red><strong>思路一：栈</strong></font>  学校的数据结构课就是那这个作为例子来引入栈结构的。1. 遍历表达式中每个字符，如果是’(‘或’[]’或’{‘就放入栈中。2. 如果是’)’或’]’或’}’就弹出栈顶字符top，如果此时栈为空或者将此时被遍历字符和top不匹配，则说明表达式无效。3. 遍历完所有字符，检查栈是否为空，如果不为空则表达式无效，反之有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//        用hashmap存储括号对</span></span><br><span class="line">        HashMap&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line"><span class="comment">//        用栈来保存遍历到的'(' '[' '&#123;'</span></span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"><span class="comment">//            如果map中没有c这个key，则说明c是(或[或&#123;,就存入栈中（题目说只有六种字符）</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c))&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果存在c这个key则说明，c是)或]或&#125;，就需要去和栈顶字符进行匹配</span></span><br><span class="line"><span class="comment">//                如果栈为空，则无法匹配</span></span><br><span class="line">                <span class="keyword">if</span> (stack.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//                取出栈顶元素</span></span><br><span class="line">                Character top = stack.pop();</span><br><span class="line"><span class="comment">//                如果map中c的value和栈顶元素top不相等，则无法匹配</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(c)!=top)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        遍历完所有字符之后，检查栈是否为空，如果为空则匹配，反之无法匹配</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——Z字形变换</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="NO-6-Z字形变换-中等"><a href="#NO-6-Z字形变换-中等" class="headerlink" title="NO.6 Z字形变换 中等 "></a>NO.6 Z字形变换 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/10/QDB5TA.png" alt="QDB5TA.png"></p>
<p><font color=red><strong>思路一：按列写，按行读</strong></font> 将原字符串按列写成”Z字形”，写好之后按行读取“Z字形”。1.先创建一个有min(numRows,len(s))个元素的list，且list的每个元素都是一个StringBuilder。2.用两个变量分别记录当前是第几行和当前的方向。3.然后将参数字符串中的字符逐一填入。4.仅当前行等于list的第一个参数下标0或者等于numRows-1时方向改变。</p>
<p>这个思路很类似我们动手在纸上将参数字符串写成Z字形的过程，将所有字符逐一写出，在第一行写字符之后写字符的方向变为向下写，在最后一行（numRows）写字符之后写字符的方向变为向上写。当全部写完之后，按行将字符串读出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        List&lt;StringBuilder&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Math.min(numRows,s.length());i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        定义一个变量记录方向，向下为false，向上为true</span></span><br><span class="line">        <span class="keyword">boolean</span> goingDown=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        记录当前是第几行</span></span><br><span class="line">        <span class="keyword">int</span> currentRow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            list.get(currentRow).append(c);</span><br><span class="line"><span class="comment">//            如果当前行下标是第一行或者是最后一行，就改变方向标识</span></span><br><span class="line">            <span class="keyword">if</span> (currentRow==<span class="number">0</span>||currentRow==numRows-<span class="number">1</span>)goingDown=!goingDown;</span><br><span class="line"><span class="comment">//            行下标向当前方向移动，如果true就+1向下移动，如果是false就-1向上移动</span></span><br><span class="line">            currentRow+=goingDown?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        按行读取，获取最后的输出结果</span></span><br><span class="line">        StringBuilder ret=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder stringBuilder : list) &#123;</span><br><span class="line">            ret.append(stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red><strong>思路二：直接按行访问</strong></font>  直接按照将参数字符串写成Z字形之后的结构进行按行访问拼接到结果字符串中。经过观察，可以发现如下规律：对于所有的行i和结果字符串中的字符索引k都有，1. 行0中的字符位于原字符串的k(2*numRows-2)索引处。 2. 行numRows-1中的字符位于原字符串的k(2*numRows-2)+numRows-1索引处。3. 内部的行i中的字符位于原字符串的k(2*numRows-1)+i以及(k+1)(2*numRows-2)-i索引处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> len=s.length();</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//        一个循环长度（Z字形两次方向变换，即向下写到numRows行方向变化为向上再写到0行的长度）</span></span><br><span class="line">    <span class="keyword">int</span> cycleLen=<span class="number">2</span>*numRows-<span class="number">2</span>;</span><br><span class="line"><span class="comment">//        0-numRows行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;len;j+=cycleLen)&#123;</span><br><span class="line">            ans.append(s.charAt(j+i));</span><br><span class="line"><span class="comment">//     当不是第0行且不是第numRows-1行且当前行下一个字符在原字符串中存在时，将当前行下一个字符加入结果串</span></span><br><span class="line"><span class="comment">//                防止遗漏中间行的字符</span></span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>&amp;&amp;i!=numRows-<span class="number">1</span>&amp;&amp;j+cycleLen-i&lt;len)</span><br><span class="line">                ans.append(s.charAt(j+cycleLen-i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——Pow(x,n)</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20Pow(x,n)%20/</url>
    <content><![CDATA[<h2 id="NO-50-Pow-x-n-中等"><a href="#NO-50-Pow-x-n-中等" class="headerlink" title="NO.50 Pow(x,n) 中等 "></a>NO.50 Pow(x,n) <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/07/1gKljg.png" alt="1gKljg.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 这道题暴力法是不能通过leetcode判题机，会得到一个t。但是方法本身是可以得到正确答案的，所以我们需要对他进行优化。暴力法的想法很简单的：2^3=2*2*2。</p>
<p>如果n为负，则n=-n同时x=1/x，例如2^(-3)=1/2*1/2*1/2。但是这里要注意n的取值范围，主要是 正整数和负整数的不同范围限制 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> N=n;</span><br><span class="line">    <span class="keyword">if</span> (N&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        N=-N;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        ans*=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：二分法</font></strong> 当我们得到x^(n/2)的时候，我们不需要再去乘上n/2个x了，而是x^(n/2)*x^(n/2)=x^n。</p>
<p>这个想法用递归很容易实现，但是需要注意的是n的奇偶性，如果n为奇数则需要再乘上一个x。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> half=myPow(x,n/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//奇偶性处理</span></span><br><span class="line">    <span class="keyword">double</span> rest=myPow(x,n%<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> half*half*rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——买卖股票的最佳时机</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="NO-121-买卖股票的最佳时机-简单"><a href="#NO-121-买卖股票的最佳时机-简单" class="headerlink" title="NO.121 买卖股票的最佳时机 简单 "></a>NO.121 买卖股票的最佳时机 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/09/3zzoW9.png" alt="3zzoW9.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 没什么好说的，双重循环计算所有元素两两组合相减的结果，取最大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            maxProfit=Math.max(maxProfit,prices[j]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><strong><font color=red>思路二：优化暴力法到一次遍历</font></strong> 买卖股票从第二天开始我们每天都会”后悔”：后悔没有在之前的最低点进行买入，只有这样我们的收益才会最大化。</p>
<p>由此可见，我们想要当天利益最大化，只需要在过去的某个最低点买入股票就好。所以我们只需要记录曾经出现过的最低点就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minPoint=Integer.MAX_VALUE,maxProfit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">//记录曾出现过最低点</span></span><br><span class="line">        minPoint=Math.min(prices[i],minPoint);</span><br><span class="line">        <span class="comment">//当日-曾经的最低</span></span><br><span class="line">        maxProfit=Math.max(maxProfit,prices[i]-minPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>从NO.121题不难看出：<strong><font color=red>买股票的最佳时机是曾经！股市有风险，入股需谨慎！</font></strong>(狗头)</p>
<p>单纯的解答本题是比较简单的，但是买卖股票可以算作是一个系列的经典问题，在leetcode上就有本题一系列的变种问题：买卖股票的最佳时机、买卖股票的最佳时机II、买卖股票的最佳时机III、买卖股票的最佳时机IV、买卖股票的最佳时机含冷冻期、买卖股票的最佳时机含手续费。</p>
<p>虽然这些题有难有易，但是既然是一类问题，就有这一些通用的方法。</p>
<p>这六个问题都是由第四个问题简化变种而来的，第四题相较于本题多了一个参数k，限制只能进行k次交易；第一题也就是本题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种。</p>
<p>之后记一下笔记总结一下这几个问题。</p>
<p>目前找到了”labuladong”大佬的公众号写的一篇《一个方法团灭 6 道股票问题》题解，打算先学习在总结。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——删除排序数组中的重复项</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%20/</url>
    <content><![CDATA[<h2 id="NO-26-删除排序数组中的重复项-简单"><a href="#NO-26-删除排序数组中的重复项-简单" class="headerlink" title="NO.26 删除排序数组中的重复项 简单 "></a>NO.26 删除排序数组中的重复项 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZCsTU.png" alt="lZCsTU.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/27/lZCrwT.png" alt="lZCrwT.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 题目中给了两个关键点需要特别思考”原地”和”不需要考虑数组中超出新长度后面的元素”，所谓的”原地”就是不需要创建新的数组将不重复的元素复制过去，只需要在原数组中进行”覆盖”即可；所谓”不需要考虑数组中超出新长度后面的元素”就是只需要将不重复元素都”紧凑到原数组的前面”，如：[1,1,1,2,3,3,4,6]遵循上述两个点进行”覆盖”和”紧凑”的结果[1,2,3,4,6,3,4,6]，算法的返回值为新长度5。</p>
<p>可以用两个指针i和j分别指向0号和1号元素，如果j指向的元素和i指向的元素相等就移动j指针，如果不相等则先移动i指针再让j指向的元素覆盖此时i指向的元素最后移动j指针，直至j指针遍历完所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="comment">//            如果不相等,则先移动i指针再让j指向的元素覆盖此时i指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——删除排序数组中的重复项</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="NO-26-删除排序数组中的重复项-简单"><a href="#NO-26-删除排序数组中的重复项-简单" class="headerlink" title="NO.26 删除排序数组中的重复项 简单 "></a>NO.26 删除排序数组中的重复项 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZCsTU.png" alt="lZCsTU.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/27/lZCrwT.png" alt="lZCrwT.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 题目中给了两个关键点需要特别思考”原地”和”不需要考虑数组中超出新长度后面的元素”，所谓的”原地”就是不需要创建新的数组将不重复的元素复制过去，只需要在原数组中进行”覆盖”即可；所谓”不需要考虑数组中超出新长度后面的元素”就是只需要将不重复元素都”紧凑到原数组的前面”，如：[1,1,1,2,3,3,4,6]遵循上述两个点进行”覆盖”和”紧凑”的结果[1,2,3,4,6,3,4,6]，算法的返回值为新长度5。</p>
<p>可以用两个指针i和j分别指向0号和1号元素，如果j指向的元素和i指向的元素相等就移动j指针，如果不相等则先移动i指针再让j指向的元素覆盖此时i指向的元素最后移动j指针，直至j指针遍历完所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="comment">//            如果不相等,则先移动i指针再让j指向的元素覆盖此时i指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——第K个排列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E7%AC%ACK%E4%B8%AA%E6%8E%92%E5%88%97%20/</url>
    <content><![CDATA[<h2 id="NO-60-第K个排列-中等"><a href="#NO-60-第K个排列-中等" class="headerlink" title="NO.60 第K个排列 中等 "></a>NO.60 第K个排列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/08/3x0skq.png" alt="3x0skq.png"></p>
<p><strong><font color=red>思路一：逆用康托展开</font></strong> 什么是康托展开式可以先从百度了解。本文直接从示例着手。</p>
<p>利用康托展开求排列是第几个，例如”213”是n=3的全排列中的第几个？<img src="https://s2.ax1x.com/2020/03/08/3x5LgH.png" alt="3x5LgH.png"></p>
<p>其实就是找出比”213”小的排列有几个，然后+1。</p>
<p>先比较首位，比2小的只有1，1开头的排列有1*2!个。</p>
<p>第二位比1小的不存在所以有0*1!排列。</p>
<p>第三位比3小的有1和2但是前面已经用过所以有0*0!个。</p>
<p>综上所述，有2个比”213”小的排列，所以”213”排在第3位。</p>
<p><strong>本题是逆用，知道n和第k个，求排列本身。</strong></p>
<p>例如：要找n=5，k=35的排列。共有5!=120个排列，从小到大要找第35个排列。</p>
<p>从首位开始找，首位分别是1、2、3、4、5的排列分成五组，每组各有(5-1)!=24个，由于k=35，所以要找的排列在第二组中，就是首位是2开头的24个排列中，即目标排列首位是”2”。</p>
<p>再看第二位，第二位可能是1、3、4、5分成四组，每组分别有(5-2)!=6个，由于k-24=11，所以要找的排列在第二组中，即目标排列的前两位是”23”。</p>
<p>同理，第三位可能是1、4、5分成三组，每组分别有(5-3)!=2个，因为k-6=5，所以要找的排列在第三组的两个排列中，即目标排列的前三位是”235”。</p>
<p>再然后第四位可能是1、4，分两组各有(5-4)!=1个，因为k-4=1，所以在第一组，即目标排列的前四位是”2351”。</p>
<p>最后第五位只剩下4，所以目标排列是”23514”。</p>
<p>找到第35个排列。</p>
<p><strong>其实这个方法就是分组，上例中找第一位时候将有序全排列按照首位数字分为5组，看看我们要找的那个排列在第几组中从而确定了首位数字。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//所有可用数字</span></span><br><span class="line">    StringBuilder map=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)map.append(i);</span><br><span class="line">    <span class="keyword">int</span> groupId,index=n;</span><br><span class="line">    <span class="comment">//逐位确定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//确定在当前分组的第几组</span></span><br><span class="line">        groupId=(k-<span class="number">1</span>)/foc(index);</span><br><span class="line">        <span class="comment">//得到分组的数字，移除使用过的数字</span></span><br><span class="line">        ans.append(map.charAt(groupId));</span><br><span class="line">        map.deleteCharAt(groupId);</span><br><span class="line">        <span class="comment">//更新k</span></span><br><span class="line">        k-=groupId*foc(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求 i!</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">foc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        x*=i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)    题目说n的范围[1,9]，可以直接将1~9的阶乘预先保存在一个数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//0~9的阶乘,直接使用</span></span><br><span class="line">    <span class="keyword">int</span> factor[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;</span><br><span class="line">    <span class="comment">//所有可用数字</span></span><br><span class="line">    StringBuilder map=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)map.append(i);</span><br><span class="line">    <span class="keyword">int</span> groupId,index=n;</span><br><span class="line">    <span class="comment">//逐位确定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//确定在当前分组的第几组</span></span><br><span class="line">        groupId=(k-<span class="number">1</span>)/factor[index];</span><br><span class="line">        <span class="comment">//得到分组的数字，移除使用过的数字</span></span><br><span class="line">        ans.append(map.charAt(groupId));</span><br><span class="line">        map.deleteCharAt(groupId);</span><br><span class="line">        <span class="comment">//更新k</span></span><br><span class="line">        k-=groupId*factor[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>康托展开式</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——解数独</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%A7%A3%E6%95%B0%E7%8B%AC%20/</url>
    <content><![CDATA[<h2 id="NO-37-解数独-困难"><a href="#NO-37-解数独-困难" class="headerlink" title="NO.37 解数独 困难 "></a>NO.37 解数独 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/23/310IhV.png" alt="310IhV.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3105t0.png" alt="3105t0.png"></p>
<p><strong><font color=red>思路一：回溯法</font></strong> 就是模拟人解数独时的简单想法：</p>
<ol>
<li>人在解数独的时候要注意每一行、每一列、每一个子数独中哪些数字已经被使用过了；</li>
<li>一行一行的进行填充，填充完一行就聚焦到下一行继续填充；</li>
<li>如果一个单元格中不为空，则去下一个单元格；</li>
<li>如果一个单元格为空，我们就看一下这个单元格所属的行、列、子数独中有哪些数字没有使用过，就将未使用过的数字填入单元格，并且记录这个被填入的数字在此单元格所属的行、列、子数独中已经被使用过了；</li>
<li>如果出现因为之前填充空格时选择不佳，导致无法继续填写空格的情况，就逐步擦除之前填入的数字，并将被擦除的数字在所属的行、列、子数独中设置为未使用的状态后，重新选择下一个未使用过的数字进行填充，尝试继续完成填充；</li>
<li>如果已经填充完所有行，即成功解数独。</li>
</ol>
<p>通过描述”我”解这类数独时的朴素想法，我们大概知道编码的方法了：</p>
<ol>
<li>大方向上，我们就是对需要填写的空白格进行尝试，不断地将每个空白格填写上当前状态可用的数字。当填写逐步推进的过程中，如果出现无法满足要求的组合时，就返回并擦除填写的数字，直至得到一个完全符合要求的组合。<u>这个过程就是典型的dfs剪枝回溯的思路。</u></li>
<li>我们需要实时的记录更新每一行、每一列、每一个子数独中1~9数字的使用情况。<u>这里可以用三大小为9*9的boolean类型数组分别记录，初始化为false表示都未使用，遍历初始数独将已使用过的数字记录为true表示已使用。</u></li>
<li>回溯方法中需要按行逐步推进，所有行都填写完毕即完成解数独。<u>编写时需要时刻记录当前填写的行和被填写的列。</u></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三个数组分别记录9行、9列、9个子数独中9个数字的使用状态，finished记录是否完成解数独</span></span><br><span class="line"><span class="keyword">boolean</span>[][] rows=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>],cols=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>],blocks=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">boolean</span> finished=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//解数独方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化状态数组，遍历初始数独，将使用过的数字的状态置为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                rows[row][board[row][col]-<span class="string">'1'</span>]=</span><br><span class="line">                    cols[col][board[row][col]-<span class="string">'1'</span>]=</span><br><span class="line">                    blocks[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][board[row][col]-<span class="string">'1'</span>]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度遍历，row记录当前要填写的行，col记录当前要填写的列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0-8行都已经填写，解数独完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==<span class="number">9</span>)&#123;</span><br><span class="line">        finished=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是空白格，不需要填写，继续向后移动</span></span><br><span class="line">    <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>)&#123;</span><br><span class="line">        <span class="comment">//如果本行已经是最后一列，则继续填写下一行的第一列；否则继续当前行的下一列。</span></span><br><span class="line">        <span class="keyword">if</span> (col==<span class="number">8</span>) dfs(board,row+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> dfs(board,row,col+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//按顺序将当前行、列、子数独未使用的数字尝试填入空白格</span></span><br><span class="line">        <span class="keyword">int</span> block = row / <span class="number">3</span> * <span class="number">3</span> + col / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//如果i+1未使用，可以填入当前空白格</span></span><br><span class="line">            <span class="keyword">if</span> (!rows[row][i] &amp;&amp; !cols[col][i] &amp;&amp; !blocks[block][i])&#123;</span><br><span class="line">                board[row][col]=(<span class="keyword">char</span>)(i+<span class="string">'1'</span>);</span><br><span class="line">                <span class="comment">//更新被入数字的状态</span></span><br><span class="line">                rows[row][i]=cols[col][i]=blocks[block][i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//填写完毕当前空白格，继续填写一格</span></span><br><span class="line">                <span class="keyword">if</span> (col==<span class="number">8</span>)dfs(board,row+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> dfs(board,row,col+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果当前尝试填入的数字组合不能成功解数独(导致后序空白格无法填写)，则回溯</span></span><br><span class="line">                <span class="keyword">if</span> (!finished)&#123;</span><br><span class="line">                    <span class="comment">//擦除填入的数字，并更新被擦除数字的状态</span></span><br><span class="line">                    board[row][col]=<span class="string">'.'</span>;</span><br><span class="line">                    rows[row][i]=cols[col][i]=blocks[block][i]=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看着长，除去注释其实没多少。而且这道题思路比较简单清晰易懂。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——N皇后II</title>
    <url>/2020/03/14/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/temp/%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9/%5BLeetCode%5D%E2%80%94%E2%80%94%20N%E7%9A%87%E5%90%8E%20/</url>
    <content><![CDATA[<h2 id="NO-51-N皇后-困难"><a href="#NO-51-N皇后-困难" class="headerlink" title="NO.51 N皇后 困难 "></a>NO.51 N皇后 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/28/3BxeVe.png" alt="3BxeVe.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/28/3Bxn5d.png" alt="3Bxn5d.png"></p>
<p>ps：皇后可以攻击同一行、同一列以及左上角、右上角、左下角、右下角这些角度方向上的任意单位。</p>
<p><strong><font color=red>思路一：回溯法</font></strong> 这道题使用回溯法的思路和<a href="https://blog.csdn.net/qq_42758551/article/details/104478835" target="_blank" rel="noopener">NO.37解数独</a>类似，每次填入一个元素就会导致增加后序填写时的约束条件。尝试依次填写的过程中无法继续时，就回溯并继续尝试另一种填写序列。</p>
<p>本题深度遍历回溯方法的骨架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dfs(棋盘board,当前行row,n)&#123;</span><br><span class="line">	if(终止条件)&#123;</span><br><span class="line">		保存当前序列;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    	if(board[row][i]可以填写)&#123;</span><br><span class="line">    		当前格子board[row][i]&#x3D;1;</span><br><span class="line">    		填写下一行dfs(board,row+1,n);</span><br><span class="line">    		擦除填写，验证下一个序列board[row][i]&#x3D;0;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终止条件是什么：棋盘的0~n-1行都填写完毕，即row==n。</p>
<p>如何保存当前序列：棋盘使用int[][]数组表示，0为’.’，1为’Q’。遍历每一行转换为字符串存入list，最后list存入结果。</p>
<p>如何判断当前格子是否可以：遍历当前列上是否已经有皇后；遍历当前左上至右下对角线上是否已经有皇后；遍历当前右上至左下对角线上是否已经有皇后。这些遍历只需要检测小于当前的行，因为大于当前的行还没有填写到一定没有皇后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//棋盘,默认为0表示空，1表示皇后</span></span><br><span class="line">    <span class="keyword">int</span>[][] board=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//row当前填写得的行号</span></span><br><span class="line">    dfs(n,<span class="number">0</span>,board);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0~n-1都填写完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==n)&#123;</span><br><span class="line">        res.add(track(board,n));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsable(board,row,col))&#123;</span><br><span class="line">            board[row][col]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//填写下一行</span></span><br><span class="line">            dfs(n,row+<span class="number">1</span>,board);</span><br><span class="line">            board[row][col]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//board[row][col]是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUsable</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查列上有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查左上至右下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+row-col&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i+row-col][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查右上至左下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row+col-i&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row+col-i][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将int类型棋盘转换成输出格式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">track</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j]==<span class="number">0</span>)temp.append(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">else</span> temp.append(<span class="string">'Q'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(temp.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——两数相加</title>
    <url>/2019/10/01/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="NO-2-两数相加-中等"><a href="#NO-2-两数相加-中等" class="headerlink" title="NO.2 两数相加    中等 "></a>NO.2 两数相加    <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMw8XR.png" alt="QMw8XR.png"></p>
<p><font color=red><strong>思路一：转换法</strong></font>    1.将两个链表先转化成int或long类型数值x和y。2.x和y相加后的值再转换成链表。</p>
<p><strong>缺点</strong>：当参数中两个链表足够长时，得到的结果很有可能会超出int或long类型的范围发生溢出。</p>
<p>可以将x和y用BigDecimal类型来存储尽可能避免发生溢出，<strong><u>需要注意的是题目中链表都是逆序的</u></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">""</span>;</span><br><span class="line">        String s2=<span class="string">""</span>;</span><br><span class="line">        ListNode q=l1,p=l2;</span><br><span class="line"><span class="comment">//        将两个链表转化为字符串</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s1=q.val+s1;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s2=p.val+s2;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        BigDecimal x=<span class="keyword">new</span> BigDecimal(s1);</span><br><span class="line">        BigDecimal y=<span class="keyword">new</span> BigDecimal(s2);</span><br><span class="line">        BigDecimal z=x.add(y);</span><br><span class="line"><span class="comment">//        将结果转换成链表</span></span><br><span class="line">        <span class="keyword">char</span>[] chars=z.toString().toCharArray();</span><br><span class="line">        ListNode result=<span class="keyword">new</span> ListNode(Integer.parseInt(String.valueOf(chars[chars.length-<span class="number">1</span>])));</span><br><span class="line">        ListNode t=result;</span><br><span class="line"><span class="comment">//        因为链表是逆序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=chars.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ListNode temp=<span class="keyword">new</span> ListNode(Integer.parseInt(String.valueOf(chars[i])));</span><br><span class="line">            t.next=temp;</span><br><span class="line">            t=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：初等数学法</strong></font>    1.因为链表本身就是逆序的，所以从后向前按位依次加。2.用一个int变量carry来记录前一位相加后得到的进位。3.如果一个链表已经遍历完毕，在后续的按位相加时，该链表的节点值就是0。4.每次按位相加之后更新进位值carry，并将进位之后的数值加入结果链表。5.<u>两个链表遍历相加结束之后，需要再次判断进位值，防止遗漏最高位的进位。</u></p>
<p><strong><u>需要注意的是每次按位相加时，不要忘记加上进位值carry。</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        用哑节点来简化代码，如果没有使用哑节点就需要额外的代码来初始化表头的值</span></span><br><span class="line">        ListNode dummyHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode q=l1,p=l2,curr=dummyHead;</span><br><span class="line"><span class="comment">//        进位标志carry</span></span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>||p!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//          获取节点值，如果节点为空，值就为0</span></span><br><span class="line">            <span class="keyword">int</span> x=q==<span class="keyword">null</span>?<span class="number">0</span>:q.val;</span><br><span class="line">            <span class="keyword">int</span> y=p==<span class="keyword">null</span>?<span class="number">0</span>:p.val;</span><br><span class="line"><span class="comment">//          两个节点值和进位相加</span></span><br><span class="line">            <span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line"><span class="comment">//          获取相加之后的进位值</span></span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line"><span class="comment">//          将相加后结果加入结果链表</span></span><br><span class="line">            curr.next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line"><span class="comment">//          移动到下一个节点</span></span><br><span class="line">            curr=curr.next;</span><br><span class="line">            <span class="keyword">if</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        最后判断是否仍有进位，防止进位被遗漏</span></span><br><span class="line">        <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            curr.next=<span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        因为第一个节点是哑节点，</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(max(m,n))</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>初等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[LeetCode]——计算质数</title>
    <url>/2019/10/01/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-204-计算质数-简单"><a href="#NO-204-计算质数-简单" class="headerlink" title="NO.204 计算质数    简单 "></a>NO.204 计算质数    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMwlp4.png" alt="QMwlp4.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font>    双层for循环。1.第一层循环遍历逐个判断[2,n)。2.第二层循环判断参数是否为素数。：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime(i))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^2)</p>
<p><strong>可改进点：</strong>例如，12=2*6、12=3*4、12=sqrt(12)*sqrt(12)、12=4*3、12=6<em>2，可以观察到后面就是前面两个数反过来，说明查找可以整除12的因子时只需要找到“一半”的位置即可，如果前“一半”没有可以整除的因子，那么后“一半”也没有，这个临界点“一半”就是sqrt(12)。所以上述isPrime()方法的循环条件可以写为“i\</em>i&lt;n”即可，该方法时间复杂度降到了O(sqrt(n))。</p>
<p><font color=red><strong>思路二：厄拉多塞筛法</strong></font>    不难想象，所有质数的倍数都不是质数。例如，2是质数，2的倍数4、6、8、10、12。。。都不是质数；3是质数，3的倍数6、9、12、15。。。都不是质数；可以看一下维基百科中一个厄拉多塞筛的gif图：</p>
<p><img src="https://s2.ax1x.com/2019/12/03/QMw11J.gif" alt="QMw11J.gif"></p>
<p>这种方法大概就是“排除法”，每确定一个质数，就可以排除一批非质数，那么算法就可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isPrimes[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrimes,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//		将所有质数的倍数设置为false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;n;j+=i)&#123;</span><br><span class="line">                isPrimes[j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//      统计所有质数，即isPrimes[i]==true的为质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述算法还存在两处冗余：</p>
<ol>
<li>在本题的暴利算法下说的：只需要判断到sqrt(n)即可。</li>
<li>例如，12不是质数，所以会被设置为false，但是12既是2的倍数，也是3的倍数，所以它被标记了两次。</li>
</ol>
<p>解决上述两处冗余后的算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isPrimes[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrimes,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//        只需要判断小于sqrt(n)的数是否为质数即可，所以i*i&lt;n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;n;i++)&#123;</span><br><span class="line"><span class="comment">//            这样可以把质数i的整数倍都标记为false，但是仍然存在计算冗余。</span></span><br><span class="line"><span class="comment">//            比如n=25，i=4时算法会标记4×2=8，4×3=12等等数字，</span></span><br><span class="line"><span class="comment">//            但是这两个数字已经被i=2和i=3的2×4和3×4标记了。所以使用j=i*i减少此计算的冗余。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i*i;j&lt;n;j+=i)&#123;</span><br><span class="line">                isPrimes[j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//      统计所有质数，即isPrimes[i]==true的为质数</span></span><br><span class="line"><span class="comment">//        这里要注意从2开始，因为0,1不是质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>厄尔拉塞筛法的时间复杂度：O(nloglogn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>厄拉多塞筛</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC中的集合参数绑定</title>
    <url>/2019/06/09/SpringMVC%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>绑定数组参数和集合参数<a id="more"></a></p>
<h2 id="1-绑定数组参数"><a href="#1-绑定数组参数" class="headerlink" title="1. 绑定数组参数"></a>1. 绑定数组参数</h2><p><u>语言匮乏，组织不好语言。。。直接上例子。。</u></p>
<p>例子：页面中多个checkbox<strong>组件</strong>的<strong>name</strong>都是ids。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/queryItem.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">查询条件：</span><br><span class="line">&lt;table width=<span class="string">"100%"</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;商品id&lt;input type="text" name="item.id" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;商品名称&lt;input type="text" name="item.name" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">商品列表：</span><br><span class="line">&lt;table width=<span class="string">"100%"</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;选择&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品名称&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品价格&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;生产日期&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品描述&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;操作&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;itemList &#125;"</span> <span class="keyword">var</span>=<span class="string">"item"</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;&lt;input type="checkbox" name="ids" value="$&#123;item.id&#125;"/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.name &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.price &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>controller方法可以用一个数组做形参，MVC的处理器适配器就会自动绑定参数。</p>
<p>对应以上的例子，controller方法的形参可以是<strong>Integer[ ]</strong> 类型，表单提交后被选中的checkbox的<strong>value</strong>就会被自动绑定到方法的形参中去。</p>
<h2 id="2-绑定集合参数"><a href="#2-绑定集合参数" class="headerlink" title="2.  绑定集合参数"></a>2.  绑定集合参数</h2><p>依然是上面的jsp文件，controller方法的形参直接改为<strong>List&lt;Integer&gt;</strong>,表单提交后会报错！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报错信息：Failed to instantiate [java.util.List]: Specified class is an interface</span><br></pre></td></tr></table></figure>

<p>此时需要一个pojo对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemVo</span> </span>&#123;</span><br><span class="line">	。</span><br><span class="line">    。</span><br><span class="line">    。</span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line">	</span><br><span class="line">	getter/setter。。。</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>将controller方法的形参改为ItemVo类型，会自动将表单提交来的参数，按参数名绑定到pojo类的集合属性中。</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller方法的返回值</title>
    <url>/2019/06/09/Controller%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<h3 id="1-返回ModelAndView"><a href="#1-返回ModelAndView" class="headerlink" title="1. 返回ModelAndView"></a>1. 返回ModelAndView<a id="more"></a></h3><p>最开始学习的时候就是返回这个类，可以给这个类添加model数据和指定view。</p>
<h3 id="2-返回void"><a href="#2-返回void" class="headerlink" title="2. 返回void"></a>2. 返回void</h3><p>返回值为空，那么model数据和view怎么办呢？</p>
<p>可以在形参中使用request和response，完成域对象存取数据、重定向、转发。。。（这里就有点像最初的servlet了）</p>
<h3 id="3-返回字符串"><a href="#3-返回字符串" class="headerlink" title="3. 返回字符串"></a>3. 返回字符串</h3><p>controller方法返回字符串可以指定<strong>逻辑视图名</strong>，通过<strong>视图解析器</strong>解析为<strong>物理视图地址</strong>。（类似于指定view）</p>
<p>可以在字符串前加<strong>Redirect</strong>或者<strong>forward</strong>完成<strong>重定向</strong>或<strong>转发</strong>。</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>@RequestMapping注解的作用</title>
    <url>/2019/06/09/@RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-URL路径映射"><a href="#1-URL路径映射" class="headerlink" title="1. URL路径映射"></a>1. URL路径映射<a id="more"></a></h3><p>最常用，用的最多的属性value</p>
<p>@RequestMapping(value=”item”)或@RequestMapping(“/item”）</p>
<p>value的值是数组，可以将多个url映射到同一个方法</p>
<h3 id="2-添加在类上面"><a href="#2-添加在类上面" class="headerlink" title="2. 添加在类上面"></a>2. 添加在类上面</h3><p>在<strong>class</strong>上添加<strong>@RequestMapping(url)</strong>指定<strong>通用请求前缀</strong>， <u>限制此类下的所有方法请求url必须以请求前缀开头</u>。</p>
<p><font color="red"><strong>可以使用此方法对url进行分类管理。</strong></font></p>
<h3 id="3-请求方法限定"><a href="#3-请求方法限定" class="headerlink" title="3. 请求方法限定"></a>3. 请求方法限定</h3><p>method属性，可以限制请求的方法GET、POST。。。</p>
<p>并且该方法也是一个数组，可以指定多个请求的方法。</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
</search>
