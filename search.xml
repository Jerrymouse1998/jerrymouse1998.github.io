<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode——有效数字</title>
    <url>/2020/03/14/LeetCode-%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p>什么是面向测试编程？试试本题就知道了！</p>
<h2 id="NO-65-有效数字-困难"><a href="#NO-65-有效数字-困难" class="headerlink" title="NO.65 有效数字 困难 "></a>NO.65 有效数字 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8Q6Wd0.png" alt="8Q6Wd0.png"></p>
<p>没有get到这道题目的点，这样的题目很搞心态。尤其是看了<a href="https://leetcode.com/problems/valid-number/discuss/23977/A-clean-design-solution-By-using-design-pattern" target="_blank" rel="noopener">作者的解答</a>之后更懵逼了，作者使用了责任链的设计模式，从来没想到解算法题还能用到设计模式。大牛的思维方式就适合我不一样，解个算法题都能考虑到扩展性和复用性。</p>
<h3 id="思路一：暴力法"><a href="#思路一：暴力法" class="headerlink" title="思路一：暴力法"></a><strong><font color=red>思路一：暴力法</font></strong></h3><p>按序遍历字符串，逐位判断是否合法。注意要去除首尾空格。</p>
<p>这种方法就是比较恶心，很容易有考虑不到的情况。</p>
<p>而且测试用例中有：”.1”、”.2”、”+.8”、”46.”、”2e0”等等，预期输出都是true。真的恶心到了。。。</p>
<p>切身感受什么是面向测试编程！！！！！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    s = s.trim();</span><br><span class="line">    <span class="keyword">if</span> (s.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> pointSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 .</span></span><br><span class="line">    <span class="keyword">boolean</span> eSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 e</span></span><br><span class="line">    <span class="keyword">boolean</span> numberSeen = <span class="keyword">false</span>;<span class="comment">//是否出现过 0-9</span></span><br><span class="line">    <span class="keyword">boolean</span> numberAfterE = <span class="keyword">true</span>;<span class="comment">//e之后是否出现 0-9</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'0'</span> &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= <span class="string">'9'</span>) &#123;<span class="comment">//当前元素是数字</span></span><br><span class="line">            numberSeen = <span class="keyword">true</span>;</span><br><span class="line">            numberAfterE = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'.'</span>) &#123;<span class="comment">//当前元素是 .</span></span><br><span class="line">            <span class="keyword">if</span>(eSeen || pointSeen) &#123;<span class="comment">//已经出现过 e或者.，则非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pointSeen = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'e'</span>) &#123;<span class="comment">//当前元素 e</span></span><br><span class="line">            <span class="keyword">if</span>(eSeen || !numberSeen) &#123;<span class="comment">//已经出现过 e或者e之前没出现过数字，则非法</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            numberAfterE = <span class="keyword">false</span>;<span class="comment">//注意这点很重要，现在开始记录e之后是否有数字</span></span><br><span class="line">            eSeen = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">'-'</span> || s.charAt(i) == <span class="string">'+'</span>) &#123;<span class="comment">//当前元素是-或+</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(i-<span class="number">1</span>) != <span class="string">'e'</span>) &#123;<span class="comment">//如果-或+不是第一个元素 或者 之前不是 e</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//当前元素不是0-9、. 、e 、- 、+，非法</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否有数字并且e之后也有数字</span></span><br><span class="line">    <span class="keyword">return</span> numberSeen &amp;&amp; numberAfterE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>写完暴力法，忍不住给下面这个骚操作点了个赞 : )</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            key=float(s)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="思路二：确定有限自动机-DFA"><a href="#思路二：确定有限自动机-DFA" class="headerlink" title="思路二：确定有限自动机(DFA)"></a><strong><font color=red>思路二：确定有限自动机(DFA)</font></strong></h3><p>下面搬运自leetcode社区windliang，我不是大佬，我只是大佬的搬运工。</p>
<p>先画出状态转换图：</p>
<p><img src="https://s1.ax1x.com/2020/03/14/8QIq3t.png" alt="8QIq3t.png"></p>
<p>如上图，从 0 开始总共有 9 个状态，橙色代表可接受状态，也就是表示此时是合法数字。总共有四大类输入，数字，小数点，e 和 正负号。我们只需要将这个图实现就够了。</p>
<p>这种方式思路清晰多了，但是之前没有接触过这种方法实现起来还是很生疏的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> state = <span class="number">0</span>;<span class="comment">//当前状态</span></span><br><span class="line">    s = s.trim();<span class="comment">//去除头尾的空格</span></span><br><span class="line">    <span class="comment">//遍历所有字符，当做输入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (s.charAt(i)) &#123;</span><br><span class="line">                <span class="comment">//输入正负号</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                    state = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="number">4</span>) &#123;</span><br><span class="line">                    state = <span class="number">6</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//输入数字</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'3'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'4'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'5'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'6'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'7'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'8'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'9'</span>:</span><br><span class="line">                <span class="comment">//根据当前状态去跳转</span></span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        state = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        state = <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                        state = <span class="number">5</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                        state = <span class="number">8</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                        state = <span class="number">8</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//小数点</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        state = <span class="number">7</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        state = <span class="number">3</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//e</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                        state = <span class="number">4</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//橙色部分的状态代表合法数字</span></span><br><span class="line">    <span class="keyword">return</span> state == <span class="number">2</span> || state == <span class="number">3</span> || state == <span class="number">5</span> || state == <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<h3 id="思路三：责任链模式"><a href="#思路三：责任链模式" class="headerlink" title="思路三：责任链模式"></a><strong><font color=red>思路三：责任链模式</font></strong></h3><p>解法二看起来已经很清晰明了了，只需要把状态图画出来，然后实现代码就很简单了。但是缺点是，如果状态图少考虑了东西，再改起来就会很麻烦。</p>
<p>这里作者提出来，利用责任链的设计模式，会使得写出的算法扩展性以及维护性更高。这里用到的思想就是，每个类只判断一种类型。比如判断是否是正数的类，判断是否是小数的类，判断是否是科学计数法的类，这样每个类只关心自己的部分，出了问题很好排查，而且互不影响。</p>
<p>虽然代码变多了，但是维护性，扩展性变的很强了。比如，题目新增了一种情况，”0x123” 16 进制也算是合法数字。这样的话，解法一和解法二就没什么用了，完全得重新设计。但对于解法三，我们只需要新增一个类，专门判断这种情况，然后加到执行者的数组里就够了，很牛逼！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个类都实现这个接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NumberValidate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个抽象类，用来检查一些基础的操作，是否为空，去掉首尾空格，去掉 +/-</span></span><br><span class="line"><span class="comment">//doValidate 交给子类自己去实现</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>  <span class="title">NumberValidateTemplate</span> <span class="keyword">implements</span> <span class="title">NumberValidate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (checkStringEmpty(s))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = checkAndProcessHeader(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> doValidate(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkStringEmpty</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">checkAndProcessHeader</span><span class="params">(String value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = value.trim();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (value.startsWith(<span class="string">"+"</span>) || value.startsWith(<span class="string">"-"</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            value = value.substring(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是整数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntegerValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String integer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; integer.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(integer.charAt(i)) == <span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是科学计数法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SienceFormatValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> pos = s.indexOf(<span class="string">"e"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String first = s.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String second = s.substring(pos+<span class="number">1</span>, s.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (validatePartBeforeE(first) == <span class="keyword">false</span> || validatePartAfterE(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePartBeforeE</span><span class="params">(String first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.equals(<span class="string">""</span>) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHeadAndEndForSpace(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate integerValidate = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        NumberValidate floatValidate = <span class="keyword">new</span> FloatValidate();</span><br><span class="line">        <span class="keyword">if</span> (integerValidate.validate(first) == <span class="keyword">false</span> &amp;&amp; floatValidate.validate(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkHeadAndEndForSpace</span><span class="params">(String part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (part.startsWith(<span class="string">" "</span>) ||</span><br><span class="line">            part.endsWith(<span class="string">" "</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">validatePartAfterE</span><span class="params">(String second)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (second.equals(<span class="string">""</span>) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkHeadAndEndForSpace(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate integerValidate = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        <span class="keyword">if</span> (integerValidate.validate(second) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现 doValidate 判断是否是小数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FloatValidate</span> <span class="keyword">extends</span> <span class="title">NumberValidateTemplate</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doValidate</span><span class="params">(String floatVal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pos = floatVal.indexOf(<span class="string">"."</span>);</span><br><span class="line">        <span class="keyword">if</span> (pos == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (floatVal.length() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        String first = floatVal.substring(<span class="number">0</span>, pos);</span><br><span class="line">        String second = floatVal.substring(pos + <span class="number">1</span>, floatVal.length());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkFirstPart(first) == <span class="keyword">true</span> &amp;&amp; checkFirstPart(second) == <span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkFirstPart</span><span class="params">(String first)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first.equals(<span class="string">""</span>) == <span class="keyword">false</span> &amp;&amp; checkPart(first) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPart</span><span class="params">(String part)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Character.isDigit(part.charAt(<span class="number">0</span>)) == <span class="keyword">false</span> ||</span><br><span class="line">            Character.isDigit(part.charAt(part.length() - <span class="number">1</span>)) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        <span class="keyword">if</span> (nv.validate(part) == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个执行者，我们把之前实现的各个类加到一个数组里，然后依次调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberValidator</span> <span class="keyword">implements</span> <span class="title">NumberValidate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;NumberValidate&gt; validators = <span class="keyword">new</span> ArrayList&lt;NumberValidate&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberValidator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        addValidators();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">addValidators</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        NumberValidate nv = <span class="keyword">new</span> IntegerValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line"></span><br><span class="line">        nv = <span class="keyword">new</span> FloatValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//nv = new HexValidate();</span></span><br><span class="line">        <span class="comment">//validators.add(nv);</span></span><br><span class="line"></span><br><span class="line">        nv = <span class="keyword">new</span> SienceFormatValidate();</span><br><span class="line">        validators.add(nv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (NumberValidate nv : validators)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nv.validate(s) == <span class="keyword">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    NumberValidate nv = <span class="keyword">new</span> NumberValidator();</span><br><span class="line">    <span class="keyword">return</span> nv.validate(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>确定有限自动机</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%20%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="NO-20-有效括号-简单"><a href="#NO-20-有效括号-简单" class="headerlink" title="NO.20 有效括号 简单 "></a>NO.20 有效括号 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFVldS.png" alt="lFVldS.png"></p>
<p><font color=red><strong>思路一：栈</strong></font>  学校的数据结构课就是那这个作为例子来引入栈结构的。1. 遍历表达式中每个字符，如果是’(‘或’[]’或’{‘就放入栈中。2. 如果是’)’或’]’或’}’就弹出栈顶字符top，如果此时栈为空或者将此时被遍历字符和top不匹配，则说明表达式无效。3. 遍历完所有字符，检查栈是否为空，如果不为空则表达式无效，反之有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//        用hashmap存储括号对</span></span><br><span class="line">        HashMap&lt;Character,Character&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">')'</span>,<span class="string">'('</span>);</span><br><span class="line">        map.put(<span class="string">']'</span>,<span class="string">'['</span>);</span><br><span class="line">        map.put(<span class="string">'&#125;'</span>,<span class="string">'&#123;'</span>);</span><br><span class="line"><span class="comment">//        用栈来保存遍历到的'(' '[' '&#123;'</span></span><br><span class="line">        Stack&lt;Character&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"><span class="comment">//            如果map中没有c这个key，则说明c是(或[或&#123;,就存入栈中（题目说只有六种字符）</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(c))&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//如果存在c这个key则说明，c是)或]或&#125;，就需要去和栈顶字符进行匹配</span></span><br><span class="line"><span class="comment">//                如果栈为空，则无法匹配</span></span><br><span class="line">                <span class="keyword">if</span> (stack.size()==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//                取出栈顶元素</span></span><br><span class="line">                Character top = stack.pop();</span><br><span class="line"><span class="comment">//                如果map中c的value和栈顶元素top不相等，则无法匹配</span></span><br><span class="line">                <span class="keyword">if</span> (map.get(c)!=top)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        遍历完所有字符之后，检查栈是否为空，如果为空则匹配，反之无法匹配</span></span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长上升子序列</title>
    <url>/2020/03/14/LeetCode-%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-300-最长上升子序列-中等"><a href="#NO-300-最长上升子序列-中等" class="headerlink" title="NO.300 最长上升子序列 中等 "></a>NO.300 最长上升子序列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/14/8QQPq1.png" alt="8QQPq1.png"></p>
<p>刚看到题，我以为寻找的这个上升子序列需要是连续的递增元素，所以我想双指针。发现行不通，重新审题发现，示例中的子序列元素不是连续的。。。</p>
<h3 id="思路一：动态规划"><a href="#思路一：动态规划" class="headerlink" title="思路一：动态规划"></a><strong><font color=red>思路一：动态规划</font></strong></h3><p>dp数组含义：dp[i]nums前i个元素中最长上升子序列的长度。</p>
<p>初始化：初始状态全部为1，因为每个元素自身至少是长度为1子序列。</p>
<p>状态转移：填写dp[i]时遍历j∈[0,i，</p>
<p>如果i元素&gt;j元素则当前元素i可以接在j元素之后作为上升子序列dp[i]=Max(dp[i],dp[j]+1)；</p>
<p>否则i元素&lt;=j元素当前元素i不能拼接在j元素之后就忽略。</p>
<p>每次填写完dp[i]更新当前最长上升子序列长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">    <span class="keyword">int</span> maxLen=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">//如果i元素&gt;j元素，则i可以接在j元素后面作为上升子序列</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[j])dp[i]=Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新最大长度</span></span><br><span class="line">        maxLen=Math.max(maxLen,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<h3 id="思路二：TreeSet"><a href="#思路二：TreeSet" class="headerlink" title="思路二：TreeSet"></a><strong><font color=red>思路二：TreeSet</font></strong></h3><p>JAVA Api中的TreeSet有ceiling(x)方法，取大于x的数，如果不存在则返回null。(此方法时间复杂度O(logn)，但是最坏情况下会退化到O(n))</p>
<p>按序遍历nums，到TreeSet中取大于num的数x，如果存在x则删除x并将num加入set，如果不存在就是所有的数都小于num就将num加入set。</p>
<p>最后返回set的大小即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    TreeSet&lt;Integer&gt; set=<span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        Integer x = set.ceiling(num);</span><br><span class="line">        <span class="keyword">if</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">            set.remove(x);</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> set.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最坏时间复杂度仍然是：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——N皇后II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20N%E7%9A%87%E5%90%8EII/</url>
    <content><![CDATA[<h2 id="NO-52-N皇后II-困难"><a href="#NO-52-N皇后II-困难" class="headerlink" title="NO.52 N皇后II 困难 "></a>NO.52 N皇后II <font color=#ff0099>困难</font> <a id="more"></a></h2><p>NO.52是NO.51的姊妹题，区别在于NO.51要求返回包含”棋子摆放”的List&lt;List&lt;String&gt;&gt;集合，而本题NO.52只需要返回一共有多少种摆法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NO.51:public List&lt;List&lt;String&gt;&gt; solveNQueens(int n)</span><br><span class="line">NO.52:public int totalNQueens(int n)</span><br></pre></td></tr></table></figure>

<p><strong><font color=red>思路一：回溯法</font></strong> 看到题的第一反应是直接把上一题回溯法的终止处理”res.add”改成”计数器+1”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//棋盘,默认为0表示空，1表示皇后</span></span><br><span class="line">    <span class="keyword">int</span>[][] board=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//row当前填写得的行号</span></span><br><span class="line">    dfs(n,<span class="number">0</span>,board);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0~n-1都填写完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==n)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsable(board,row,col))&#123;</span><br><span class="line">            board[row][col]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//填写下一行</span></span><br><span class="line">            dfs(n,row+<span class="number">1</span>,board);</span><br><span class="line">            board[row][col]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//board[row][col]是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUsable</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查列上有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查左上至右下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+row-col&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i+row-col][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查右上至左下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row+col-i&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row+col-i][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——Z字形变换</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="NO-6-Z字形变换-中等"><a href="#NO-6-Z字形变换-中等" class="headerlink" title="NO.6 Z字形变换 中等 "></a>NO.6 Z字形变换 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/10/QDB5TA.png" alt="QDB5TA.png"></p>
<p><font color=red><strong>思路一：按列写，按行读</strong></font> 将原字符串按列写成”Z字形”，写好之后按行读取“Z字形”。1.先创建一个有min(numRows,len(s))个元素的list，且list的每个元素都是一个StringBuilder。2.用两个变量分别记录当前是第几行和当前的方向。3.然后将参数字符串中的字符逐一填入。4.仅当前行等于list的第一个参数下标0或者等于numRows-1时方向改变。</p>
<p>这个思路很类似我们动手在纸上将参数字符串写成Z字形的过程，将所有字符逐一写出，在第一行写字符之后写字符的方向变为向下写，在最后一行（numRows）写字符之后写字符的方向变为向上写。当全部写完之后，按行将字符串读出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        List&lt;StringBuilder&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Math.min(numRows,s.length());i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> StringBuilder());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        定义一个变量记录方向，向下为false，向上为true</span></span><br><span class="line">        <span class="keyword">boolean</span> goingDown=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        记录当前是第几行</span></span><br><span class="line">        <span class="keyword">int</span> currentRow=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            list.get(currentRow).append(c);</span><br><span class="line"><span class="comment">//            如果当前行下标是第一行或者是最后一行，就改变方向标识</span></span><br><span class="line">            <span class="keyword">if</span> (currentRow==<span class="number">0</span>||currentRow==numRows-<span class="number">1</span>)goingDown=!goingDown;</span><br><span class="line"><span class="comment">//            行下标向当前方向移动，如果true就+1向下移动，如果是false就-1向上移动</span></span><br><span class="line">            currentRow+=goingDown?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        按行读取，获取最后的输出结果</span></span><br><span class="line">        StringBuilder ret=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (StringBuilder stringBuilder : list) &#123;</span><br><span class="line">            ret.append(stringBuilder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red><strong>思路二：直接按行访问</strong></font>  直接按照将参数字符串写成Z字形之后的结构进行按行访问拼接到结果字符串中。经过观察，可以发现如下规律：对于所有的行i和结果字符串中的字符索引k都有，1. 行0中的字符位于原字符串的k(2*numRows-2)索引处。 2. 行numRows-1中的字符位于原字符串的k(2*numRows-2)+numRows-1索引处。3. 内部的行i中的字符位于原字符串的k(2*numRows-1)+i以及(k+1)(2*numRows-2)-i索引处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String s, <span class="keyword">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">int</span> len=s.length();</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="comment">//        一个循环长度（Z字形两次方向变换，即向下写到numRows行方向变化为向上再写到0行的长度）</span></span><br><span class="line">    <span class="keyword">int</span> cycleLen=<span class="number">2</span>*numRows-<span class="number">2</span>;</span><br><span class="line"><span class="comment">//        0-numRows行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numRows;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j+i&lt;len;j+=cycleLen)&#123;</span><br><span class="line">            ans.append(s.charAt(j+i));</span><br><span class="line"><span class="comment">//     当不是第0行且不是第numRows-1行且当前行下一个字符在原字符串中存在时，将当前行下一个字符加入结果串</span></span><br><span class="line"><span class="comment">//                防止遗漏中间行的字符</span></span><br><span class="line">            <span class="keyword">if</span> (i!=<span class="number">0</span>&amp;&amp;i!=numRows-<span class="number">1</span>&amp;&amp;j+cycleLen-i&lt;len)</span><br><span class="line">                ans.append(s.charAt(j+cycleLen-i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——买卖股票的最佳时机</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="NO-121-买卖股票的最佳时机-简单"><a href="#NO-121-买卖股票的最佳时机-简单" class="headerlink" title="NO.121 买卖股票的最佳时机 简单 "></a>NO.121 买卖股票的最佳时机 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/09/3zzoW9.png" alt="3zzoW9.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 没什么好说的，双重循环计算所有元素两两组合相减的结果，取最大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxProfit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            maxProfit=Math.max(maxProfit,prices[j]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><strong><font color=red>思路二：优化暴力法到一次遍历</font></strong> 买卖股票从第二天开始我们每天都会”后悔”：后悔没有在之前的最低点进行买入，只有这样我们的收益才会最大化。</p>
<p>由此可见，我们想要当天利益最大化，只需要在过去的某个最低点买入股票就好。所以我们只需要记录曾经出现过的最低点就好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minPoint=Integer.MAX_VALUE,maxProfit=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="comment">//记录曾出现过最低点</span></span><br><span class="line">        minPoint=Math.min(prices[i],minPoint);</span><br><span class="line">        <span class="comment">//当日-曾经的最低</span></span><br><span class="line">        maxProfit=Math.max(maxProfit,prices[i]-minPoint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p>从NO.121题不难看出：<strong><font color=red>买股票的最佳时机是曾经！股市有风险，入股需谨慎！</font></strong>(狗头)</p>
<p>单纯的解答本题是比较简单的，但是买卖股票可以算作是一个系列的经典问题，在leetcode上就有本题一系列的变种问题：买卖股票的最佳时机、买卖股票的最佳时机II、买卖股票的最佳时机III、买卖股票的最佳时机IV、买卖股票的最佳时机含冷冻期、买卖股票的最佳时机含手续费。</p>
<p>虽然这些题有难有易，但是既然是一类问题，就有这一些通用的方法。</p>
<p>这六个问题都是由第四个问题简化变种而来的，第四题相较于本题多了一个参数k，限制只能进行k次交易；第一题也就是本题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种。</p>
<p>之后记一下笔记总结一下这几个问题。</p>
<p>目前找到了”labuladong”大佬的公众号写的一篇《一个方法团灭 6 道股票问题》题解，打算先学习在总结。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——Pow(x,n)</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20Pow(x,n)/</url>
    <content><![CDATA[<h2 id="NO-50-Pow-x-n-中等"><a href="#NO-50-Pow-x-n-中等" class="headerlink" title="NO.50 Pow(x,n) 中等 "></a>NO.50 Pow(x,n) <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/07/1gKljg.png" alt="1gKljg.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 这道题暴力法是不能通过leetcode判题机，会得到一个t。但是方法本身是可以得到正确答案的，所以我们需要对他进行优化。暴力法的想法很简单的：2^3=2*2*2。</p>
<p>如果n为负，则n=-n同时x=1/x，例如2^(-3)=1/2*1/2*1/2。但是这里要注意n的取值范围，主要是 正整数和负整数的不同范围限制 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> N=n;</span><br><span class="line">    <span class="keyword">if</span> (N&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        N=-N;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        ans*=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：二分法</font></strong> 当我们得到x^(n/2)的时候，我们不需要再去乘上n/2个x了，而是x^(n/2)*x^(n/2)=x^n。</p>
<p>这个想法用递归很容易实现，但是需要注意的是n的奇偶性，如果n为奇数则需要再乘上一个x。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (n)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> -<span class="number">1</span>:<span class="keyword">return</span> <span class="number">1</span>/x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> half=myPow(x,n/<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//奇偶性处理</span></span><br><span class="line">    <span class="keyword">double</span> rest=myPow(x,n%<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> half*half*rest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——第K个排列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E7%AC%ACK%E4%B8%AA%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-60-第K个排列-中等"><a href="#NO-60-第K个排列-中等" class="headerlink" title="NO.60 第K个排列 中等 "></a>NO.60 第K个排列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/08/3x0skq.png" alt="3x0skq.png"></p>
<p><strong><font color=red>思路一：逆用康托展开</font></strong> 什么是康托展开式可以先从百度了解。本文直接从示例着手。</p>
<p>利用康托展开求排列是第几个，例如”213”是n=3的全排列中的第几个？<img src="https://s2.ax1x.com/2020/03/08/3x5LgH.png" alt="3x5LgH.png"></p>
<p>其实就是找出比”213”小的排列有几个，然后+1。</p>
<p>先比较首位，比2小的只有1，1开头的排列有1*2!个。</p>
<p>第二位比1小的不存在所以有0*1!排列。</p>
<p>第三位比3小的有1和2但是前面已经用过所以有0*0!个。</p>
<p>综上所述，有2个比”213”小的排列，所以”213”排在第3位。</p>
<p><strong>本题是逆用，知道n和第k个，求排列本身。</strong></p>
<p>例如：要找n=5，k=35的排列。共有5!=120个排列，从小到大要找第35个排列。</p>
<p>从首位开始找，首位分别是1、2、3、4、5的排列分成五组，每组各有(5-1)!=24个，由于k=35，所以要找的排列在第二组中，就是首位是2开头的24个排列中，即目标排列首位是”2”。</p>
<p>再看第二位，第二位可能是1、3、4、5分成四组，每组分别有(5-2)!=6个，由于k-24=11，所以要找的排列在第二组中，即目标排列的前两位是”23”。</p>
<p>同理，第三位可能是1、4、5分成三组，每组分别有(5-3)!=2个，因为k-6=5，所以要找的排列在第三组的两个排列中，即目标排列的前三位是”235”。</p>
<p>再然后第四位可能是1、4，分两组各有(5-4)!=1个，因为k-4=1，所以在第一组，即目标排列的前四位是”2351”。</p>
<p>最后第五位只剩下4，所以目标排列是”23514”。</p>
<p>找到第35个排列。</p>
<p><strong>其实这个方法就是分组，上例中找第一位时候将有序全排列按照首位数字分为5组，看看我们要找的那个排列在第几组中从而确定了首位数字。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//所有可用数字</span></span><br><span class="line">    StringBuilder map=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)map.append(i);</span><br><span class="line">    <span class="keyword">int</span> groupId,index=n;</span><br><span class="line">    <span class="comment">//逐位确定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//确定在当前分组的第几组</span></span><br><span class="line">        groupId=(k-<span class="number">1</span>)/foc(index);</span><br><span class="line">        <span class="comment">//得到分组的数字，移除使用过的数字</span></span><br><span class="line">        ans.append(map.charAt(groupId));</span><br><span class="line">        map.deleteCharAt(groupId);</span><br><span class="line">        <span class="comment">//更新k</span></span><br><span class="line">        k-=groupId*foc(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求 i!</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">foc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">        x*=i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)    题目说n的范围[1,9]，可以直接将1~9的阶乘预先保存在一个数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPermutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    StringBuilder ans=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="comment">//0~9的阶乘,直接使用</span></span><br><span class="line">    <span class="keyword">int</span> factor[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">120</span>,<span class="number">720</span>,<span class="number">5040</span>,<span class="number">40320</span>,<span class="number">362880</span>&#125;;</span><br><span class="line">    <span class="comment">//所有可用数字</span></span><br><span class="line">    StringBuilder map=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i++)map.append(i);</span><br><span class="line">    <span class="keyword">int</span> groupId,index=n;</span><br><span class="line">    <span class="comment">//逐位确定</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index--;</span><br><span class="line">        <span class="comment">//确定在当前分组的第几组</span></span><br><span class="line">        groupId=(k-<span class="number">1</span>)/factor[index];</span><br><span class="line">        <span class="comment">//得到分组的数字，移除使用过的数字</span></span><br><span class="line">        ans.append(map.charAt(groupId));</span><br><span class="line">        map.deleteCharAt(groupId);</span><br><span class="line">        <span class="comment">//更新k</span></span><br><span class="line">        k-=groupId*factor[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>康托展开式</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——解数独</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%A7%A3%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="NO-37-解数独-困难"><a href="#NO-37-解数独-困难" class="headerlink" title="NO.37 解数独 困难 "></a>NO.37 解数独 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/23/310IhV.png" alt="310IhV.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/23/3105t0.png" alt="3105t0.png"></p>
<p><strong><font color=red>思路一：回溯法</font></strong> 就是模拟人解数独时的简单想法：</p>
<ol>
<li>人在解数独的时候要注意每一行、每一列、每一个子数独中哪些数字已经被使用过了；</li>
<li>一行一行的进行填充，填充完一行就聚焦到下一行继续填充；</li>
<li>如果一个单元格中不为空，则去下一个单元格；</li>
<li>如果一个单元格为空，我们就看一下这个单元格所属的行、列、子数独中有哪些数字没有使用过，就将未使用过的数字填入单元格，并且记录这个被填入的数字在此单元格所属的行、列、子数独中已经被使用过了；</li>
<li>如果出现因为之前填充空格时选择不佳，导致无法继续填写空格的情况，就逐步擦除之前填入的数字，并将被擦除的数字在所属的行、列、子数独中设置为未使用的状态后，重新选择下一个未使用过的数字进行填充，尝试继续完成填充；</li>
<li>如果已经填充完所有行，即成功解数独。</li>
</ol>
<p>通过描述”我”解这类数独时的朴素想法，我们大概知道编码的方法了：</p>
<ol>
<li>大方向上，我们就是对需要填写的空白格进行尝试，不断地将每个空白格填写上当前状态可用的数字。当填写逐步推进的过程中，如果出现无法满足要求的组合时，就返回并擦除填写的数字，直至得到一个完全符合要求的组合。<u>这个过程就是典型的dfs剪枝回溯的思路。</u></li>
<li>我们需要实时的记录更新每一行、每一列、每一个子数独中1~9数字的使用情况。<u>这里可以用三大小为9*9的boolean类型数组分别记录，初始化为false表示都未使用，遍历初始数独将已使用过的数字记录为true表示已使用。</u></li>
<li>回溯方法中需要按行逐步推进，所有行都填写完毕即完成解数独。<u>编写时需要时刻记录当前填写的行和被填写的列。</u></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三个数组分别记录9行、9列、9个子数独中9个数字的使用状态，finished记录是否完成解数独</span></span><br><span class="line"><span class="keyword">boolean</span>[][] rows=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>],cols=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>],blocks=<span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line"><span class="keyword">boolean</span> finished=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//解数独方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化状态数组，遍历初始数独，将使用过的数字的状态置为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">9</span>; row++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; <span class="number">9</span>; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>)&#123;</span><br><span class="line">                rows[row][board[row][col]-<span class="string">'1'</span>]=</span><br><span class="line">                    cols[col][board[row][col]-<span class="string">'1'</span>]=</span><br><span class="line">                    blocks[row/<span class="number">3</span>*<span class="number">3</span>+col/<span class="number">3</span>][board[row][col]-<span class="string">'1'</span>]=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(board,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度遍历，row记录当前要填写的行，col记录当前要填写的列</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0-8行都已经填写，解数独完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==<span class="number">9</span>)&#123;</span><br><span class="line">        finished=<span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是空白格，不需要填写，继续向后移动</span></span><br><span class="line">    <span class="keyword">if</span> (board[row][col] != <span class="string">'.'</span>)&#123;</span><br><span class="line">        <span class="comment">//如果本行已经是最后一列，则继续填写下一行的第一列；否则继续当前行的下一列。</span></span><br><span class="line">        <span class="keyword">if</span> (col==<span class="number">8</span>) dfs(board,row+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> dfs(board,row,col+<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//按顺序将当前行、列、子数独未使用的数字尝试填入空白格</span></span><br><span class="line">        <span class="keyword">int</span> block = row / <span class="number">3</span> * <span class="number">3</span> + col / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//如果i+1未使用，可以填入当前空白格</span></span><br><span class="line">            <span class="keyword">if</span> (!rows[row][i] &amp;&amp; !cols[col][i] &amp;&amp; !blocks[block][i])&#123;</span><br><span class="line">                board[row][col]=(<span class="keyword">char</span>)(i+<span class="string">'1'</span>);</span><br><span class="line">                <span class="comment">//更新被入数字的状态</span></span><br><span class="line">                rows[row][i]=cols[col][i]=blocks[block][i]=<span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//填写完毕当前空白格，继续填写一格</span></span><br><span class="line">                <span class="keyword">if</span> (col==<span class="number">8</span>)dfs(board,row+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> dfs(board,row,col+<span class="number">1</span>);</span><br><span class="line">                <span class="comment">//如果当前尝试填入的数字组合不能成功解数独(导致后序空白格无法填写)，则回溯</span></span><br><span class="line">                <span class="keyword">if</span> (!finished)&#123;</span><br><span class="line">                    <span class="comment">//擦除填入的数字，并更新被擦除数字的状态</span></span><br><span class="line">                    board[row][col]=<span class="string">'.'</span>;</span><br><span class="line">                    rows[row][i]=cols[col][i]=blocks[block][i]=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码看着长，除去注释其实没多少。而且这道题思路比较简单清晰易懂。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——删除排序数组中的重复项</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h2 id="NO-26-删除排序数组中的重复项-简单"><a href="#NO-26-删除排序数组中的重复项-简单" class="headerlink" title="NO.26 删除排序数组中的重复项 简单 "></a>NO.26 删除排序数组中的重复项 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZCsTU.png" alt="lZCsTU.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/27/lZCrwT.png" alt="lZCrwT.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 题目中给了两个关键点需要特别思考”原地”和”不需要考虑数组中超出新长度后面的元素”，所谓的”原地”就是不需要创建新的数组将不重复的元素复制过去，只需要在原数组中进行”覆盖”即可；所谓”不需要考虑数组中超出新长度后面的元素”就是只需要将不重复元素都”紧凑到原数组的前面”，如：[1,1,1,2,3,3,4,6]遵循上述两个点进行”覆盖”和”紧凑”的结果[1,2,3,4,6,3,4,6]，算法的返回值为新长度5。</p>
<p>可以用两个指针i和j分别指向0号和1号元素，如果j指向的元素和i指向的元素相等就移动j指针，如果不相等则先移动i指针再让j指向的元素覆盖此时i指向的元素最后移动j指针，直至j指针遍历完所有元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;len;j++)&#123;</span><br><span class="line"><span class="comment">//            如果不相等,则先移动i指针再让j指向的元素覆盖此时i指向的元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]!=nums[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——四数之和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-18-四数之和-中等"><a href="#NO-18-四数之和-中等" class="headerlink" title="NO.18 四数之和 中等 "></a>NO.18 四数之和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/19/QLB8Qs.png" alt="QLB8Qs.png"></p>
<p><font color=red><strong>思路一：双指针法</strong></font> 熟悉的配方，熟悉的味道，回想“2.两数之和”和“15.三数之和”分别是如何计算的。这里我的思路是将二者相结合形参这道“四数之和”的算法：1.因为需要用到双指针法，所以先将数组排序。2. 遍历数组每个元素nums[i]的时候计算其于target的差值temp（这里有点两数之和的味道）。3. 同时在nums[i]元素后面的部分寻找是否有三个数相加等于temp（这里就是进行双指针法解三数之和，具体思路参考<a href="https://jerrymouse1998.github.io/post/%E5%BE%92%E6%89%8B%E6%8C%96%E5%9C%B0%E7%90%83%E5%85%AD%E5%91%A8%E7%9B%AE/">徒手挖地球六周目</a>中的三数之和双指针法思路），如果找到三数和等于temp就将这三个数和nums[i]加入结果集。5. 在nums[i]元素后面的部分进行双指针法全部遍历完后，对nums[i+1]进行上述操作，直至数组中所有元素都进行完毕。</p>
<p>和”三数之和”一样需要”<strong>去重</strong>“：1. 外层for遍历每个元素nums[i]时，除了0号元素之外如果nums[i]==nums[i+1]，则需要跳过。2. 内层循环除了第一个元素之外，如果nums[j]==nums[j+1],也需要跳过。</p>
<p>可以<strong>优化</strong>的地方：1. 固定当前nums[i]元素后，最小的四数之和已经大于target，则结束循环。2.固定当前nums[i]元素后，当前最大的四数之和依然小于target，则跳过当前元素，进行下一个元素nums[i+1]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len=nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">4</span>)<span class="keyword">return</span> ans;</span><br><span class="line"><span class="comment">//        排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        遍历数组每一个元素,因为是求四数之和，所以i&lt;len-3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len-<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="comment">//            如果当前最小的四数之和已经大于target，则结束循环</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[i+<span class="number">1</span>]+nums[i+<span class="number">2</span>]+nums[i+<span class="number">3</span>]&gt; target)<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//            如果当前最大的四数之和依然小于target，则跳过当前元素，进行下一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[len-<span class="number">1</span>]+nums[len-<span class="number">2</span>]+nums[len-<span class="number">3</span>]&lt; target)<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            跳过重复的元素</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            当前数组想要组成target所需要的值</span></span><br><span class="line">            <span class="keyword">int</span> temp=target-nums[i];</span><br><span class="line">            </span><br><span class="line"><span class="comment">//            遍历i号元素后面部分的每个元素，因为是求三数之和，所以i&lt;len-2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;len-<span class="number">2</span>;j++)&#123;</span><br><span class="line"><span class="comment">//                跳过重复元素</span></span><br><span class="line">                <span class="keyword">if</span> (j&gt;i+<span class="number">1</span>&amp;&amp;nums[j]==nums[j-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//                用双指针分别指向j号元素后面部分的开始元素和结尾元素</span></span><br><span class="line">                <span class="keyword">int</span> L=j+<span class="number">1</span>,R=len-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum=nums[j]+nums[L]+nums[R];</span><br><span class="line">                    <span class="keyword">if</span> (sum==temp)&#123;</span><br><span class="line">                        ans.add(Arrays.asList(nums[i],nums[j],nums[L],nums[R]));</span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[L]==nums[L+<span class="number">1</span>])L++;</span><br><span class="line">                        <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[R]==nums[R-<span class="number">1</span>])R--;</span><br><span class="line">                        L++;</span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;temp)&#123;</span><br><span class="line">                        L++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;temp)&#123;</span><br><span class="line">                        R--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^3)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——最长回文子串</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="NO-5-最长回文子串-中等"><a href="#NO-5-最长回文子串-中等" class="headerlink" title="NO.5 最长回文子串 中等 "></a>NO.5 最长回文子串 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/05/Q8ZSII.png" alt="Q8ZSII.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 用两个for循环划分出所有子串，并依次判断划分出的子串是否为回文，如果是回文并且子串长度大于ans当前记录的值，就更新ans。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    String ans=<span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;s.length();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s.substring(i,j))&amp;&amp;len&lt;j-i+<span class="number">1</span>)&#123;</span><br><span class="line">                ans=s.substring(i,j);</span><br><span class="line">                len=Math.max(len,ans.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length()/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i)!=s.charAt(s.length()-<span class="number">1</span>-i))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^3)</p>
<p><font color=red><strong>思路二：扩展中心法</strong></font> 经过对回文特点的观察发现，回文都是中心对称的。所以我们可以从中心进行展开判断，一个长度为n的字符串中有2n-1个中心（因为回文长度有可能是基数或偶数，基数回文的中心有n个，如abc中心是b；偶数回文的中心有n-1个，如abbc中心是bb）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        如果是空串，则直接返回空串表示没有回文串</span></span><br><span class="line">        <span class="keyword">if</span> (s==<span class="keyword">null</span>||s.length()&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>,end=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line"><span class="comment">//            判断i为中心的基数回文长度</span></span><br><span class="line">            <span class="keyword">int</span> len1=expandAroundCenter(s,i,i);</span><br><span class="line"><span class="comment">//            判断i，i+1为中心的偶数回文长度</span></span><br><span class="line">            <span class="keyword">int</span> len2=expandAroundCenter(s,i,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> len=Math.max(len1,len2);</span><br><span class="line"><span class="comment">//            如果新回文串的长度大于之前的回文串长度，则更新</span></span><br><span class="line">            <span class="keyword">if</span> (len&gt;end-start)&#123;</span><br><span class="line"><span class="comment">//                </span></span><br><span class="line">                start=i-(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">                end=i+len/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        因为substring()方法截取的范围是[起始索引,结束索引)，所以第二个参数需要+1</span></span><br><span class="line">        <span class="keyword">return</span> s.substring(start,end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">expandAroundCenter</span><span class="params">(String s,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="comment">//        当左标记大于等于0,且右标记小于输入串长，且当前左右标记的字符相等时，左右标记分别中心扩展</span></span><br><span class="line">        <span class="keyword">while</span> (left&gt;=<span class="number">0</span>&amp;&amp;right&lt;s.length()&amp;&amp;s.charAt(left)==s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        返回以i或(i，i+1)为中心的回文串长度。</span></span><br><span class="line">        <span class="keyword">return</span> right-left-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><font color=red><strong>思路三：最长公共子串法(LCS)</strong></font> 回文是从左向右读和从右向左读都是一样的，所以我们可以将原字符串s倒置之后获得s’，然后取s和s’的最长公共子串ans作为最长回文子串。</p>
<p>用动态规划法求最长公共子串，大概思路是：1.申请一个二维数组arr[s.length][s’.length]。2.判断每个对应位置的字符是否相等，如果相等 arr[i][j]=arr[i-1][j-1]+1；当i=0或j=0时候单独分析，如果对应位置字符相等 arr[i][j]=1。(<strong>PS：</strong>arr[i][j]保存的就是公共子串的长度。)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String origin=s;</span><br><span class="line"><span class="comment">//        倒置原字符串</span></span><br><span class="line">        String reverse=<span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line"><span class="comment">//        maxLen记录最长公共子序列，maxEnd记录最长公共子序列的结尾下标</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>,maxEnd=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        分别以原字符串长度和倒置字符串长度来表示，是为了更直观的理解该二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr=<span class="keyword">new</span> <span class="keyword">int</span>[origin.length()][reverse.length()];</span><br><span class="line"><span class="comment">//        双重循环遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;reverse.length();j++)&#123;</span><br><span class="line"><span class="comment">//                判断原字符串i位置字符和倒置字符串j位置字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (origin.charAt(i)==reverse.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;<span class="comment">//当i=0或j=0时候单独分析，如果对应位置字符相等 arr[i][j]=1</span></span><br><span class="line">                        arr[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        arr[i][j]=arr[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                如果当前公共子串长度比maxLen所记录的值更大，则更新最长公共子串的长度及其结束下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i][j]&gt;maxLen)&#123;</span><br><span class="line">                    maxLen=arr[i][j];</span><br><span class="line">                    maxEnd=i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxEnd-maxLen+<span class="number">1</span>,maxEnd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>当S=”abc435cba”，S’=”abc534cba”时，上述算法依然可以计算出最长公共子串”abc”来作为最长回文子串，这显然是不对的。</font>对于这个问题的解决思路是：1.因为j一直指向倒置字符串中子串的末尾字符，可以先求出j指向的字符X倒置之前的下标beforeReverse=length-1-j。2.此时求出的beforeReverse是X在<strong>原字符串中的子串首位的下标</strong>，还需要加上当前子串的长度才是<strong>原字符串中子串末尾的下标</strong>e，即e=beforeReverse+arr[i][j]-1。3.因为i一直指向原字符串中子串的末尾字符，所以将e与i进行比较，如果相等，则说明当前找到的公共子串是回文子串。</p>
<p>例如，字符串倒置前后分别是S=”abc435cba”，S’=”abc534cba”，当i=2且j=2时，arr[2][2]=3,然后进行计算出beforeReverse=length-1-j=9-1-2=6，判断beforeReverse+arr[2][2]-1是否等于i，显然 6+3-1!=2，所以当前子串不是回文子串且不需要更新maxLen和maxEnd。</p>
<p><img src="https://s2.ax1x.com/2019/12/08/Qamn76.png" alt="Qamn76.png"></p>
<p>针对该思路，只需要在更新maxLen和maxEnd之前添加<strong>下标是否匹配的判断</strong>即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String origin=s;</span><br><span class="line"><span class="comment">//        倒置原字符串</span></span><br><span class="line">        String reverse=<span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line"><span class="comment">//        maxLen记录最长公共子序列，maxEnd记录最长公共子序列的结尾下标</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>,maxEnd=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        分别以原字符串长度和倒置字符串长度来表示，是为了更直观的理解该二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] arr=<span class="keyword">new</span> <span class="keyword">int</span>[origin.length()][reverse.length()];</span><br><span class="line"><span class="comment">//        双重循环遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;reverse.length();j++)&#123;</span><br><span class="line"><span class="comment">//                判断原字符串i位置字符和倒置字符串j位置字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (origin.charAt(i)==reverse.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;<span class="comment">//当i=0或j=0时候单独分析，如果对应位置字符相等 arr[i][j]=1</span></span><br><span class="line">                        arr[i][j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        arr[i][j]=arr[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                如果当前公共子串长度比maxLen所记录的值更大，则更新最长公共子串的长度及其结束下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i][j]&gt;maxLen)&#123;</span><br><span class="line">                    <span class="keyword">int</span> beforeReverse=origin.length()-<span class="number">1</span>-j;</span><br><span class="line"><span class="comment">//					  添加下标是否匹配的判断                 </span></span><br><span class="line">                    <span class="keyword">if</span> (beforeReverse+arr[i][j]-<span class="number">1</span>==i) &#123;</span><br><span class="line">                        maxLen = arr[i][j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxEnd-maxLen+<span class="number">1</span>,maxEnd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^2)</p>
<p>写到这里，利用LCS算法解决求最长回文子串的问题已经基本完成了,经过查阅资料和学习之后发现：其实可以使用一个一位数组即可，而不必使用上述的二维数组arr[][]。空间复杂度从之前的用二维数组时的O(n^2)降到了用一维数组后的O(n)。</p>
<p>例如还是上面的那个数组S=”abc435cba”，i=0，j=1、2、3、4、5、6、7、8更新了第一列；i=2j=1、2、3、4、5、6、7、8更新了第二列，以此类推直到i=8且j=8每一列都更新完毕。但是经过观察发现，每次更新时只需要参考前一列的值，更新第三列时，第一列的值就用不到了，所以只需要一个一维数组就可以了。但是，更新arr[i]的时候需要arr[i-1]的值，例如arr[3]=arr[2]+1，arr[4]=arr[3]+1，此时的arr[3]的信息已经被更新过了并不是”之前一列的信息了“，所以循环时j不能从0到8递增，应该倒过来，arr[8]=arr[7]+1、arr[7]=arr[6]+1。。。更新arr[8]时用arr[7]，用完之后才能去更新arr[7]：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        String origin=s;</span><br><span class="line"><span class="comment">//        倒置原字符串</span></span><br><span class="line">        String reverse=<span class="keyword">new</span> StringBuffer(s).reverse().toString();</span><br><span class="line"><span class="comment">//        maxLen记录最长公共子序列，maxEnd记录最长公共子序列的结尾下标</span></span><br><span class="line">        <span class="keyword">int</span> maxLen=<span class="number">0</span>,maxEnd=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        分别以原字符串长度和倒置字符串长度来表示，是为了更直观的理解该二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr=<span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"><span class="comment">//        双重循环遍历二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;origin.length();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=reverse.length()-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="comment">//                判断原字符串i位置字符和倒置字符串j位置字符是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (origin.charAt(i)==reverse.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;<span class="comment">//当i=0或j=0时候单独分析，如果对应位置字符相等 arr[j]=1</span></span><br><span class="line">                        arr[j]=<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        arr[j]=arr[j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//之前是二维数组每一列默认值就是0，现在是一维数组所以需要手动更新为0</span></span><br><span class="line">                    arr[j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                如果当前公共子串长度比maxLen所记录的值更大，则更新最长公共子串的长度及其结束下标</span></span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;maxLen)&#123;</span><br><span class="line">                    <span class="keyword">int</span> beforeReverse=origin.length()-<span class="number">1</span>-j;</span><br><span class="line">                    <span class="keyword">if</span> (beforeReverse+arr[j]-<span class="number">1</span>==i) &#123;</span><br><span class="line">                        maxLen = arr[j];</span><br><span class="line">                        maxEnd = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(maxEnd-maxLen+<span class="number">1</span>,maxEnd+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路四：Manacher算法</strong></font> 在扩展中心算法中，将奇数长度回文子串和偶数长度的回文子串分别进行了处理。本算法首先解决了奇数和偶数的问题，在每个字符间插入“#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入“^”和“$”，这样重心扩展的时候，判断两端字符是否相等时，如果到了边界就一定不会相等，从而结束循环（这里的“#”“^”“$”是字符串中不存在的字符）。并且，经过插入特殊字符处理后，字符串的长度永远都是奇数了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，</span><br><span class="line">	&quot;aba&quot; 扩展为 &quot;^#a#b#a#$&quot;</span><br><span class="line">	&quot;acca&quot; 扩展为 &quot;^#a#c#c#a#$&quot;</span><br><span class="line">	&quot;cbcbccde&quot; 扩展为 &quot;^#c#b#c#b#c#c#d#e#$&quot;</span><br></pre></td></tr></table></figure>

<p>字符串扩展之后，我们申请一个数组p[]保存从中心扩展的最大个数，而这个数也刚好是去掉”#“之后原子串的长度。例如下图中下标为6的字符，p[6]=5,所以它是从左边扩展5个字符，相应的右边也是扩展5个字符，也就是“#c#b#c#b#c#”。而去掉“#”恢复到原来的子串，变成“cbcbc”，它的长度刚好也是5。</p>
<p><img src="https://s2.ax1x.com/2019/12/08/QawkCQ.png" alt="QawkCQ.png"></p>
<p><strong>求原字符串下标</strong>：用p的下标i减去p[i]，再除以2，就是原字符串的开头下标了。例如，我们找到上图中p[i]最大值为5，也就是回文串的最大长度是5，对应的下标是6，所以原子串在原字符串中的开头下标是（6-5）/2=0。所以我们只需要返回原字符串的第0到第（5-1）位就可以了。</p>
<p>既然已经知道了如何利用p[]数组巧妙地取得结果子串了，那么就要进行马拉车算法最重要的步骤了，即<strong>如何求p[]数组？</strong></p>
<p>这一步是马拉车算法的精髓所在，充分利用的回文的对称性。用c表示回文子串的中心，用r表示回文子串的右边半径。所以r=c+p[i]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串，而不一定是最长的回文串。</p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0m8Ld.png" alt="Q0m8Ld.png"></p>
<p>用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。 我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串中心 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。</p>
<p><font color=green>但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论:</font></p>
<p><font color=green><strong>情况一：超出了 R</strong></font></p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0mJeA.png" alt="Q0mJeA.png"></p>
<p>当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。</p>
<p><font color=green><strong>情况二：P [ i_mirror ] 遇到了原字符串的左边界</strong></font></p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0mtot.png" alt="Q0mtot.png"></p>
<p>此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。</p>
<p><font color=green><strong>情况三：i 等于了 R</strong></font></p>
<p>此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。</p>
<p><strong>考虑 C 和 R 的更新</strong><br>就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。</p>
<p><img src="https://s2.ax1x.com/2019/12/09/Q0mYdI.png" alt="Q0mYdI.png"></p>
<p>此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        获取扩充后的字符串T</span></span><br><span class="line">        String T=preProsess(s);</span><br><span class="line">        <span class="keyword">int</span> len=T.length();</span><br><span class="line">        <span class="keyword">int</span>[] p=<span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> c=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        不需要判断前后边界字符“^"和“$”，所以循环范围是[1,len-1)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len-<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="comment">//            第i个字符关于c对称的下标</span></span><br><span class="line">            <span class="keyword">int</span> i_mirror=<span class="number">2</span>*c-i;</span><br><span class="line">            <span class="keyword">if</span> (r&gt;i)&#123;<span class="comment">//如果i小于对称半径r</span></span><br><span class="line">                p[i]=Math.max(r-i,p[i_mirror]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                p[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            遇到三种特殊情况时，需要退化到中心扩展法</span></span><br><span class="line">            <span class="keyword">while</span> (T.charAt(i+<span class="number">1</span>+p[i])==T.charAt(i-<span class="number">1</span>-p[i]))&#123;</span><br><span class="line">                p[i]++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            判断是否需要更新c和r</span></span><br><span class="line">            <span class="keyword">if</span> (i+p[i]&gt;r)&#123;</span><br><span class="line">                c=i;</span><br><span class="line">                r=p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        找出p[]数组中最大的值</span></span><br><span class="line">        <span class="keyword">int</span> currentIndex=<span class="number">0</span>,maxLen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;p.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p[i]&gt;maxLen)&#123;</span><br><span class="line">                currentIndex=i;</span><br><span class="line">                maxLen=p[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        求子串首字符在原字符串中的下标</span></span><br><span class="line">        <span class="keyword">int</span> start=(currentIndex-maxLen)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    扩充字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">preProsess</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="string">"$"</span>;</span><br><span class="line">        String result=<span class="string">"^"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            result+=<span class="string">"#"</span>+s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        result+=<span class="string">"#$"</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>Manacher算法</tag>
        <tag>中心扩展</tag>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——N皇后</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<h2 id="NO-51-N皇后-困难"><a href="#NO-51-N皇后-困难" class="headerlink" title="NO.51 N皇后 困难 "></a>NO.51 N皇后 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/28/3BxeVe.png" alt="3BxeVe.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/28/3Bxn5d.png" alt="3Bxn5d.png"></p>
<p>ps：皇后可以攻击同一行、同一列以及左上角、右上角、左下角、右下角这些角度方向上的任意单位。</p>
<p><strong><font color=red>思路一：回溯法</font></strong> 这道题使用回溯法的思路和<a href="http://www.m1ng.top/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%A7%A3%E6%95%B0%E7%8B%AC/" target="_blank" rel="noopener">NO.37解数独</a>类似，每次填入一个元素就会导致增加后序填写时的约束条件。尝试依次填写的过程中无法继续时，就回溯并继续尝试另一种填写序列。</p>
<p>本题深度遍历回溯方法的骨架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dfs(棋盘board,当前行row,n)&#123;</span><br><span class="line">	if(终止条件)&#123;</span><br><span class="line">		保存当前序列;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i&#x3D;0;i&lt;n;i++)&#123;</span><br><span class="line">    	if(board[row][i]可以填写)&#123;</span><br><span class="line">    		当前格子board[row][i]&#x3D;1;</span><br><span class="line">    		填写下一行dfs(board,row+1,n);</span><br><span class="line">    		擦除填写，验证下一个序列board[row][i]&#x3D;0;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终止条件是什么：棋盘的0~n-1行都填写完毕，即row==n。</p>
<p>如何保存当前序列：棋盘使用int[][]数组表示，0为’.’，1为’Q’。遍历每一行转换为字符串存入list，最后list存入结果。</p>
<p>如何判断当前格子是否可以：遍历当前列上是否已经有皇后；遍历当前左上至右下对角线上是否已经有皇后；遍历当前右上至左下对角线上是否已经有皇后。这些遍历只需要检测小于当前的行，因为大于当前的行还没有填写到一定没有皇后。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;String&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">//棋盘,默认为0表示空，1表示皇后</span></span><br><span class="line">    <span class="keyword">int</span>[][] board=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="comment">//row当前填写得的行号</span></span><br><span class="line">    dfs(n,<span class="number">0</span>,board);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, <span class="keyword">int</span>[][] board)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//0~n-1都填写完毕</span></span><br><span class="line">    <span class="keyword">if</span> (row==n)&#123;</span><br><span class="line">        res.add(track(board,n));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUsable(board,row,col))&#123;</span><br><span class="line">            board[row][col]=<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//填写下一行</span></span><br><span class="line">            dfs(n,row+<span class="number">1</span>,board);</span><br><span class="line">            board[row][col]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//board[row][col]是否可用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isUsable</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查列上有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查左上至右下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i+row-col&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[i+row-col][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查右上至左下对角线有无皇后</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (row+col-i&lt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (board[row+col-i][i]==<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将int类型棋盘转换成输出格式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">track</span><span class="params">(<span class="keyword">int</span>[][] board, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        StringBuilder temp=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j]==<span class="number">0</span>)temp.append(<span class="string">'.'</span>);</span><br><span class="line">            <span class="keyword">else</span> temp.append(<span class="string">'Q'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(temp.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——不同路径</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="NO-62-不同路径-中等"><a href="#NO-62-不同路径-中等" class="headerlink" title="NO.62 不同路径 中等 "></a>NO.62 不同路径 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/10/8ioaGR.png" alt="8ioaGR.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/10/8ioUi9.png" alt="8ioUi9.png"></p>
<p><strong><font  color=red>思路一：动态规划</font></strong> 只能向下或向右，就是无法后退或者绕路且到达终点的步数是确定的。</p>
<p>dp[][]数组的含义：dp[i][j]就是到到i行j列的位置有多少种走法。</p>
<p>初始化：dp[0][0]~dp[0][n-1]即第一列和dp[0][0]~dp[0][n-1]即第一行因为只有向下或向右移动，所以都只有1走法可以到达。</p>
<p>状态转移：除了第一行、第一列，dp[i][j]=dp[i-1][j]+dp[i][j-1]，还是因为只能向下或向右移动，所以dp[i][j]的一定是从其上面的[i][j-1]或左面的[i-1][j]移动而来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——K个一组翻转链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-25-K个一组翻转链表-困难"><a href="#NO-25-K个一组翻转链表-困难" class="headerlink" title="NO.25 K个一组翻转链表 困难 "></a>NO.25 K个一组翻转链表 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/17/3C5wuV.png" alt="3C5wuV.png"></p>
<p><strong><font color=red>思路一：迭代实现</font></strong> 和<a href="https://blog.csdn.net/qq_42758551/article/details/103796292" target="_blank" rel="noopener">徒手挖地球九周目</a>中NO.24两两交换链表中的节点的迭代法思路一样，不过NO.24题中的k是2而已。</p>
<ol>
<li>哑节点dummy。pre指向待翻转子链表的前驱，end指向待翻转子链表的尾节点。然后，<font color=#3366cc>start</font>指向待翻转子链表的头节点，<font color=#3366cc>next</font>指向待翻转子链表的后继。最后断开待翻转子链表和剩余链表，翻转第一组。<img src="https://s2.ax1x.com/2020/02/17/3PuodI.png" alt="3PuodI.png"></li>
<li>反转完成之后，将<font color=#3366cc>start</font>节点和<font color=#3366cc>next</font>节点连接。移动<font color=#009966>pre</font>指向<font color=#3366cc>start</font>节点，<font color=#009966>end</font>指向<font color=#009966>pre</font>节点，检查<font color=#009966>end.next</font>不为空，所以向后移动<font color=#009966>end</font>到下一组待翻转子链表的尾节点，<font color=#009966>start</font>指向待翻转子链表的头节点，<font color=#009966>next</font>指向待翻转子链表的后继。翻转第二组。<img src="https://s2.ax1x.com/2020/02/17/3PuIeA.png" alt="3PuIeA.png"></li>
<li>第二组翻转完成，将<font color=#009966>start</font>节点和<font color=#009966>next</font>节点连接。移动<font color=#cc9900>pre</font>指向<font color=#009966>start</font>节点，<font color=#cc9900>end</font>指向<font color=#cc9900>pre</font>节点，检查<font color=#cc9900>end.next</font>不为空，所以向后移动<font color=#cc9900>end</font>，但是剩余节点不足k个。所以翻转全部，返回dummy.next。<img src="https://s2.ax1x.com/2020/02/17/3PKv9K.png" alt="3PKv9K.png"></li>
</ol>
<p>这里还有一个问题就是如何翻转子链表reverse(head)？用上述第一组子链表为例：</p>
<p>curr指向当前节点，pre指向curr之前节点，next指向curr之后节点，翻转过程比较简单，直接看图。</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3PGPHg.png" alt="3PGPHg.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/17/3PGSjf.png" alt="3PGSjf.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/17/3PG9u8.png" alt="3PG9u8.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/17/3P8zgP.png" alt="3P8zgP.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">1</span>)<span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">//初始化哑节点、pre、end</span></span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next=head;</span><br><span class="line">    ListNode pre=dummy,end=dummy;</span><br><span class="line">    <span class="keyword">while</span> (end.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//移动end指向待翻转子链表的尾部,如果剩余节点不足k个，则翻转完成返回head</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k&amp;&amp; end!=<span class="keyword">null</span>; i++) end=end.next;</span><br><span class="line">        <span class="keyword">if</span> (end==<span class="keyword">null</span>)<span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//start指向待翻转子链表头节点，next指向未翻转部分的头节点</span></span><br><span class="line">        ListNode start=pre.next,next=end.next;</span><br><span class="line">        end.next=<span class="keyword">null</span>;</span><br><span class="line">        pre.next=reverse(start);</span><br><span class="line">        <span class="comment">//连接完成翻转部分和未翻转部分</span></span><br><span class="line">        start.next=next;</span><br><span class="line">        <span class="comment">//移动pre和end</span></span><br><span class="line">        pre=start;</span><br><span class="line">        end=pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//翻转子链表</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode pre=<span class="keyword">null</span>,curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next=curr.next;</span><br><span class="line">        curr.next=pre;</span><br><span class="line">        pre=curr;</span><br><span class="line">        curr=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nk)   n是节点总数。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——跳跃游戏II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/</url>
    <content><![CDATA[<h2 id="NO-45-跳跃游戏II-困难"><a href="#NO-45-跳跃游戏II-困难" class="headerlink" title="NO.45 跳跃游戏II 困难 "></a>NO.45 跳跃游戏II <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/26/3an8VP.png" alt="3an8VP.png"></p>
<p><strong><font color=red>思路一：贪心算法</font></strong> nums[i]表示的可以跳入的最大范围，如果当前nums[i]所能跳到的范围不涉及重点，那么就在当前能跳到的范围内选择一个最优的点(可以跳出更远的范围的点)，因为如果这个最优点都不能跳到终点，那么其他的点更不能跳到。</p>
<p>这种每一步都选择最优来保证最终结果的最优性的方法就是典型的贪心算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//end当前能跳到的最远点，steps跳的步数，maxposition能跳的最远的距离</span></span><br><span class="line">    <span class="keyword">int</span> end=<span class="number">0</span>,steps=<span class="number">0</span>,maxPosition=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//注意是：i&lt;length-1，如果最后一跳最远距离刚好到达终点会导致额外一次steps++</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//在当前可跳的范围内，寻找能跳的最远位置</span></span><br><span class="line">        maxPosition=Math.max(maxPosition,nums[i]+i);</span><br><span class="line">        <span class="comment">//到达当前跳跃最远点</span></span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            end=maxPosition;</span><br><span class="line">            steps++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> steps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——串联所有单词的子串</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="NO-30-串联所有单词的子串-困难"><a href="#NO-30-串联所有单词的子串-困难" class="headerlink" title="NO.30 串联所有单词的子串 困难 "></a>NO.30 串联所有单词的子串 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/19/3E2X5D.png" alt="3E2X5D.png"></p>
<p>这道题要把每个单词看成整体，每个不同的单词看作是不同的字符，单词串就看成是特殊的字符串。</p>
<p>==注意：s中的单词未必是长度相等。words中可能存在相同的单词。==</p>
<p><strong><font color=red>思路一：暴力法</font></strong> words中的单词长度都一样，大幅降低了这道题的难度，所以这个特点要充分利用。所以遍历s的每个子串，分别检查每个字串中是否符合要求。</p>
<p>用一个hashmap存储words中的每个单词及其在words中出现的次数；每遍历一个子串都要用一个hashmap存储被遍历子串中出现的words中存在的单词及其在子串中出现的次数。</p>
<p>重点是理解这个“要求”：1.words中的每个单词都<strong>必须出现一次</strong>。2.words中的每个单词<strong>必须连续出现</strong>。</p>
<p>反言之：检查每个子串的过程中，出现words中的不存在的单词则结束检查；出现与words中相等的单词，但是出现的次数超过其在words中出现的次数则结束检查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (words==<span class="keyword">null</span>||words.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">//单词个数、单词长度</span></span><br><span class="line">    <span class="keyword">int</span> wordNum = words.length,wordLen=words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="comment">//将words每个单词及其个数存入hashmap</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; allWords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        Integer value = allWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">        allWords.put(word,++value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历s每一个子串,剩余不足wordNum*wordLen个字符的子串不需要遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() - wordNum * wordLen + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//将子串中出现的和words中相等的单词及其出现次数存入hashmap</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; hasWords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录字串中和words中相等单词数量</span></span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计字串中连续和words中相等的单词</span></span><br><span class="line">        <span class="keyword">while</span> (count&lt;wordNum)&#123;</span><br><span class="line">            String word = s.substring(i + count * wordLen, i + (count + <span class="number">1</span>) * wordLen);</span><br><span class="line">            <span class="comment">//如果word匹配words中的单词，就统计其出现次数</span></span><br><span class="line">            <span class="keyword">if</span> (allWords.containsKey(word))&#123;</span><br><span class="line">                Integer value = hasWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">                hasWords.put(word,++value);</span><br><span class="line">                <span class="comment">//如果word出现次数超过words中这个单词的总数量则结束统计</span></span><br><span class="line">                <span class="keyword">if</span> (hasWords.get(word)&gt;allWords.get(word))<span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果字串中出现于words中所有单词都不匹配的word则结束统计</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//增加成功与words中匹配的单词数量</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count==wordNum)res.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*m)    n是s长度，m是words中单词个数。</p>
<p><strong><font color=red>思路二：滑动窗口优化暴力法</font></strong> 用循环内的map(haswords)来保存窗口中匹配的单词，再用一个指针标记窗口当前的起始位置。</p>
<p>暴力方法中有几个需要优化的地方：</p>
<ol>
<li><p>匹配成功：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3My6je.png" alt="3My6je.png"></p>
<p>判断i=0这个子串符合要求，如果继续按照思路一的方法判断。当i=3的时候，依然一次校验每个单词，但是“foofoo”这两个单词已经在i=0子串的时候校验过了。所以暴力法中的hasword这个map并不需要每次都清空，只需要移除“bar“之后，从i=9的单词开始判断就好了。</p>
</li>
<li><p>匹配失败，有不匹配的单词：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3MyycD.png" alt="3MyycD.png"></p>
<p>判断i=0子串时出现了“the”这个不匹配的单词导致匹配失败。i=3、i=6这些子串都包含“the”这个单词，所以都不能匹配成功，所以窗口直接移动到i=9继续校验即可。</p>
</li>
<li><p>匹配失败，单词匹配但是数量超出：</p>
<p><img src="https://s2.ax1x.com/2020/02/22/3Mys1O.png" alt="3Mys1O.png"></p>
<p>i=0字串中“bar”出现两次，但是words中只有一个”bar”所以匹配失败。窗口移动到i=3,移除了“foo”但是“bar”依然多出一个，所以一定不匹配。窗口移动到i=6的时候移除了“bar”，就可以按照正常流程继续判断了。</p>
</li>
</ol>
<p>不难发现，上述几种情况的描述时，不再是每次移动一个字符，而是每次移动单词长度。但是s中的单词不一定都是刚好符合wordLen，如何解决这种情况？</p>
<p>答：分成wordLen种情况，分别进行判断。分别从i=0开始每次移动一个单词长度、从i=1开始每次移动一个单词长度、从i=2开始每次移动一个单词长度、、、直至从i=wordLen-1开始每次移动一个单词长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findSubstring</span><span class="params">(String s, String[] words)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>||words==<span class="keyword">null</span>||words.length==<span class="number">0</span>)<span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">int</span> wordsNum = words.length,wordLen=words[<span class="number">0</span>].length();</span><br><span class="line">    <span class="comment">//将words中的单词及其数量存入hashmap</span></span><br><span class="line">    HashMap&lt;String,Integer&gt; allWords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">        Integer value = allWords.getOrDefault(word, <span class="number">0</span>);</span><br><span class="line">        allWords.put(word,value+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//分成wordLen中情况，分别从0开始每次移动一个单词长度~从wordLen-1开始每次移动一个单词长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;wordLen;j++)&#123;</span><br><span class="line">        <span class="comment">//haswords存放当前子串中匹配的单词及其个数，count当前子串匹配的单词数量</span></span><br><span class="line">        HashMap&lt;String,Integer&gt; haswords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历从j开始的每个子串，每次动一个单词长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=j;i&lt;s.length()-wordLen*wordsNum+<span class="number">1</span>;i+=wordLen)&#123;</span><br><span class="line">            <span class="comment">//防止情况三出现之后，情况一继续移除</span></span><br><span class="line">            <span class="keyword">boolean</span> hasRemoved=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span> (count&lt;wordsNum)&#123;</span><br><span class="line">                String curWord = s.substring(i + count * wordLen, i + (count + <span class="number">1</span>) * wordLen);</span><br><span class="line">                <span class="comment">//当前单词匹配，加入haswords</span></span><br><span class="line">                <span class="keyword">if</span> (allWords.containsKey(curWord)) &#123;</span><br><span class="line">                    Integer value = haswords.getOrDefault(curWord, <span class="number">0</span>);</span><br><span class="line">                    haswords.put(curWord,value+<span class="number">1</span>);</span><br><span class="line">                    count++;</span><br><span class="line">                    <span class="comment">//情况三，当前单词匹配，但是数量超了</span></span><br><span class="line">                    <span class="keyword">if</span> (haswords.get(curWord) &gt; allWords.get(curWord)) &#123;</span><br><span class="line">                        hasRemoved=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//从i开始逐个单词，从haswords中移除，removeNum记录移除的单词个数</span></span><br><span class="line">                        <span class="keyword">int</span> removeNum=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">while</span> (haswords.get(curWord) &gt; allWords.get(curWord)) &#123;</span><br><span class="line">                            String fristWord = s.substring(i + removeNum * wordLen, i + (removeNum + <span class="number">1</span>) * wordLen);</span><br><span class="line">                            Integer v = haswords.get(fristWord);</span><br><span class="line">                            haswords.put(fristWord,v-<span class="number">1</span>);</span><br><span class="line">                            removeNum++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//移除完毕之后，更新count</span></span><br><span class="line">                        count-=removeNum;</span><br><span class="line">                        <span class="comment">//移动i的位置(注意removeNum要-1，因为跳出当前循环之后，i还要+wordLen)</span></span><br><span class="line">                        i+=(removeNum-<span class="number">1</span>)*wordLen;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//情况二，当前单词不匹配</span></span><br><span class="line">                    <span class="comment">//清空haswords</span></span><br><span class="line">                    haswords.clear();</span><br><span class="line">                    <span class="comment">//i移动到当前单词位置(因为跳出当前循环之后，i还要+wordLen)</span></span><br><span class="line">                    i+=count*wordLen;</span><br><span class="line">                    count=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况一，匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (count==wordsNum)result.add(i);</span><br><span class="line">            <span class="comment">//如果情况三没有出现</span></span><br><span class="line">            <span class="keyword">if</span> (count&gt;<span class="number">0</span>&amp;&amp;!hasRemoved)&#123;</span><br><span class="line">                <span class="comment">//移除成功匹配子串的第一个元素</span></span><br><span class="line">                String fristWord = s.substring(i, i + wordLen);</span><br><span class="line">                Integer v = haswords.get(fristWord);</span><br><span class="line">                haswords.put(fristWord,v-<span class="number">1</span>);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*wordLen)    这个时间复杂度不敢确定算的对。。。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——不同路径II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II/</url>
    <content><![CDATA[<h2 id="NO-63-不同路径II-中等"><a href="#NO-63-不同路径II-中等" class="headerlink" title="NO.63 不同路径II 中等 "></a>NO.63 不同路径II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/10/8iodR1.png" alt="8iodR1.png"></p>
<p><strong><font  color=red>思路一：动态规划</font></strong> 这道题和上一题作为姊妹题，没什么太大变化，只是多了障碍物这个因素。</p>
<p>dp[][]数组的含义：和上一题一样。</p>
<p>初始化：dp[0][0]~dp[0][n-1]即第一列和dp[0][0]~dp[0][n-1]即第一行因为只有向下或向右移动，所以在第一个障碍物之前的位置都是1，障碍物即障碍物之后的位置都是无法到达所以是0。</p>
<p>状态转移：如果[i][j]是障碍物则无法到达所以是0，否则依然是dp[i][j]=dp[i-1][j]+dp[i][j-1]，还是因为只能向下或向右移动，所以dp[i][j]的一定是从其上面的[i][j-1]或左面的[i-1][j]移动而来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = obstacleGrid.length,n=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>]==<span class="number">0</span>)dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j]==<span class="number">0</span>)dp[<span class="number">0</span>][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][j]==<span class="number">1</span>)dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——二叉树的直径</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</url>
    <content><![CDATA[<h2 id="NO-543-二叉树的直径-简单"><a href="#NO-543-二叉树的直径-简单" class="headerlink" title="NO.543 二叉树的直径  简单 "></a>NO.543 二叉树的直径  <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/10/8iIWuT.png" alt="8iIWuT.png"></p>
<p><strong><font color=red>思路一：深度优先遍历</font></strong> 这道题比较明显，立刻就能想到深度搜索，关键是怎么找到最长的。</p>
<p>一开始就陷入了一个误区，我觉着最大直径一定有根节点，所以根节点左子树找到最深的路径leftMax、右子树找到最深路径rightMax，最后总的最深路径就是leftMax+rightMax。很朴实的想法，但是明显是错误的。如果树是空的就错了，即使树不空但是根节点的左子树或者右子树为空也可能会出错，形如下图。</p>
<p><img src="https://s2.ax1x.com/2020/03/10/8izEL9.png" alt="8izEL9.png"></p>
<p>最初的这个想法浪费了不少时间，但是通过学习别人的思路发现最初的错误方法有一小部分是正确的。</p>
<p>虽然最大直径不一定经过根节点，但是一定经过某个节点(废话)，这个某节点的左子树最深路径和右子树最深路径之和就是最大直径。</p>
<p>我们要找的是路径和而不是节点和，这一点要牢记。</p>
<p>根据这个左右子树最大深度之和的方式，深度优先遍历将所有节点的最大直径都算出来，取最大即可。递归深搜到每个叶子节点，触底返回节点左右最深的路径+1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> ans;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为空，没有路径</span></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//深搜</span></span><br><span class="line">    <span class="keyword">int</span> leftMax=dfs(root.left);</span><br><span class="line">    <span class="keyword">int</span> rightMax=dfs(root.right);</span><br><span class="line">    <span class="comment">//每个子树根的最大直径</span></span><br><span class="line">    ans=Math.max(ans,leftMax+rightMax);</span><br><span class="line">    <span class="comment">//+1因为子树的根到父节点之间有一条边</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(leftMax,rightMax)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——二进制求和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-67-二进制求和-简单"><a href="#NO-67-二进制求和-简单" class="headerlink" title="NO.67 二进制求和 简单 "></a>NO.67 二进制求和 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/16/8G8PqU.png" alt="8G8PqU.png"></p>
<p><strong><font color=red>思路一：逐位相加进位</font></strong> 这种题其实已经遇到很多了，之前的字符串相加、字符串相乘是一样的。只不过本题换成了二进制而已。</p>
<p>不需要考虑符号位，依然是逆序遍历从低位到高位逐位相加，记录进位情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>,len=Math.max(a.length(),b.length());</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=a.length()-i-<span class="number">1</span>&gt;=<span class="number">0</span>?a.charAt(a.length()-<span class="number">1</span>-i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> y=b.length()-i-<span class="number">1</span>&gt;=<span class="number">0</span>?b.charAt(b.length()-<span class="number">1</span>-i)-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line">        carry=sum/<span class="number">2</span>;</span><br><span class="line">        sb.append(sum%<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)sb.append(carry);</span><br><span class="line">    <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——岛屿的最大面积</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/</url>
    <content><![CDATA[<h2 id="NO-695-岛屿的最大面积-中等"><a href="#NO-695-岛屿的最大面积-中等" class="headerlink" title="NO.695 岛屿的最大面积 中等 "></a>NO.695 岛屿的最大面积 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/15/81gBKe.png" alt="81gBKe.png"></p>
<p><strong><font color=red>思路一：广度优先遍历</font></strong> 这道题给我的第一感觉和腐烂的橘子那道题很像，都是多源向外”辐射”寻找。</p>
<p>用一个和grid大小一样的boolean型数组used标识每个位置是否用过，max统计最大岛屿面积。</p>
<p>遍历矩阵，如果当前位置是陆地(1)并且没有被使用过，就从当前位置进行广搜最后更新最大岛屿面积；否则继续遍历。</p>
<p>简陋的BFS模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(队列不空)&#123;</span><br><span class="line">	node=队列.poll();</span><br><span class="line">	<span class="keyword">for</span>(node的邻接节点)&#123;</span><br><span class="line">		<span class="keyword">if</span>(邻接节点m未曾入队)&#123;</span><br><span class="line">			队列.add(m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显这是个模板题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span>[][] used;</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.m=grid.length;</span><br><span class="line">    <span class="keyword">this</span>.n=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">this</span>.used=<span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">    <span class="comment">//遍历每个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//如果是陆地且没用过</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>&amp;&amp;!used[i][j])&#123;</span><br><span class="line">                <span class="comment">//广搜更新最大岛屿面积</span></span><br><span class="line">                max=Math.max(max,bfs(grid,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//广搜</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//广搜队列</span></span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);<span class="comment">//当前陆地入队</span></span><br><span class="line">    used[i][j]=<span class="keyword">true</span>;<span class="comment">//更新标记数组</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;<span class="comment">//开始就是一块陆地</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] curr = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> r=curr[<span class="number">0</span>],c=curr[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//判断当前出队陆地的上下左右是否是陆地且没使用过</span></span><br><span class="line">        <span class="keyword">if</span> (r-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r-<span class="number">1</span>][c]==<span class="number">1</span>&amp;&amp;!used[r-<span class="number">1</span>][c])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r-<span class="number">1</span>,c&#125;);</span><br><span class="line">            used[r-<span class="number">1</span>][c]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r][c-<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;!used[r][c-<span class="number">1</span>])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c-<span class="number">1</span>&#125;);</span><br><span class="line">            used[r][c-<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r+<span class="number">1</span>&lt;m&amp;&amp;grid[r+<span class="number">1</span>][c]==<span class="number">1</span>&amp;&amp;!used[r+<span class="number">1</span>][c])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>,c&#125;);</span><br><span class="line">            used[r+<span class="number">1</span>][c]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c+<span class="number">1</span>&lt;n&amp;&amp;grid[r][c+<span class="number">1</span>]==<span class="number">1</span>&amp;&amp;!used[r][c+<span class="number">1</span>])&#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c+<span class="number">1</span>&#125;);</span><br><span class="line">            used[r][c+<span class="number">1</span>]=<span class="keyword">true</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<p><strong>使用的这个used数组可以省略，每个使用过的陆地(1)直接置为0就可以了，我看很多人很形象地把这个叫做”沉岛思想”。用这种方式可以自行改进上一题，减少空间使用。</strong></p>
<p><strong><font color=red>思路二：深度优先遍历</font></strong> 虽然改用深度优先遍历，实际上和上文思路一样，应该叫做实现二。</p>
<p>依然是遍历判断是否为1，如果是则采用深搜统计并更新max。</p>
<p>尝试抛弃used数组，改为”沉岛思想”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">//是陆地</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//深搜并更新max</span></span><br><span class="line">                max=Math.max(max,dfs(grid,i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深搜</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//越界都是海水</span></span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span>||i==grid.length||j&lt;<span class="number">0</span>||j==grid[i].length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">        grid[i][j]=<span class="number">0</span>;<span class="comment">//沉岛</span></span><br><span class="line">        <span class="comment">//上下左右四个方向深搜，别忘了开始的一块陆地</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(grid,i+<span class="number">1</span>,j)+dfs(grid,i-<span class="number">1</span>,j)+dfs(grid,i,j+<span class="number">1</span>)+dfs(grid,i,j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——多数元素</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="NO-169-多数元素-简单"><a href="#NO-169-多数元素-简单" class="headerlink" title="NO.169 多数元素 简单 "></a>NO.169 多数元素 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/13/8n497q.png" alt="8n497q.png"></p>
<p><strong><font color=red>思路一：排序法</font></strong> 因为题目中说总是存在多数元素，这个多数元素的个数大于半数，所以无论是升序还是降序排序之后中间元素一定是多数元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">return</span> nums[nums.length/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)</p>
<p><strong><font color=red>思路二：哈希表</font></strong> 遍历一遍统计不同数字出现次数，然后遍历哈希表找出多数元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计数字出现次数</span></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        Integer value = map.getOrDefault(num, <span class="number">0</span>);</span><br><span class="line">        map.put(num,value+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历map，打擂台找到多数元素</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,maxNum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; en : map.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (en.getValue()&gt;maxNum)&#123;</span><br><span class="line">            ans=en.getKey();</span><br><span class="line">            maxNum=en.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路三：摩尔投票法</font></strong> 基于题目中说的多数元素一定存在。</p>
<p>简单说就是先定一个候选人和计数器count，然后遍历过程中遇到和候选人相同的就count+1，不同则count-1，当count==0，就更换当前元素为新的候选人并将count置为1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> candidate=nums[<span class="number">0</span>],count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num==candidate)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)&#123;</span><br><span class="line">            candidate=num;</span><br><span class="line">            count=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
        <tag>摩尔投票算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——插入区间</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="NO-57-插入区间-困难"><a href="#NO-57-插入区间-困难" class="headerlink" title="NO.57 插入区间 困难 "></a>NO.57 插入区间 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/07/3XsAzD.png" alt="3XsAzD.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 先将intervals和新区间都输入到一个数组中，然后对数组中的区间进行合并得到结果。</p>
<p><a href="https://blog.csdn.net/qq_42758551/article/details/104662112" target="_blank" rel="noopener">徒手挖地球二五周目</a>题解中NO.56合并区间中详细描述了如何进行区间合并。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">    <span class="keyword">int</span>[][] input=<span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//将newInterval和Intervals都输入一个数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        input[i][<span class="number">0</span>]=intervals[i][<span class="number">0</span>];</span><br><span class="line">        input[i][<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    input[n][<span class="number">0</span>]=newInterval[<span class="number">0</span>];</span><br><span class="line">    input[n][<span class="number">1</span>]=newInterval[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//合并区间</span></span><br><span class="line">    <span class="keyword">return</span> merger(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] merger(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(intervals,(o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=intervals[i][<span class="number">0</span>],right=intervals[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;intervals.length-<span class="number">1</span>&amp;&amp;right&gt;=intervals[i+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            right=Math.max(right,intervals[i+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(nlogn)    将新旧区间输入一个数组中需要遍历一次，合并区间操作需要排序是nlogn复杂度，然后合并本身需要遍历数组一次。</p>
<p><strong><font color=red>思路二：贪心算法</font></strong> 将当前的一小步进行最优处理，从而使整体最优。思路二是针对思路一进行优化。</p>
<p>本题中已经告知旧区间是有序的，所以思路一中的排序只是为了让新区间放置在末尾之后移动到有序的位置上，从而付出了nlogn的代价。</p>
<ol>
<li><p>针对这一点很容易想到，在第一次遍历旧区间合集的时候顺便进行和新区间的比较，就能直接将新区间插入到有序的位置上。如何进行比较？</p>
<p>==新区间应该放置到最后一个右边界小于新区间左边界的旧区间后面==，这样新区间放入位置之前的所有旧区间都不会和新区间重叠且不需要和新区间进行合并。</p>
</li>
<li><p>找到新区间的插入位置后先不要急于将新区间放入，因为此时新区间可能需要和放入位置及其后序连续的旧区间进行合并。什么样的旧区间会和新区间进行合并？</p>
<p>==新区间右边界&gt;=旧区间左边界==则说明新旧区间需要进行合并，例如[4,5]和[2,6]、[4,8]和[8,9]等等。。。</p>
</li>
<li><p>两个区间合并的结果是[min(新区间左,旧区间左)，max(新区间右,旧区间右)]。将合并后的新区间加入结果集。最后将剩余的旧区间加入结果集。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] insert(<span class="keyword">int</span>[][] intervals, <span class="keyword">int</span>[] newInterval) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>,n=intervals.length;</span><br><span class="line">    <span class="comment">//找到新区间的放置位置，最后一个右边界小于新区间左边界的旧区间的后面</span></span><br><span class="line">    <span class="keyword">while</span> (index&lt;n&amp;&amp;newInterval[<span class="number">0</span>]&gt;intervals[index][<span class="number">1</span>])&#123;</span><br><span class="line">        res.add(intervals[index++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//temp记录合并后新区间的左右边界值</span></span><br><span class="line">    <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newInterval[<span class="number">0</span>],newInterval[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">while</span> (index&lt;n&amp;&amp;newInterval[<span class="number">1</span>]&gt;=intervals[index][<span class="number">0</span>])&#123;</span><br><span class="line">        temp[<span class="number">0</span>]=Math.min(temp[<span class="number">0</span>],intervals[index][<span class="number">0</span>]);</span><br><span class="line">        temp[<span class="number">1</span>]=Math.max(temp[<span class="number">1</span>],intervals[index][<span class="number">1</span>]);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将合并后的新区间放入结果集</span></span><br><span class="line">    res.add(temp);</span><br><span class="line">    <span class="comment">//将剩余区间放入结果集</span></span><br><span class="line">    <span class="keyword">while</span> (index&lt;n)&#123;</span><br><span class="line">        res.add(intervals[index++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——电话号码的字母组合</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h2 id="NO-17-电话号码的字母组合-中等"><a href="#NO-17-电话号码的字母组合-中等" class="headerlink" title="NO.17 电话号码的字母组合 中等 "></a>NO.17 电话号码的字母组合 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/19/QLBNwV.png" alt="QLBNwV.png"></p>
<p><font color=red><strong>思路一：回溯法</strong></font> 如果这道题加一个条件：“每次输入3位字符的字符串”。那么这道题就非常简单了，直接三层for循环就解决了。这道题棘手的地方就是如何确定循环的层数，这时候递归就派上用场了（模仿大佬的语气）！</p>
<p>例如输入”2345”这样的字符串：第一次递归处理2，然后处理完第一个字符2之后，将输入的字符改变成”345”并调用第二个递归函数；第二次递归处理3，将字符串改变成”45”后再次递归；第三次递归处理4，将字符串改变成 “5”后继续递归；第四次递归处理5，将字符串改变成””后继续递归；最后发现字符串为空了，将结果放到列表中并返回。</p>
<p>上面是从函数调用的角度去看的，而每次调用下一层递归时，都需要将本层的一些处理结果放到一个临时变量中，再传递给下一层，从这个变量层层传递的变化看，就像一棵树一样，这个算法的时间复杂度很高，是O(3^n)这个级别的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//    用数组或hashmap存储数字及其对应的字符表</span></span><br><span class="line">    String[] letters=&#123;<span class="string">""</span>,<span class="string">""</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line"><span class="comment">//    结果集</span></span><br><span class="line">    List&lt;String&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        边界处理</span></span><br><span class="line">        <span class="keyword">if</span> (digits.length()==<span class="number">0</span>||digits==<span class="keyword">null</span>)<span class="keyword">return</span> result;</span><br><span class="line">        backTrack(digits,<span class="string">""</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    递归函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(String str,String combination,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"><span class="comment">//        递归终止条件，当index==str.length()时说明str==""</span></span><br><span class="line">        <span class="keyword">if</span> (index==str.length())&#123;</span><br><span class="line">            result.add(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        获取当前index位置的字符，此处和前文的思路中有所不同：没有采用每次将字符串切割的方法</span></span><br><span class="line"><span class="comment">//        subString()每次都会生成新的字符串，而用index方式取当前第一个字符，效率更高一点</span></span><br><span class="line">        <span class="keyword">char</span> c= str.charAt(index);</span><br><span class="line">        String letter=letters[c-<span class="string">'0'</span>];</span><br><span class="line"><span class="comment">//        遍历letter字符串，例如第一次得到的是‘2’，即遍历“abc”</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;letter.length();i++)&#123;</span><br><span class="line"><span class="comment">//            这里是比较值得思考的地方，递归调用</span></span><br><span class="line">            backTrack(str,combination+letter.charAt(i),index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(3^n)</p>
<p><font color=red><strong>思路二：队列法</strong></font> 利用队列先进先出的特点来处理该问题。</p>
<p>直接用一个例子来说明思路：假设输入的还是”23”,先将”2”对应的字符依次放入队列，队列res变为{“a”,”b”,”c”}；将此时队列中的每个字符串依次取出的同时分别和下一个输入数字所对应的字符拼接后重新放入队列，将”a”取出和第二个输入数字”3”对应的字符”def”依次拼接后重新放入队列，队列res变为{“b”,”c”,”ad”,”ae”,”af”}，将”b”取出和第二个输入数字”3”对应的字符”def”依次拼接后重新放入队列，队列res变为{“c”,”ad”,”ae”,”af”,”bd”,”be”,”bf”}，将”c”取出和第二个输入数字”3”对应的字符”def”依次拼接后重新放入队列，队列res变为{“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”}；所有输入数字遍历结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//        边界处理</span></span><br><span class="line">        <span class="keyword">if</span> (digits==<span class="keyword">null</span>||digits.length()==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line"><span class="comment">//        用数组或hashmap存储数字及其对应的字符表</span></span><br><span class="line">        String[] letters=&#123;<span class="string">""</span>,<span class="string">"#"</span>,<span class="string">"abc"</span>,<span class="string">"def"</span>,<span class="string">"ghi"</span>,<span class="string">"jkl"</span>,<span class="string">"mno"</span>,<span class="string">"pqrs"</span>,<span class="string">"tuv"</span>,<span class="string">"wxyz"</span>&#125;;</span><br><span class="line"><span class="comment">//        先往队列中加入一个空字符，防止第一次循环从队列中取出第一个元素时出现下标越界异常</span></span><br><span class="line">        res.add(<span class="string">""</span>);</span><br><span class="line"><span class="comment">//        遍历输入的字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;digits.length();i++)&#123;</span><br><span class="line"><span class="comment">//            取出当前遍历数字对应的字符串</span></span><br><span class="line">            String letter=letters[digits.charAt(i)-<span class="string">'0'</span>];</span><br><span class="line"><span class="comment">//            获取当前队列的长度，不能在for循环中直接j&lt;res.size()，因为内层循环中队列在不断增长，导致死循环</span></span><br><span class="line">            <span class="keyword">int</span> size = res.size();</span><br><span class="line"><span class="comment">//            遍历队列中每个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;size;j++)&#123;</span><br><span class="line"><span class="comment">//                从队列中取出第一个元素</span></span><br><span class="line">                String temp = res.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//                遍历当前数字对应的字符串的每个字符，依次和取出的第一个元素拼接后重新放入队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;letter.length();k++)&#123;</span><br><span class="line">                    res.add(temp+letter.charAt(k));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(3^n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——翻转链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-206-翻转链表-简单"><a href="#NO-206-翻转链表-简单" class="headerlink" title="NO.206 翻转链表 简单 "></a>NO.206 翻转链表 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/02/3R4HGn.png" alt="3R4HGn.png"></p>
<p>本题是K个一组翻转链表这道题的其中一步，学习完本题可以趁热打铁学习NO.25，题解参考<a href="https://blog.csdn.net/qq_42758551/article/details/104362023" target="_blank" rel="noopener">徒手挖地球十八周目</a>。</p>
<p><strong><font color=red>思路一：迭代实现</font></strong> 翻转链表需要三个”指针”：pre指向前驱、curr指向当前节点、next指向后继。</p>
<p>过程比较简单，自己模拟一遍就好了：</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3R4b2q.png" alt="3R4b2q.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/02/3R47Ps.png" alt="3R47Ps.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre=<span class="keyword">null</span>,curr=head;</span><br><span class="line">    <span class="keyword">while</span> (curr!= <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next=curr.next;</span><br><span class="line">        curr.next=pre;</span><br><span class="line">        pre=curr;</span><br><span class="line">        curr=next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：递归实现</font></strong> 每层递归返回已经翻转好的部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">    ListNode pre=reverseList(head.next);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——腐烂的橘子</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/</url>
    <content><![CDATA[<h2 id="NO-994-腐烂的橘子-简单"><a href="#NO-994-腐烂的橘子-简单" class="headerlink" title="NO.994 腐烂的橘子 简单 "></a>NO.994 腐烂的橘子 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/04/3Io9V1.png" alt="3Io9V1.png"></p>
<p><img src="https://s2.ax1x.com/2020/03/04/3IIzr9.png" alt="3IIzr9.png"></p>
<p><strong><font color=red>思路一：广度优先遍历</font></strong> 这道题可以解读为：腐烂橘子到达最远好橘子的最短路径。</p>
<p>写一个很简陋的BFS的框架：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(队列不空)&#123;</span><br><span class="line">	node&#x3D;队列.poll();</span><br><span class="line">	for(node的邻接节点)&#123;</span><br><span class="line">		if(邻接节点m未曾入队)&#123;</span><br><span class="line">			队列.add(m);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道了BFS，这道题就比较简单了。</p>
<ol>
<li>先遍历一遍，统计初始新鲜橘子的数量并将初始腐烂橘子入队。</li>
<li>然后BFS，同时round记录进行了多少轮次的”传染”。每轮开始都要记录当前轮次开始有多少个坏橘子n。</li>
<li>将本轮开始时的所有坏橘子都出队，并对出队节点的四个邻接节点进行判断和”传染”。</li>
<li>最后检查好橘子还有没有。</li>
</ol>
<p>只有坏橘子才会入队，所以没有框架里邻接节点m未曾入队的检查，因为入过队的都变成坏橘子了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.length,col=grid[<span class="number">0</span>].length;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>[]&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历，统计新鲜橘子，坏橘子坐标入队</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j]==<span class="number">1</span>)count++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j]==<span class="number">2</span>)queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//round传染的轮次</span></span><br><span class="line">    <span class="keyword">int</span> round=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当队列不空并且还存在好橘子就广搜BFS</span></span><br><span class="line">    <span class="keyword">while</span> (count&gt;<span class="number">0</span>&amp;&amp;!queue.isEmpty())&#123;</span><br><span class="line">        round++;</span><br><span class="line">        <span class="comment">//n记录当前坏橘子数量，防止出队入队导致不同轮次之间混乱</span></span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] rc = queue.poll();</span><br><span class="line">            <span class="keyword">int</span> r=rc[<span class="number">0</span>],c=rc[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//每个出队的坏橘子的四个正方向上邻接节点是否是好橘子，如果是就传染腐烂并入队</span></span><br><span class="line">            <span class="keyword">if</span> (r-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r-<span class="number">1</span>][c]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r-<span class="number">1</span>][c]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r-<span class="number">1</span>,c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (r+<span class="number">1</span>&lt;row&amp;&amp;grid[r+<span class="number">1</span>][c]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r+<span class="number">1</span>][c]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r+<span class="number">1</span>,c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c-<span class="number">1</span>&gt;=<span class="number">0</span>&amp;&amp;grid[r][c-<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r][c-<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c-<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (c+<span class="number">1</span>&lt;col&amp;&amp;grid[r][c+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                grid[r][c+<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">                count--;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;r,c+<span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count&gt;<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> round;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    n数组元素个数，整个过程遍历数组两次。</p>
<p>代码很冗长，但是思路还算清楚。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a>   </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两数之和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-1-两数之和-简单"><a href="#NO-1-两数之和-简单" class="headerlink" title="NO.1 两数之和    简单 "></a>NO.1 两数之和    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMw3c9.png" alt="QMw3c9.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font>    看到题，最先想到的思路就是<strong>暴力解法</strong>，直接两层for循环遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]+nums[j]==target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"no result!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><font color=red><strong>思路二：哈希表法</strong></font>    通过一个哈希表来空间换时间：1.遍历nums数组，判断每个元素和目标值的差temp是否在哈希表中。2.如果在就返回当前遍历元素的下标和哈希表中temp这个key对应的value。3.如果不在就将当前遍历元素作为key、当前遍历元素下标作为value存入哈希表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map =<span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=target-nums[i];</span><br><span class="line"><span class="comment">//          所需要的temp是否在map中，如果在就返回map中temp值对应的value(即temp值对应的下标)和i。</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(temp))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(temp),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//          temp如果不在map中，就将nums[i]作为key、下标i作为value放入map中</span></span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"no twoSum result!"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两两交换链表中的节点</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="NO-24-两两交换链表中的节点-中等"><a href="#NO-24-两两交换链表中的节点-中等" class="headerlink" title="NO.24 两两交换链表中的节点 中等 "></a>NO.24 两两交换链表中的节点 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZCWlR.png" alt="lZCWlR.png"></p>
<p><font color=red><strong>思路一：迭代实现</strong></font> 用一个pre指针指向未被交换节点的前驱，交换pre后继和pre后继的后继，直到pre没有后继或者pre的后继没有后继。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode pre=dummy;</span><br><span class="line">        <span class="keyword">while</span> (pre.next!=<span class="keyword">null</span>&amp;&amp;pre.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode start=pre.next,end=pre.next.next;</span><br><span class="line"><span class="comment">//            交换两个节点，注意交换顺序，否则容易死循环</span></span><br><span class="line">            pre.next=end;</span><br><span class="line">            start.next=end.next;</span><br><span class="line">            end.next=start;</span><br><span class="line"><span class="comment">//            移动pre指针，此时已经交换过两个节点的位置</span></span><br><span class="line">            pre=start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><font color=red><strong>思路二：递归实现</strong></font> 没有节点或者只有一个节点不需要进行交换，停止递归，此时返回head节点本身。每层递归返回值是交换过之后的链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>||head.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode next=head.next;</span><br><span class="line">    head.next=swapPairs(next.next);</span><br><span class="line">    next.next=head;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两数相除</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/</url>
    <content><![CDATA[<h2 id="NO-29-两数相除-中等"><a href="#NO-29-两数相除-中等" class="headerlink" title="NO.29 两数相除 中等 "></a>NO.29 两数相除 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/30/llAbkQ.png" alt="llAbkQ.png"></p>
<p>看了很多人的题解，学习到了很多。但是有些题解我不敢苟同，例如用long存储变量的题解，题目明确说明：我们环境只能存储32位有符号整数；需要用乘法改变正负号的题解，第一句就说了不能用乘法。。等等</p>
<p><font color=red><strong>思路一：二分法除数翻倍</strong></font> 被除数中有N个除数，那么商就是N(用减法来实现除法，新被除数=被除数-除数&amp;商+=1)。如果每次被除数只减一个除数，虽然可以实现除法，但是效率太低，在leetcode上也会TLE。所以采用每次除数翻倍(商也不再是每次+1)的方法。</p>
<p>这道题的思路并不难，但是本题有很多细节需要注意和学习：</p>
<ol>
<li><p>商的范围需要注意，小心溢出。这里可以采用先将除数和被除数转换成负数并且用负数商来进行运算，运算结束再根据除数和被除数原本的符号决定商的符号(负号直接返回，正号需要判断符号转变后是否溢出)。</p>
</li>
<li><p>如何得到商的符号：判断除数和被除数异或之后的符号即可。</p>
</li>
<li><p>如何获得相反数：反码+1=补码。分享一篇文章，对这里有疑惑的同学可以看看——<a href="https://jerrymouse1998.github.io/post/%E8%BD%AC%E8%A1%A5%E7%A0%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8C%89%E4%BD%8D%E5%8F%96%E5%8F%8D%E5%86%8D%E5%8A%A0%E4%B8%80/">补码(为什么按位取反再加一)</a></p>
<p>举个栗子，17/3，除数和被除数都转换为负数(反码+1=补码)，即-17/-3，先用-17-(-3)=-14，商+=-1；</p>
<p>除数翻倍-14-(-6)=-8，商+=-2；</p>
<p>除数翻倍，此时的除数-12&lt;被除数-8，所以除数重置为-3；</p>
<p>继续-8-(-3)=-5，商+=-1；</p>
<p>除数翻倍，此时的除数-6&lt;被除数-5，所以除数重置为-3；</p>
<p>继续-5-(-3)=-2，商+=-1；</p>
<p>除数翻倍，此时的除数-6&lt;被除数-2，所以除数重置为-3；</p>
<p>但是初始的除数-3&lt;被除数-2，所以计算结束。</p>
<p>最后根据除数和被除数原本的符号决定商的符号，结果应该是”正正得正”，判断此时的负数商符号转变后是否溢出，负数商不等于32位有符号整形最小值-2147483648，所以可以直接转换为正数，返回负数商的相反数。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (divisor==<span class="number">0</span>)<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//将除数和被除数异或之后，得到商的符号</span></span><br><span class="line">    <span class="keyword">boolean</span> isPositive=(dividend^divisor)&gt;=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//将除数和被除数都转化为负数</span></span><br><span class="line">    <span class="keyword">if</span> (dividend&gt;<span class="number">0</span>)dividend=opposite(dividend);</span><br><span class="line">    <span class="keyword">if</span> (divisor&gt;<span class="number">0</span>)divisor=opposite(divisor);</span><br><span class="line">    <span class="comment">// 商用负数来表示，这样可以处理Integer.MIN_VALUE的情况</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (dividend&lt;=divisor)&#123;</span><br><span class="line">        <span class="keyword">int</span> tempDivisor=divisor;</span><br><span class="line">        <span class="keyword">int</span> count=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里注意需要对tempDivisor是否为负数做判断，因为tempDivisor有可能会溢出</span></span><br><span class="line">        <span class="keyword">while</span> (tempDivisor&lt;<span class="number">0</span>&amp;&amp;dividend&lt;=tempDivisor)&#123;</span><br><span class="line">            <span class="comment">//被除数-除数</span></span><br><span class="line">            dividend-=tempDivisor;</span><br><span class="line">            ans+=count;</span><br><span class="line">            <span class="comment">//除数翻倍</span></span><br><span class="line">            tempDivisor+=tempDivisor;</span><br><span class="line">            count+=count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对返回值进行处理，这里也可以使用三目运算符完成</span></span><br><span class="line">    <span class="keyword">if</span> (isPositive)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans==Integer.MIN_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> opposite(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//x的反码+1，得到x的相反数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">opposite</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ~x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(logN)，除数是 1，每次减一个除数，我们将减 n 次，但因为每次除数都翻倍了，所以共减了log(n)次。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——加一</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h2 id="NO-66-加一-简单"><a href="#NO-66-加一-简单" class="headerlink" title="NO.66 加一 简单 "></a>NO.66 加一 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/15/83UxmV.png" alt="83UxmV.png"></p>
<p>这个题的题干给的很迷，不知道是不是翻译的问题。。。</p>
<p><strong><font color=red>思路一：遍历</font></strong> 很容易想到，+1的结果最大就是10，如果是10就进位当前位置剩余0。</p>
<p>只需要注意”9”、”99”、”999”。。。的全9情况就好了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//当前位是否是9，不是9+1返回即可</span></span><br><span class="line">        <span class="keyword">if</span> (digits[i]!=<span class="number">9</span>)&#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前位是9，+1进位剩余0</span></span><br><span class="line">        digits[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明全是9，新建长度+1数组，最高位是1其余都是0即可</span></span><br><span class="line">    <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">    ans[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——有效括号</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-23-合并K个排序链表-困难"><a href="#NO-23-合并K个排序链表-困难" class="headerlink" title="NO.23 合并K个排序链表 困难 "></a>NO.23 合并K个排序链表 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/17/3C5sN4.png" alt="3C5sN4.png"></p>
<p><strong><font color=red>思路一：逐一两两合并</font></strong> 将<a href="https://blog.csdn.net/qq_42758551/article/details/103733958" target="_blank" rel="noopener">NO.21合并两个有序链表</a>中的方法进行k-1次即可。</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3C5BHU.png" alt="3C5BHU.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lists==<span class="keyword">null</span>||lists.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (lists.length&lt;<span class="number">2</span>)<span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    dummy.next=lists[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;lists.length;i++)&#123;</span><br><span class="line">        ListNode head=dummy,p=dummy.next,q=lists[i];</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>&amp;&amp;p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q.val&lt; p.val)&#123;</span><br><span class="line">                head.next=q;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head.next=p;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">            head=head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q!=<span class="keyword">null</span>)head.next=q;</span><br><span class="line">        <span class="keyword">if</span> (p!=<span class="keyword">null</span>)head.next=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(Nk)   N是节点总数，k是链表数</p>
<p><strong><font color=red>思路二：分治法优化两两合并</font></strong> 每次对折合并，0号链表和length-1号链表合并保存到0、1号链表和length-2号链表合并保存到1。。。第一轮合并后，将0~k/2再次对折两两合并。。。以此类推，最后0号链表就是最终结果。</p>
<p><img src="https://s2.ax1x.com/2020/02/17/3C5y4J.png" alt="3C5y4J.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = lists.length;</span><br><span class="line">    <span class="keyword">if</span> (lists==<span class="keyword">null</span>|| len ==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (len&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//中心对称，两两合并</span></span><br><span class="line">            lists[i]=mergeTwoList(lists[i],lists[len-<span class="number">1</span>-i]);</span><br><span class="line">        &#125;</span><br><span class="line">        len=(len+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//合并两个链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoList</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    ListNode head=dummy,p=l1,q=l2;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="keyword">null</span>&amp;&amp;q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val&lt;q.val)&#123;</span><br><span class="line">            head.next=p;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head.next=q;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (q!=<span class="keyword">null</span>)head.next=q;</span><br><span class="line">    <span class="keyword">if</span> (p!=<span class="keyword">null</span>)head.next=p;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(Nlogk)    N是节点总数，每次对折合并所有节点都参与了，一共对折合并了logk次。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——合并两个有序链表</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="NO-21-合并两个有序链表-简单"><a href="#NO-21-合并两个有序链表-简单" class="headerlink" title="NO.21 合并两个有序链表 简单 "></a>NO.21 合并两个有序链表 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFVQZ8.png" alt="lFVQZ8.png"></p>
<p><font color=red><strong>思路一：迭代法</strong></font> 这个题目也是学校老师讲述数据结构课程时说的。1. 创建一个新的头结点dummy，用prehead指针指向新创建的dummy头结点，用p指针指向l1链表的头结点，q指针指向l2链表的头结点。2. 比较p指向的节点的值和q指向的节点的值，如果p指向的节点值小，就让prehead的next指向p所指向的节点，然后prehead和p向后移动，反之就让prehead的next指向q所指向的节点，然后prehead和q向后移动。3. 直到p或者q指针有一个为null为止，最后检查p或者q是否有不为null的指针，如果有就让prehead指向非空的p或者q。返回dummy.next即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1==<span class="keyword">null</span>)<span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2==<span class="keyword">null</span>)<span class="keyword">return</span> l1;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode prehead=dummy,p=l1,q=l2;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>&amp;&amp;q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val&lt;q.val)&#123;</span><br><span class="line">                prehead.next=p;</span><br><span class="line">                prehead=prehead.next;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                prehead.next=q;</span><br><span class="line">                prehead=prehead.next;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        最后检查p或者q是否有不为null的指针</span></span><br><span class="line">        <span class="keyword">if</span> (p!=<span class="keyword">null</span>)prehead.next=p;</span><br><span class="line">        <span class="keyword">if</span> (q!=<span class="keyword">null</span>)prehead.next=q;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：递归法</strong></font> 其实递归法不能算是第二个思路，只能说是思路一的另一种实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——合并两个有序数组</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="NO-88-合并两个有序数组-简单"><a href="#NO-88-合并两个有序数组-简单" class="headerlink" title="NO.88 合并两个有序数组 简单 "></a>NO.88 合并两个有序数组 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/03/34CGVO.png" alt="34CGVO.png"></p>
<p><strong><font color=red>思路一：暴力法</font></strong> 没啥说的直接B合并到A后面的预留位置，然后直接API对A进行排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span>[] B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        A[m+i]=B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(A);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O((m+n)*log(m+n))    排序的复杂度</p>
<p><strong><font color=red>思路二：双指针法</font></strong> 最直接想到的双指针法就是像合并两个有序链表一样双指针分别指向两个数组开头，从前向后遍历两个数组。</p>
<p>但是本题中A数组要作为最终的结果数组，所以需要将A中的m个元素保存到A2数组中，然后像上述方法一样双指针遍历A2和B数组，合并保存到A数组中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//保存nums1的m个元素</span></span><br><span class="line">    <span class="keyword">int</span>[] A2=<span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        A2[i]=nums1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//双指针比较并合并保存到nums1中</span></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;A2.length&amp;&amp;j&lt;nums2.length)&#123;</span><br><span class="line">        nums1[index++]=(A2[i]&lt;nums2[j]?A2[i++]:nums2[j++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个数组有剩余时保存到nums1后面</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;nums2.length)nums1[index++]=nums2[j++];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;A2.length)nums1[index++]=A2[i++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(m)    保存nums1的m个元素。</p>
<p><strong><font color=red>思路三：逆序双指针法</font></strong> 不使用额外的数组去保存nums1的m个元素，从而优化空间。</p>
<p>方法就是：逆序！其实就是将思路二都逆向进行。</p>
<p>双指针分别指向nums1和nums2的尾部，逆序遍历，比较大的元素优先合并入结果数组；从结果数组的尾部向前保存并入的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//指针都指向尾部，比较大的元素优先合并至nums1尾部</span></span><br><span class="line">    <span class="keyword">int</span> i=m-<span class="number">1</span>,j=n-<span class="number">1</span>,index=nums1.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>&amp;&amp;j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        nums1[index--]=(nums1[i]&gt;nums2[j]?nums1[i--]:nums2[j--]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否有剩余</span></span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span>)nums1[index--]=nums1[i--];</span><br><span class="line">    <span class="keyword">while</span> (j&gt;=<span class="number">0</span>)nums1[index--]=nums2[j--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<p>空间复杂度：O(1)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——合并区间</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="NO-56-合并区间-中等"><a href="#NO-56-合并区间-中等" class="headerlink" title="NO.56 合并区间 中等 "></a>NO.56 合并区间 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/04/3IoSbR.png" alt="3IoSbR.png"></p>
<p><strong><font color=red>思路一：排序</font></strong> 将所有区间按照左边界大小进行非递减排序。</p>
<p>什么样的区间是重叠的需要合并？</p>
<p>[1,3]、[2,6] 第1个区间的右边界大于下一个区间的左边界即发生重叠。</p>
<p>需要合并成[第一个区间的左边界,max(第一个区间的右边界,第二个区间的右边界)]这个区间加入结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (intervals==<span class="keyword">null</span>||intervals.length==<span class="number">0</span>)<span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    <span class="comment">//每个区间按照区间左边界升序排序</span></span><br><span class="line">    Arrays.sort(intervals, (o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//遍历每个区间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> pre = <span class="number">0</span>; pre &lt; intervals.length; pre++) &#123;</span><br><span class="line">        <span class="comment">//记录当前区间的左右边界值</span></span><br><span class="line">        <span class="keyword">int</span> left=intervals[pre][<span class="number">0</span>],right=intervals[pre][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//如果当前区间的右边界大于下一个区间的左边界，即发生重叠</span></span><br><span class="line">        <span class="keyword">while</span> (pre&lt;intervals.length-<span class="number">1</span>&amp;&amp;right&gt;=intervals[pre+<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">            right=Math.max(right,intervals[pre+<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            pre++;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;left,right&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>][]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n*logn)    区间数组只需要遍历一次，主要是排序的时间复杂度。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——回文数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-9-回文数-简单"><a href="#NO-9-回文数-简单" class="headerlink" title="NO.9 回文数    简单 "></a>NO.9 回文数    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/15/QfCVaQ.png" alt="QfCVaQ.png"></p>
<p><font color=red><strong>思路一：字符串法</strong></font> 最简单的解法就是直接将数字转换为字符串s，然后将字符串翻转得到re，最后判断s和rs是否相等，相等则是回文。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    String rs = <span class="keyword">new</span> StringBuilder(x + <span class="string">""</span>).reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> (x+<span class="string">""</span>).equals(rs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：翻转一半法</strong></font> 题目要求中有说，不能将整数转化为字符串来解决这个问题。但是依然可以使用字符串法的翻转思路，将数字进行翻转也并不难，例如“1221”，我们需要将后半部分“21”翻转为“12”再和前半部分“12”作比较，相同所以“1221”是回文数。</p>
<p>算法步骤：1.如果数字是负数，那么一定不是回文数。如果数字最后一位是”0“，但数字本身并不是”0“，那么该数字也一定不是回文数。2.如何翻转数字的后半部分：例如“x=1221”，先”1221%10“得到1，然后“x/=10”使x=122， 最后”t=t*10+1”得到t=1；再次“122%10”得到2，然后“x/=10”使x=12，“最后”t=t*10+2”得到t=12。3.将数字后半部分翻转后得到的t和前半部分“12”进行比较，相等则为回文数。</p>
<p><font color=green>如何判断翻转数字的位数已经到达原数字位数的一半？</font>我们将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字小于反转后的数字时，就意味着我们已经处理了一半位数的数字。</p>
<p><u>参数数字x可能是偶数也可能是基数</u>，如果x是偶数，例如“1221”，只要翻转后的“21”等于前半部分“12”，x就是回文数；如果x是基数，例如“12321”，后半部分翻转得到“123”，剩余的前半部分是”12“，但是原始数字中间的这个数字”3“并不影响回文（它总是与自身相等）,所以可以直接简单的将后半部分翻转得到“123”进行“123/10=12”的操作即可，然后再与前半部分进行比较。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        两种不是回文数的特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (x&lt;<span class="number">0</span>||(x!=<span class="number">0</span>&amp;&amp;x%<span class="number">10</span>==<span class="number">0</span>))<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//        后半部分翻转后的数字</span></span><br><span class="line">        <span class="keyword">int</span> reversedNumber=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x&gt;reversedNumber)&#123;</span><br><span class="line">            reversedNumber=reversedNumber*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        x可能是的位数可能是偶数或基数，如果是基数直接reversedNumber/10,简单的去掉中间的数</span></span><br><span class="line">        <span class="keyword">return</span> x==reversedNumber||x==reversedNumber/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——将数组分成和相等的三个部分</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E4%B8%89%E4%B8%AA%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="NO-1013-将数组分成和相等的三个部分-简单"><a href="#NO-1013-将数组分成和相等的三个部分-简单" class="headerlink" title="NO.1013 将数组分成和相等的三个部分 简单 "></a>NO.1013 将数组分成和相等的三个部分 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/11/8A3zR0.png" alt="8A3zR0.png"></p>
<p><strong><font color=red>思路一：双指针法</font></strong> 一个数组能分成和相等的三部分，则这个数组元素总sum和必定是3的倍数，如不是则否定。</p>
<p>双指针头尾开始同时遍历，寻找最左部分和最右部分总和等于sum/3的位置，并且寻找过程中要给中间部分留有余地(中间部分至少是一个元素)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//元素总和必须是3的倍数</span></span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum%<span class="number">3</span>!=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//双指针找和等于sum/3的左右部分</span></span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=A.length-<span class="number">1</span>,leftSum=A[<span class="number">0</span>],rightSum=A[A.length-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//+1给中间部分留有"余地"</span></span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)&#123;</span><br><span class="line">        <span class="keyword">if</span> (leftSum == sum / <span class="number">3</span> &amp;&amp; rightSum == sum / <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftSum != sum / <span class="number">3</span>) &#123;</span><br><span class="line">            leftSum+=A[++left];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightSum != sum / <span class="number">3</span>) &#123;</span><br><span class="line">            rightSum+=A[--right];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<p><strong><font color=red>思路二：计数器法</font></strong> 和思路一差不多，先判断元素总和是否满足条件。</p>
<p>顺序遍历，count计数器记录有多少部分的和等于sum/3。</p>
<p>如果count&gt;=3，则true。为什么是&gt;=？例如[1,-1,1,-1,1,-1,1,-1]，count==4这个数组依然符合要求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canThreePartsEqualSum</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//元素总和必须是3的倍数</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//顺序遍历找等于sum/3的部分</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, partialSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : A) &#123;</span><br><span class="line">        partialSum += i;</span><br><span class="line">        <span class="keyword">if</span> (partialSum == sum/<span class="number">3</span>) &#123;</span><br><span class="line">            partialSum=<span class="number">0</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count&gt;=<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——括号生成</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    <content><![CDATA[<h2 id="NO-22-括号生成-中等"><a href="#NO-22-括号生成-中等" class="headerlink" title="NO.22 括号生成 中等 "></a>NO.22 括号生成 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/27/lZC6kF.png" alt="lZC6kF.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 1. 将2*n个括号的序列全部得到。2. 同时判断其是否为有效序列。如果是则加入结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="string">""</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    深度优先遍历得到所有组合序列，如果是有效序列，则加入结果集</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,String conbination,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index==<span class="number">2</span>*n)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(conbination))res.add(conbination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            dfs(index+<span class="number">1</span>,conbination+<span class="string">'('</span>,n);</span><br><span class="line">            dfs(index+<span class="number">1</span>,conbination+<span class="string">')'</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    平衡法判断括号序列是否有效</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> balance=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i)==<span class="string">'('</span>)&#123;</span><br><span class="line">                balance++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                balance--;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            如果balance&lt;0则说明，)出现在与其对应的(之前，或者)多于(</span></span><br><span class="line">            <span class="keyword">if</span> (balance&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance==<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(2^2n*n)</p>
<p><font color=red><strong>思路二：回溯法</strong></font> 该方法是对上面的暴力法的一个优化思路。上面的方法需要组合出所有的序列(有效的和无效的)，思路就是不生成无效的序列(或者说是”剪枝”,剪除无效无效序列)。观察有效序列的特点：1. 因为是括号’对’，所以n对括号序列中的’(‘和’)’的数量都是n个。2. ‘)’不能出现在与其成对的’(‘之前。</p>
<p>针对上述细节，思考回溯算法细节：</p>
<ol>
<li>当’(‘和’)’的数量都是n个的时候，说明已经得到括号序列。</li>
<li>‘(‘数量小于n的时候，可以向序列中继续添加’(‘。</li>
<li>‘)’数量小于n并且当前’)’数量小于当前’(‘数量时，才可以向序列中继续添加’)’。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	List&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="string">""</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> l 左括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r 有括号数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> combination 当前括号序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 输入n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,String combination,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="comment">//        当'('和')'的数量都是n个的时候，说明已经得到括号序列。</span></span><br><span class="line">        <span class="keyword">if</span> (l==n&amp;&amp;r==n)&#123;</span><br><span class="line">            res.add(combination);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        '('数量小于n的时候，可以向序列中继续添加'('。</span></span><br><span class="line">        <span class="keyword">if</span> (l&lt;n)&#123;</span><br><span class="line">            dfs(l+<span class="number">1</span>,r,combination+<span class="string">'('</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        ')'数量小于n并且当前')'数量小于当前'('数量时，才可以向序列中继续添加')'。</span></span><br><span class="line">        <span class="keyword">if</span> (r&lt;n&amp;&amp;r&lt;l)&#123;</span><br><span class="line">            dfs(l,r+<span class="number">1</span>,combination+<span class="string">')'</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(4^n/sqrt(n))。在回溯过程中，每个有效序列最多需要n步。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——接雨水</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="NO-42-接雨水-困难"><a href="#NO-42-接雨水-困难" class="headerlink" title="NO.42 接雨水 困难 "></a>NO.42 接雨水 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/24/3Gi5ge.png" alt="3Gi5ge.png"></p>
<p><strong><font color=red>思路一：按行计算法</font></strong> 计算每一行接的水，相加得到一共接的水。</p>
<p>用一个变量temp记录第i行的水，遍历每个”墙”的高度，遇到<code>第一个大于等于i</code>的”墙”启动temp准备记录；继续遍历遇到<code>小于i</code>的”墙”<code>temp++</code>，否则遇到<code>大于等于i</code>的”墙”<code>ans加上temp并归零temp</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,maxHeight=height[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h : height)<span class="keyword">if</span> (h&gt;maxHeight)maxHeight=h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">1</span>; row &lt;= maxHeight; row++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//是否开始统计temp</span></span><br><span class="line">        <span class="keyword">boolean</span> isStart=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isStart&amp;&amp;height[i]&lt;row)temp++;</span><br><span class="line">            <span class="keyword">if</span> (height[i]&gt;=row)&#123;</span><br><span class="line">                ans+=temp;</span><br><span class="line">                temp=<span class="number">0</span>;</span><br><span class="line">                isStart=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(maxHeight<em>n)    *</em>此方法在leetcode上会超时！**</p>
<p><strong><font color=red>思路二：按列计算法</font></strong> 计算出每一列上有多少水，相加得到一共接的水。</p>
<p>想知道第i列上是否有水，我们需要找到第i列的左边和右边最高的”墙”，因为只有形成凹点才能存水；并且”木桶效应”告诉我们存了多少水，只需要考虑第i列左边和右边找到的最高的”墙”中最矮的一个。</p>
<p>第i列的高度<code>x</code>和我们找到的左边和右边最高的”墙”中最矮的一个”墙”的高度<code>y</code>会有三种关系：</p>
<ol>
<li><code>x&lt;y</code>，第i列上存的水应该是y-x。</li>
<li><code>x&gt;y</code>，第i列上一定接不到水。</li>
<li><code>x=y</code>，第i列上依然是不能接到水。</li>
</ol>
<p>知道了这些，编码就很简单了，遍历每一列的同时找到当前列左边和右边最高的两面”墙”中最矮的一个和当前列进行比较，对上述三种情况进行处理即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; height.length; col++) &#123;</span><br><span class="line">        <span class="comment">//找到col左右最高的墙</span></span><br><span class="line">        <span class="keyword">int</span> leftMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) leftMax=Math.max(leftMax,height[i]);</span><br><span class="line">        <span class="keyword">int</span> rightMax=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = col+<span class="number">1</span>; i &lt; height.length; i++) rightMax=Math.max(rightMax,height[i]);</span><br><span class="line">        <span class="comment">//如果最高的墙中最矮的一个大于col的高度，计算当前列上接的水并加入结果</span></span><br><span class="line">        <span class="keyword">if</span> (Math.min(leftMax,rightMax)&gt;height[col])ans+=Math.min(leftMax,rightMax)-height[col];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<p><strong><font color=red>思路三：动态规划优化按列计算法</font></strong> 思路二中每次寻找第i列的左右最高墙的时候都需要遍历一次整个数组。</p>
<p>思路三就是针对这点进行优化。空间换时间。</p>
<p>以题目中实例来演示：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3U8exO.md.png" alt="3U8exO.md.png"></p>
<p>每次寻找第i列左边做高的”墙”，只需要将”已经记录的i-1列左边最高的墙和i-1列进行比较，取大的即可”。避免了每次遍历整个数组。</p>
<p>寻找第i列右边做高的”墙”同理，只需要将”已经记录的i+1列右边最高的墙和i+1列进行比较，取大的即可”。</p>
<p>所以leftMax[i]的含义就是第i列左边最高的”墙”，rightMax[i]的含义就是第i列右边最高的”墙”(不含第i列本身)。</p>
<p>初始化：顺序遍历一次填写leftMax数组，逆序遍历一次填写rightMax数组。</p>
<p>有了leftMax和rightMax之后，然后计算每一列上接的水和思路二中方法一样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//计算leftMax，rightMax</span></span><br><span class="line">    <span class="keyword">int</span>[] leftMax=<span class="keyword">new</span> <span class="keyword">int</span>[height.length],rightMax=<span class="keyword">new</span> <span class="keyword">int</span>[height.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length; i++) leftMax[i]=Math.max(leftMax[i-<span class="number">1</span>],height[i-<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=height.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) rightMax[i]=Math.max(rightMax[i+<span class="number">1</span>],height[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//计算每一列上的水</span></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min=Math.min(leftMax[i],rightMax[i]);</span><br><span class="line">        <span class="keyword">if</span> (min&gt;height[i])&#123;</span><br><span class="line">            ans+=min-height[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    三次遍历</p>
<p>空间复杂度：O(n)</p>
<p><strong><font color=red>思路四：双指针优化动态规划法</font></strong> 双指针主要是对思路三中的空间复杂度进行优化。</p>
<p>上述方法中，两个数组中的每个元素在计算每一列上的水的时候只会被使用一次。所以完全可以用两个int类型的变量实现。</p>
<p>依然是用题目中的实例来演示：</p>
<p><img src="https://s2.ax1x.com/2020/02/26/3UscqI.png" alt="3UscqI.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/26/3Us6sA.png" alt="3Us6sA.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/26/3Us2Zt.md.png" alt="3Us2Zt.md.png"></p>
<p>就按照上述方式计算出每一列上的水并加入结果，直至left&gt;right结束。</p>
<p>双指针法虽然是沿用了思路二思路三的方式去找左右最高”墙”，==但是为什么计算leftMax和rightMax的位置相差这么远依然可以有效判断呢？==</p>
<p>例如，对于left墙height[left]，如果leftMax比height[left]高。那么如果rightMax比leftMax高，那么就说明left右边一定存在比height[left]高的墙，那么left列上面一定可以接到水。</p>
<p>即使rightMax对于left右边来说不是最高的墙也无所谓，因为如果不是最高的墙，那么同样存在另一个比height[left]高的墙，那么left列上同样可以接到水，且接水量同样是leftMax-height[left]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (height==<span class="keyword">null</span>||height.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> leftMax=<span class="number">0</span>,rightMax=<span class="number">0</span>,ans=<span class="number">0</span>,left=<span class="number">1</span>,right=height.length-<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//计算更新leftMax rightMax</span></span><br><span class="line">        leftMax=Math.max(leftMax,height[left-<span class="number">1</span>]);</span><br><span class="line">        rightMax=Math.max(rightMax,height[right+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//比较leftMax和rightMax，找到较低的那一侧</span></span><br><span class="line">        <span class="keyword">if</span> (leftMax&lt;rightMax)&#123;</span><br><span class="line">            <span class="keyword">if</span> (leftMax&gt;height[left])ans+=leftMax-height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rightMax&gt;height[right])ans+=rightMax-height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——罗马数字转整数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-13-罗马数字转整数-简单"><a href="#NO-13-罗马数字转整数-简单" class="headerlink" title="NO.13 罗马数字转整数 简单 "></a>NO.13 罗马数字转整数 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/16/Q4As2Q.png" alt="Q4As2Q.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/16/Q4Ar8g.png" alt="Q4Ar8g.png"></p>
<p><font color=red><strong>思路一：哈希表</strong></font> 1.用一个hash表把所有罗马数字和阿拉伯数字相互匹配的特殊值作为键值对存储起来，例如”M,1000”、”CM,900”、”D,500”、”CD，400”。。。2.然后将字符串逐步分割并去hash表进行查询匹配，因为两位长度的罗马数字优先于一位长度的罗马数字，所以每步循环都需要先两位分割匹配再一位分割匹配。3.匹配到hash表的键之后，将对应的值加入结果中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        所有罗马数字和阿拉伯数字相互匹配的特殊值作为键值对存储起来</span></span><br><span class="line">        Map&lt;String,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"M"</span>,<span class="number">1000</span>);</span><br><span class="line">        map.put(<span class="string">"CM"</span>,<span class="number">900</span>);</span><br><span class="line">        map.put(<span class="string">"D"</span>,<span class="number">500</span>);</span><br><span class="line">        map.put(<span class="string">"CD"</span>,<span class="number">400</span>);</span><br><span class="line">        map.put(<span class="string">"C"</span>,<span class="number">100</span>);</span><br><span class="line">        map.put(<span class="string">"XC"</span>,<span class="number">90</span>);</span><br><span class="line">        map.put(<span class="string">"L"</span>,<span class="number">50</span>);</span><br><span class="line">        map.put(<span class="string">"XL"</span>,<span class="number">40</span>);</span><br><span class="line">        map.put(<span class="string">"X"</span>,<span class="number">10</span>);</span><br><span class="line">        map.put(<span class="string">"IX"</span>,<span class="number">9</span>);</span><br><span class="line">        map.put(<span class="string">"V"</span>,<span class="number">5</span>);</span><br><span class="line">        map.put(<span class="string">"IV"</span>,<span class="number">4</span>);</span><br><span class="line">        map.put(<span class="string">"I"</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        然后将字符串逐步分割并去hash表进行查询匹配</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length(); )&#123;</span><br><span class="line"><span class="comment">//            两位长度的罗马数字优先于一位长度的罗马数字,所以先进行两位长度罗马数字的判断</span></span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span>&lt;s.length()&amp;&amp;map.containsKey(s.substring(i,i+<span class="number">2</span>)))&#123;</span><br><span class="line">                ans+=map.get(s.substring(i,i+<span class="number">2</span>));</span><br><span class="line">                i+=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans+=map.get(s.substring(i,i+<span class="number">1</span>));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——零钱兑换</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="NO-322-零钱兑换-中等"><a href="#NO-322-零钱兑换-中等" class="headerlink" title="NO.322 零钱兑换 中等 "></a>NO.322 零钱兑换 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/08/3vz7RI.png" alt="3vz7RI.png"></p>
<p><strong><font color=red>思路一：深度优先遍历</font></strong> 暴力方法超时！检查所有的组合方式，找出符合要求的组合中硬币数量最少的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coins==<span class="keyword">null</span>||coins.length==<span class="number">0</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    dfs(coins,amount,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans==Integer.MAX_VALUE?-<span class="number">1</span>:ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深搜，count记录硬币数量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果小于0，说明当前组合不对，回溯</span></span><br><span class="line">    <span class="keyword">if</span> (amount&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//等于0说明当前组合正确，如果硬币数量更少，则更新结果</span></span><br><span class="line">    <span class="keyword">if</span> (amount==<span class="number">0</span>)&#123;</span><br><span class="line">        ans=Math.min(ans,count);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">        dfs(coins,amount-coins[i],count+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(amount^n) n是不同面额硬币的种类</p>
<p><strong><font color=red>思路二：动态规划</font></strong> dp数组的含义：dp[i]=x 表示至少x个硬币组成i元，即i元的最优解。</p>
<p>dp数组初始化：长度为amount+1，即0元~amount元。dp[0]=0，0元自然是不需要硬币。1~amount初始化为amount+1，因为硬币面额都是整数无论如何amount元也不会需要amount+1个硬币进行组合。</p>
<p>状态转移：无论当前目标金额是多少，都要从coins列表中取出一个面额，然后目标金额就会较少这个面额。如果dp[当前金额-取出面额]有解，则dp[当前金额]就是在其子问题dp[当前金额-取出面额]的基础上加一个硬币。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    Arrays.fill(dp,amount+<span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//填写dp</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">        <span class="comment">//金额i的所有子问题</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="comment">//不存在这个子问题</span></span><br><span class="line">            <span class="keyword">if</span> (i-coin&lt;<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//在子问题的基础上加一个硬币，取最小值</span></span><br><span class="line">            dp[i]=Math.min(dp[i],dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查amount是否有解</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount]==amount+<span class="number">1</span>?-<span class="number">1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(amount*n)    n是不同面额种类</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——三数之和</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="NO-15-三数之和-中等"><a href="#NO-15-三数之和-中等" class="headerlink" title="NO.15 三数之和 中等 "></a>NO.15 三数之和 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/17/QocMLV.png" alt="QocMLV.png"></p>
<p>这道题有一个麻烦的地方，就是需要去重，如果直接简单的三重循环暴力破解的话，除了时间复杂度问题之外还不便于去重。</p>
<p><font color=red><strong>思路一：双指针法</strong></font> 1. 首先对数组进行排序。2. 依次遍历数组元素，每遍历一个元素nums[i]时，就用左右指针指向nums[i]后面元素部分的两端，即指向nums[L]和nums[R]，判断nums[i]、nums[L]和nums[R]之和sum是否等于0，等于0则加入结果集。如果sum&gt;0，则说明需要较小的数字，即”R–”。如果sum&lt;0，则说明需要较大的数字，即”L++”。循环直至左右指针相遇，即后面元素部分已组合完毕，则本次循环结束。3. 如果遍历到某个元素nums[i]已经大于0，则三数之和必然大于0（充分利用排序后的特点，减少无用的比较），结束循环。</p>
<p>然后是该算法去重的思路：4. 如果nums[i]==nums[i-1]，就会导致结果重复，所以应该跳过。5. 如果sum==0的时候,nums[L]==num[L+1]就会导致结果重复，所以应该跳过，L++。6. 如果sum==0的时候，nums[R]=nums[R-1]就会导致结果重复，所以应该跳过，R–。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums==<span class="keyword">null</span>||len&lt;<span class="number">3</span>)<span class="keyword">return</span> ans;</span><br><span class="line"><span class="comment">//        1.排序</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"><span class="comment">//        2. 依次遍历数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="comment">//            如果当前元素已经大于0，那么之后所有的三数之和一定都大于0。结束循环。</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//            4. 如果nums[i]==nums[i-1]，就会导致结果重复，所以应该跳过。</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line"><span class="comment">//            用左右指针指向nums[i]后面元素部分的两端</span></span><br><span class="line">            <span class="keyword">int</span> L=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R=len-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//            循环直至左右指针相遇，即后面元素部分已组合完毕，则本次循环结束。</span></span><br><span class="line">            <span class="keyword">while</span> (L&lt;R)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span> (sum==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//                    三数之和等于0，等于0则加入结果集。</span></span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line"><span class="comment">//                    5. 如果sum\=\=0的时候,nums[L]\=\=num[L+1]就会导致结果重复，所以应该跳过，L++。</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[L]==nums[L+<span class="number">1</span>])L++;</span><br><span class="line"><span class="comment">//                    6. 如果sum\=\=0的时候，nums[R]=nums[R-1]就会导致结果重复，所以应该跳过，R--。</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R&amp;&amp;nums[R]==nums[R-<span class="number">1</span>])R--;</span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&gt;<span class="number">0</span>)&#123;<span class="comment">//如果sum&gt;0，则说明需要较小的数字，即"R--"</span></span><br><span class="line">                    R--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum&lt;<span class="number">0</span>)&#123;<span class="comment">//如果sum&lt;0，则说明需要较大的数字，即"L++"</span></span><br><span class="line">                    L++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n^2)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——全排列II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97%20II/</url>
    <content><![CDATA[<h2 id="NO-47-全排列II-中等"><a href="#NO-47-全排列II-中等" class="headerlink" title="NO.47 全排列II 中等 "></a>NO.47 全排列II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10yScq.png" alt="10yScq.png"></p>
<p><font color=red><strong>思路一：深度遍历，回溯法</strong></font> 本题和前文<u>46.全排列</u>相似，区别在于本题的数组中可能包含重复元素。</p>
<p>根据上一题的经验，已经知道<strong>每一条分支路径上每个数组元素只能使用一次</strong>，这个问题已经解决了：使用一个nums.length长度的boolean类型的数组标志每个元素的使用情况，false未使用，true已使用。</p>
<p>但是仅仅依靠判断元素的使用情况是不够的，因为数组中可能存在未被使用但是值相等的元素。根据前文<u>40.组合总和II</u>中的经验，<strong>相等的元素不能作为兄弟节点，但是可以作为父子节点</strong>。于是我们就可以<u>先对nums数组排序</u>，再判断每个节点使用的元素是否和之前一个兄弟节点使用的元素相等，相等则剪枝，语句形如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当前元素和之前一个兄弟节点使用的元素相等，且相等元素节点不是当前节点的父节点</span></span><br><span class="line"><span class="keyword">if</span> (i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i-<span class="number">1</span>] &amp;&amp; !used[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>为什么需要” &amp;&amp;!nums[i-1] “，以示例[1,1’,2]来说(只是简单画出了小部分，领会精神即可)：</p>
<p><a href="https://imgchr.com/i/1s3QlF" target="_blank" rel="noopener"><img src="https://s2.ax1x.com/2020/02/05/1s3QlF.md.png" alt="1s3QlF.md.png"></a></p>
<p>剪枝的地方没什么问题，但是[ 2,1,1’ ]这个节点使用元素” 1’ “，该节点的索引是1、且等于nums[0]，如果没有” &amp;&amp;!nums[i-1] “的限制也应该被剪枝。但是这个节点应该被保留，是因为<strong>相等元素允许作为父子节点</strong>，所以” &amp;&amp;!nums[i-1] “的限制是有必要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permuteUnique(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="comment">//对数组排序，使重复元素紧凑在一起，方便后续剪枝</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="comment">//标记每个元素的使用情况，默认值false表示未使用</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    dfs(flag,<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] flag, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成组合</span></span><br><span class="line">    <span class="keyword">if</span> (track.size()==nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">new</span> ArrayList&lt;&gt;(track)));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//当前元素未被使用，防止一条路径上出现一个元素被重复使用</span></span><br><span class="line">        <span class="keyword">if</span> (!flag[i])&#123;</span><br><span class="line">            <span class="comment">//当前元素和之前一个兄弟节点使用的元素相等，且相等元素节点不是当前节点的父节点</span></span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>]&amp;&amp;!flag[i-<span class="number">1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//将当前元素加入组合中，并将元素对应的标志置为true</span></span><br><span class="line">            track.add(nums[i]);</span><br><span class="line">            flag[i]=<span class="keyword">true</span>;</span><br><span class="line">            dfs(flag,track);</span><br><span class="line">            <span class="comment">//每次回溯将最后加入的元素移除，并将被移除元素对应的标志置为false</span></span><br><span class="line">            track.removeLast();</span><br><span class="line">            flag[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p> 本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——全排列</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%85%A8%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h2 id="NO-46-全排列-中等"><a href="#NO-46-全排列-中等" class="headerlink" title="NO.46 全排列 中等 "></a>NO.46 全排列 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/03/10uGsf.png" alt="10uGsf.png"></p>
<p><font color=red><strong>思路一：深度优先遍历，回溯法</strong></font> 看到全排列，就想到DFS构建树。重点是<strong>每条分支路径上每个数组元素只能使用一次</strong>。可以使用一个nums.length长度的boolean类型的数组标志每个元素的使用情况，false未使用，true已使用。</p>
<p>递归前先检查当前元素是否被使用过，如果使用过就剪枝；如果未使用过就将当前元素加入集合并将对应的标志设置为true。</p>
<p>每次回溯的时候不仅要将最后加入集合的元素移除，还要将被移除元素对应的标志置为false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span>[] nums;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">this</span>.nums=nums;</span><br><span class="line">    <span class="comment">//标记每个元素是否被使用过，默认值false表示未使用</span></span><br><span class="line">    <span class="keyword">boolean</span>[] flag=<span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</span><br><span class="line">    dfs(<span class="keyword">new</span> LinkedList&lt;Integer&gt;(),flag);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(LinkedList&lt;Integer&gt; combination,<span class="keyword">boolean</span>[] flag)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//完成组合</span></span><br><span class="line">    <span class="keyword">if</span> (combination.size()==nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(combination));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//当前元素未使用过，防止一条路径上出现一个元素被重复使用</span></span><br><span class="line">        <span class="keyword">if</span> (!flag[i])&#123;</span><br><span class="line">            <span class="comment">//将当前元素加入组合中，并将元素对应的标志置为true</span></span><br><span class="line">            combination.add(nums[i]);</span><br><span class="line">            flag[i]=!flag[i];</span><br><span class="line">            dfs(combination,flag);</span><br><span class="line">            <span class="comment">//每次回溯将最后加入的元素移除，并将被移除元素对应的标志置为false</span></span><br><span class="line">            flag[i]=!flag[i];</span><br><span class="line">            combination.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(N*N!)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——删除链表的倒数第N个节点</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h2 id="NO-19-删除链表的倒数第N个节点-中等"><a href="#NO-19-删除链表的倒数第N个节点-中等" class="headerlink" title="NO.19 删除链表的倒数第N个节点 中等 "></a>NO.19 删除链表的倒数第N个节点 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/25/lFV1Ig.png" alt="lFV1Ig.png"></p>
<p><font color=red><strong>思路一：两次遍历</strong></font> 第一次遍历得到链表的长度L，第二次遍历删除第（L-N+1）个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        依然是借助哑节点</span></span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>),q=head;</span><br><span class="line">        dummy.next=head;</span><br><span class="line"><span class="comment">//        第一次遍历获取链表长度</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        第二次遍历找到待删除节点的前一个节点</span></span><br><span class="line">        q=dummy;</span><br><span class="line">        len-=n;</span><br><span class="line">        <span class="keyword">while</span> (len&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            len--;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        删除目标节点</span></span><br><span class="line">        q.next=q.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>操作执行了2L-n步，时间复杂度为O(L)。</p>
<p><font color=red><strong>思路二：双指针一次遍历</strong></font> 1. 用两个指针p、q分别指向链表的开头(哑节点)。2. 先让q指针逐步移动到距离p指针n+1的位置上，也就是上p指针和q指针间隔n个节点。3. 让p指针和q指针同时向后移动，直至q指针为null。4. 此时p指针指向的节点的下一个节点就是待删除节点，p.next=p.next.next删除即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next=head;</span><br><span class="line">        ListNode p=dummy;</span><br><span class="line">        ListNode q=dummy;</span><br><span class="line"><span class="comment">//        首先让q指针移动到和p指针间隔n个元素的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        此时让p和q保持间距的情况下，同时向后移动，直到q为null</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q=q.next;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        删除目标节点</span></span><br><span class="line">        p.next=p.next.next;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>操作执行了L+n+1步，时间复杂度为O(L)。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——实现strStr()</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E5%AE%9E%E7%8E%B0strStr()/</url>
    <content><![CDATA[<h2 id="NO-28-实现strStr-简单"><a href="#NO-28-实现strStr-简单" class="headerlink" title="NO.28 实现strStr() 简单 "></a>NO.28 实现strStr() <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/30/llALfs.png" alt="llALfs.png"></p>
<p>吐槽一下：这道题的难度标识实在是令人纠结，虽然练习题目才是核心，但是题目的难度标识对于我这样的初学者也是不可缺少的参考标识。</p>
<p>题还没读完，脑海里跳出的第一个想法居然是直接用indexOf()。。。还好立刻就否决了这个想法，但是还是在好奇心的驱使下leetcode提交了一次这个”算法”。。。0ms 100%。。。那就等刷完这道题，读一下indexOf()的源码吧！^_^</p>
<p><font color=red><strong>思路一：双指针暴力法</strong></font> 1. 用i和j分别指向haystack字符串和needle字符串的开头。2. 如果haystack的i号字符等于needle的j号字符，则j和i都向后移动。3. 如果haystack的i号字符不等于needle的j号字符，则j回到needle字符串的开头，i也回溯之后继续比较。4. 循环直至haystack遍历完毕或者needle遍历完毕。5. 最后如果j指针没有遍历我能needle则说明haystack串不包含needle串，返回-1；反之则返回i-j。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (haystack==<span class="keyword">null</span>||needle==<span class="keyword">null</span>)<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;haystack.length()&amp;&amp;j&lt;needle.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (haystack.charAt(i)==needle.charAt(j))&#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i=i-j;</span><br><span class="line">            j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j&lt;needle.length()?-<span class="number">1</span>:i-j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)</p>
<p><font color=red><strong>思路二：Sunday法</strong></font> 该算法的思路相较于KMP十分容易理解，1. 构建一张偏移表，该表主要记录了模式串中的每一个字符，以及每个字符在模式串中出现的最右位置到尾部的距离+1，未在模式串中出现的字符对应的偏移距离都是”模式串长度+1”。2. 有了偏移表之后开始比较，用idx作为当前查询索引，每次截取目标字符串的[idx，idx+模式串长度]子串和模式串比较，如果相等则返回idx。3. 如果不相等，查看子串在目标串中的后一个字符c是否存在于偏移表中，如果存在则idx=idx+偏移表[c]；如果不存在idx=idx+模式串长度+1。循环直至idx+模式串长度&gt;目标字符串长度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack,String needle)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (needle.equals(<span class="string">""</span>))<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hLen=haystack.length(),nLen=needle.length();</span><br><span class="line">        <span class="keyword">if</span> (hLen&lt;nLen)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//        创建偏移表</span></span><br><span class="line">        Map&lt;Character,Integer&gt; offsetMap=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nLen;i++)&#123;</span><br><span class="line">            offsetMap.put(needle.charAt(i),nLen-i);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        开始查找模式串</span></span><br><span class="line">        <span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//        循环直至idx+模式串长度&gt;目标字符串长度</span></span><br><span class="line">        <span class="keyword">while</span> (idx+nLen&lt;=hLen)&#123;</span><br><span class="line"><span class="comment">//            截取目标字符串</span></span><br><span class="line">            String cutHay = haystack.substring(idx, idx + nLen);</span><br><span class="line"><span class="comment">//            如果子串和模式串相等，则返回idx</span></span><br><span class="line">            <span class="keyword">if</span> (cutHay.equals(needle))&#123;</span><br><span class="line">                <span class="keyword">return</span> idx;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                边界处理，如果子串后面已经没有字符，即已经是最后一组子串，则搜索失败</span></span><br><span class="line">                <span class="keyword">if</span>(idx+nLen&gt;=hLen)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//                如果子串在目标串中的后一个字符c是否存在于偏移表中</span></span><br><span class="line">                <span class="keyword">if</span> (offsetMap.containsKey(haystack.charAt(idx+nLen)))&#123;</span><br><span class="line">                    idx+=offsetMap.get(haystack.charAt(idx+nLen));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    idx+=nLen+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m*n)， 但是该算法的平均情况也可以达到O(n)。</p>
<p><font color=red><strong>思路三：KMP法</strong></font> 数据结构课的时候没学透彻，趁这次机会好好学习一下。作为一只弱鸡，就不瞎扯KMP了，直接找个”巨人肩膀”窥探一下KMP的原理。经过多方查找，最终通过<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">阮一峰的一篇文章</a>艰难入门KMP算法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String haystack, String needle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> tarsize = needle.length();                <span class="comment">//短字符串</span></span><br><span class="line">            <span class="keyword">int</span> scrsize = haystack.length();              <span class="comment">//长字符串</span></span><br><span class="line">            <span class="keyword">if</span>(tarsize == <span class="number">0</span>)                              <span class="comment">//短字符串是0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(tarsize &gt; scrsize)                         <span class="comment">//短字符串 比 长字符串长</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tarsize == scrsize &amp;&amp; needle.equals(haystack))    <span class="comment">//两个字符串相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> start = <span class="number">0</span>;                             <span class="comment">//长字符串的和短字符串比较的第一个字符</span></span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;                          <span class="comment">//长字符串的和短字符串正在比较的相对第一个位置</span></span><br><span class="line">            <span class="keyword">int</span>[] next = getNext(needle);       <span class="comment">//得到next数组</span></span><br><span class="line">            <span class="keyword">while</span> (start &lt;= scrsize - tarsize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.charAt(start + i) == needle.charAt(i))</span><br><span class="line">                &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span>(i == tarsize)</span><br><span class="line">                        <span class="keyword">return</span> start;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    start = start + i - next[i];</span><br><span class="line">                    i = i &gt; <span class="number">0</span> ? next[i] : <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String needle)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tarsize = needle.length();</span><br><span class="line">            <span class="keyword">int</span>[] next =  <span class="keyword">new</span> <span class="keyword">int</span>[tarsize];</span><br><span class="line">            next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(tarsize &gt; <span class="number">1</span>)</span><br><span class="line">                next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; tarsize)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(needle.charAt(i-<span class="number">1</span>) == needle.charAt(j))   <span class="comment">//</span></span><br><span class="line">                &#123;</span><br><span class="line">                    next[i] = j+<span class="number">1</span>;</span><br><span class="line">                    j++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    j = next[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    next[i] = <span class="number">0</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(m+n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
        <tag>Sunday算法</tag>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——搜索插入位置</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="NO-35-搜索插入位置-简单"><a href="#NO-35-搜索插入位置-简单" class="headerlink" title="NO.35 搜索插入位置 简单 "></a>NO.35 搜索插入位置 <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/01/05/lr9R3t.png" alt="lr9R3t.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 线性查找，找到目标值或者大于目标值元素则停止。否则插入到返回nums.length。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;        </span><br><span class="line">        <span class="keyword">if</span> (nums[i]==target||nums[i]&gt;target)<span class="keyword">return</span> i;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n)</p>
<p><font color=red><strong>思路二：二分法</strong></font> 和普通的二分法变化不大,主要区别在于最后查找失败后不返回-1，而是返回left。</p>
<p>例[1,3,5,6]、target=4。初始化left=0、right=4-1；第一次循环4&gt;3，left=1+1；第二次循环4&lt;5，right=2-1；left&gt;right循环结束，返回left，即插入位置为2。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchInsert</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>,right=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right=mid-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid]&lt;target)&#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>需要注意right的初始取值，会影响搜索区间继而影响循环终止条件、right移动。</font></p>
<p>时间复杂度：O(logn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——数字转罗马数字</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%95%B0%E5%AD%97%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="NO-12-数字转罗马数字-中等"><a href="#NO-12-数字转罗马数字-中等" class="headerlink" title="NO.12 数字转罗马数字 中等 "></a>NO.12 数字转罗马数字 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/15/QfXSAI.png" alt="QfXSAI.png"></p>
<p><img src="https://s2.ax1x.com/2019/12/15/QfOxHA.png" alt="QfOxHA.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 因为题目中说了输入范围是1~3999，所以我们可以用一个二维数组列出每一位上的所有可能：</p>
<p>roman[4][10]={</p>
<p>​        {“”, “I”, “II”, “III”, “IV”, “V”, “VI”, “VII”, “VIII”, “IX”}</p>
<p>​        {“”, “X”, “XX”, “XXX”, “XL”, “L”, “LX”, “LXX”, “LXXX”, “XC”}</p>
<p>​        {“”, “C”, “CC”, “CCC”, “CD”, “D”, “DC”, “DCC”, “DCCC”, “CM”}</p>
<p>​        {“”, “M”, “MM”, “MMM”,””,””,””,””,””,””}</p>
<p>}</p>
<p>然后用一个list&lt;String&gt;存储每一位上的阿拉伯数字的罗马数字表示，最后将String拼起来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    String[][] roman=<span class="keyword">new</span> String[][]&#123;</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"I"</span>, <span class="string">"II"</span>, <span class="string">"III"</span>, <span class="string">"IV"</span>, <span class="string">"V"</span>, <span class="string">"VI"</span>, <span class="string">"VII"</span>, <span class="string">"VIII"</span>, <span class="string">"IX"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"X"</span>, <span class="string">"XX"</span>, <span class="string">"XXX"</span>, <span class="string">"XL"</span>, <span class="string">"L"</span>, <span class="string">"LX"</span>, <span class="string">"LXX"</span>, <span class="string">"LXXX"</span>, <span class="string">"XC"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"C"</span>, <span class="string">"CC"</span>, <span class="string">"CCC"</span>, <span class="string">"CD"</span>, <span class="string">"D"</span>, <span class="string">"DC"</span>, <span class="string">"DCC"</span>, <span class="string">"DCCC"</span>, <span class="string">"CM"</span>&#125;,</span><br><span class="line">            &#123;<span class="string">""</span>, <span class="string">"M"</span>, <span class="string">"MM"</span>, <span class="string">"MMM"</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>,<span class="string">""</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    StringBuilder result=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    result.append(roman[<span class="number">3</span>][num/<span class="number">1000</span>%<span class="number">10</span>]);<span class="comment">//最高位，千位</span></span><br><span class="line">    result.append(roman[<span class="number">2</span>][num/<span class="number">100</span>%<span class="number">10</span>]);<span class="comment">//百位</span></span><br><span class="line">    result.append(roman[<span class="number">1</span>][num/<span class="number">10</span>%<span class="number">10</span>]);<span class="comment">//十位</span></span><br><span class="line">    result.append(roman[<span class="number">0</span>][num%<span class="number">10</span>]);<span class="comment">//个位</span></span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：贪心算法</strong></font> 先用两个数组分别列出罗马数字和阿拉伯数字的所有特殊点，然后将当前的阿拉伯数字与当前最大的单位作比较，每次转换完一个当前最大单位就减去已转换的当前最大单位；然后再和当前最大的单位作比较如果已不足当前最大单位，就用仅次于当前最大单位的下一个最大单位去比较。。。直到当前的阿拉伯数字等于0。</p>
<p><strong>例如</strong>“2978”，一开始最大单位是”M”表示”1000”，就用两个M转换出2000；</p>
<p>当前阿拉伯数字剩余978，已不足当前最大单位”M”,就用仅次于当前最大单位的”CM”表示”900”去比较，用一个CM转换出900；</p>
<p>当前阿拉伯数字剩余78，已不足当前最大单位”CM”,就用仅次于当前最大单位的”D”表示”500”去比较，还是不足，再用次大的单位”CD”表示”400”去比较，还是不足，再用次大的单位”C”表示”100”去比较，还是不足，再用次大的单位”XC”表示”90”去比较，还是不足，再用次大的单位”L”表示”50”去比较，可以用一个L转换出50；</p>
<p>当前阿拉伯数字剩余28，已不足当前最大单位”L”,就用仅次于当前最大单位的”XL”表示”40”去比较，还是不足，再用次大的单位”X”表示”10”去比较，可以用两个X转换出20；</p>
<p>当前阿拉伯数字剩余8，已不足当前最大单位”X”,就用仅次于当前最大单位的”IX”表示”9”去比较，还是不足，再用次大的单位”V”表示”5”去比较，可以用一个V转换出5；</p>
<p>当前阿拉伯数字剩余3，已不足当前最大单位”V”,就用仅次于当前最大单位的”IV”表示”4”去比较，还是不足，再用次大的单位”I”表示”1”去比较，可以用三个I转换出3；</p>
<p>当前阿拉伯数字剩余0，转换结束，输出两个M、一个CM、一个L、两个XX、一个V、三个I，即“MMCMLXXVIII”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        列出所有罗马数字和阿拉伯数字的特殊点</span></span><br><span class="line">        String[] roman=&#123;<span class="string">"M"</span>,<span class="string">"CM"</span>,<span class="string">"D"</span>,<span class="string">"CD"</span>,<span class="string">"C"</span>,<span class="string">"XC"</span>,<span class="string">"L"</span>,<span class="string">"XL"</span>,<span class="string">"X"</span>,<span class="string">"IX"</span>,<span class="string">"V"</span>,<span class="string">"IV"</span>,<span class="string">"I"</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arab=&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//        贪心算法</span></span><br><span class="line">        String result=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> count=num/arab[index];</span><br><span class="line">            <span class="keyword">while</span> (count--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                result+=roman[index];</span><br><span class="line">            &#125;</span><br><span class="line">            num%=arab[index];</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——求众数II</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E6%B1%82%E4%BC%97%E6%95%B0II/</url>
    <content><![CDATA[<h2 id="NO-229-求众数II-中等"><a href="#NO-229-求众数II-中等" class="headerlink" title="NO.229 求众数II 中等 "></a>NO.229 求众数II <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s1.ax1x.com/2020/03/13/8nXKh9.png" alt="8nXKh9.png"></p>
<p><strong><font color=red>思路一：摩尔投票法</font></strong> 本题是上一题169的姊妹题，本题没有说一定存在这个”较多的元素”。而且本题的众数的数量需要讨论。</p>
<p>n/k的众数最多有k-1个，本题的符合大于n/3的众数最多有3-1=2个。就像169题中要求的大于n/2，很容易就想到最多存在一个。</p>
<p>知道了本题最多存在两个符合要求的元素，那么根据摩尔头条进行改进：仍然是先定下候选人A、B，然后分别有一个计数器count1、count2。</p>
<p>遍历所有元素，如果当前元素投票给A(和A相等)则count1++，如果是投票给B则count++。</p>
<p>如果不投给A和B，检查两个计数器是否等于0，如果等于0则让被投票的num作为新的候选人且相应的计数器置为1；如果计数器都不等于0，则两个计数器都-1。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> candidate1=<span class="number">0</span>,candidate2=<span class="number">0</span>,count1=<span class="number">0</span>,count2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">//投给A或者B</span></span><br><span class="line">        <span class="keyword">if</span> (num==candidate1)&#123;</span><br><span class="line">            count1++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不投给A和B且A或B等于0</span></span><br><span class="line">        <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">            candidate1=num;</span><br><span class="line">            count1++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">            candidate2=num;</span><br><span class="line">            count2++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不投给A和B且A和B不等于0</span></span><br><span class="line">        count1--;</span><br><span class="line">        count2--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查A和B是否符合要求</span></span><br><span class="line">    count1=count2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">//必须是else if，防止所有元素都相等的情况</span></span><br><span class="line">        <span class="keyword">if</span> (num == candidate1)&#123;</span><br><span class="line">            count1++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == candidate2) &#123;</span><br><span class="line">            count2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count1&gt;nums.length/<span class="number">3</span>)res.add(candidate1);</span><br><span class="line">    <span class="keyword">if</span> (count2&gt;nums.length/<span class="number">3</span>)res.add(candidate2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    两次遍历</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>摩尔投票算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——盛最多水的容器</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%20/</url>
    <content><![CDATA[<h2 id="NO-11-盛最多水的容器-中等"><a href="#NO-11-盛最多水的容器-中等" class="headerlink" title="NO.11 盛最多水的容器 中等 "></a>NO.11 盛最多水的容器 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/15/QfYcDK.png" alt="QfYcDK.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font> 最简单的方法就是将所有的垂直线两两组合，每组计算出容纳的值，返回最大的值即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxarea=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;height.length;j++)</span><br><span class="line"><span class="comment">//                (j-i)一定要记得加括号。。。不要做蠢事</span></span><br><span class="line">                maxarea=Math.max(maxarea,Math.min(height[i],height[j])*(j-i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>共有n(n-1)/2种组合，时间复杂度：O(n^2)</p>
<p><font color=red><strong>思路二：双指针法</strong></font> 用两个指针分别指向数组的开头和结尾，每次较短垂直线那端的指针向较长垂直线那端移动一个下标，每次移动之后用maxarea持续存储目前为止获得的最大面积，直到每个垂直线都被访问过一次为止。</p>
<p>套用语句说烂的话：一个木桶能盛多少水，取决于最短的那根木板。双指针法的形成思路和”短板效应“差不多，<u>两根垂直线之间的面积取决于较短的那根垂直线m，所以想要得到更大的面积，较短的那根垂直线m必须要舍弃</u>，因为如果不舍弃m，高最大就是m，而随着指针的移动宽一直在减少，因此面积只会越来越小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxarea=<span class="number">0</span>,l=<span class="number">0</span>,r=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l&lt;r)&#123;</span><br><span class="line">        maxarea=Math.max(maxarea,Math.min(height[l],height[r])*(r-l));</span><br><span class="line">        <span class="keyword">if</span> (height[l]&lt;height[r])&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxarea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个元素被访问一次，时间复杂度:O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——缺失的第一个正数</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-41-缺失的第一个正数-困难"><a href="#NO-41-缺失的第一个正数-困难" class="headerlink" title="NO.41 缺失的第一个正数 困难 "></a>NO.41 缺失的第一个正数 <font color=#ff0099>困难</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/02/24/38HH7d.png" alt="38HH7d.png"></p>
<p><strong><font color=red>思路一：两次遍历</font></strong> 第一次遍历将每个元素交换到其元素值对应的下标出，第二次遍历检查每个元素的值和其下标是否相等，如不相等则这个下标就是缺失的第一个正数。</p>
<ol>
<li>第一次遍历：<ul>
<li>将所有符合<code>nums[i]大于0且小于length</code>的元素交换到其值对应的下标位置，例如2应当交换到nums[2]的位置、6应当交换到nums[6]的位置。</li>
<li>如果<code>nums[i]==nums[nums[i]]</code>则不需要移动，例如nums[0]==3但是nums[3]==3就不需要移动了。</li>
<li>交换之后再检查nums[i]是否依然需要交换，如果需要交换继续交换，直至nums[i]无需交换再继续向后遍历。</li>
</ul>
</li>
<li>第二次遍历：<ul>
<li>从1开始，如果<code>nums[i]!=i</code>则i就是缺失的第一个正数。</li>
</ul>
</li>
<li>两次遍历结束后：<ul>
<li>如果没有找到缺失的第一个正数，就检查<code>nums[0]==length</code>如果相等则返回length+1，否则返回length</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (nums[i]&gt;<span class="number">0</span>&amp;&amp;nums[i]&lt;nums.length&amp;&amp;nums[i]!=nums[nums[i]])&#123;</span><br><span class="line">            <span class="keyword">int</span> temp=nums[nums[i]];</span><br><span class="line">            nums[nums[i]]=nums[i];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]!=i)<span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>]==nums.length)<span class="keyword">return</span> nums.length+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)    这道题所用的方法比较简单，重点要学习其中的<a href="https://baike.baidu.com/item/%E6%8A%BD%E5%B1%89%E5%AE%9A%E7%90%86/10661533?fr=aladdin" target="_blank" rel="noopener">抽屉思想</a>。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——螺旋矩阵</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h2 id="NO-54-螺旋矩阵-中等"><a href="#NO-54-螺旋矩阵-中等" class="headerlink" title="NO.54 螺旋矩阵 中等 "></a>NO.54 螺旋矩阵 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/02/3R7fAO.png" alt="3R7fAO.png"></p>
<p><strong><font color=red>思路一：按层模拟法</font></strong> 从[0][0]开始模拟顺时针一层一层的遍历所有元素。</p>
<p><img src="https://s2.ax1x.com/2020/03/02/3WBk34.md.png" alt="3WBk34.md.png"></p>
<p>计算层数count：<code>(Min(row，col)+1)/2</code>，因为每次最多有两行两列组成，最少由一行或一列组成。</p>
<p>遍历每一层curr即<code>[0,count)</code>，每层有四次”转弯”：</p>
<ol>
<li>每一层先从左到右遍历一行，即<code>for(i=curr;i&lt;col-curr;i++)matrix[curr][i]</code>。</li>
<li>再从上到下遍历一列，即<code>for(i=curr+1;i&lt;row-curr;i++)matrix[i][col-1-curr]</code>。</li>
<li>再从右到左遍历一行，即<code>for(i=col-1-curr-1;i&gt;=curr;i--)matrix[row-1-i][i]</code>。</li>
<li>最后从下到上遍历一列，即<code>for(i=row-1-curr-1;i&gt;=curr+1;i--)matrix[i][curr]</code>。</li>
</ol>
<p><u>ps：每一层除了第一行是遍历一整行元素，其余三部分都需要注意不要重复遍历”拐点”元素。</u></p>
<p>上述是常规层(两行两列)的遍历；如果只有一行，从右向左遍历时会重复遍历；如果只有一列，从下向上遍历时会重复遍历，如何解决这个问题？</p>
<p>答：只有一行或只有一列时，不进行右向左或下向上的遍历即可。如何判断？<code>row-1-curr==curr</code>说明当前层只有一行；<code>col-1-curr==curr</code>说明当前层只有一列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (matrix==<span class="keyword">null</span>||matrix.length==<span class="number">0</span>)<span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">int</span> row = matrix.length,col=matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="comment">//计算有多少层</span></span><br><span class="line">    <span class="keyword">int</span> count=(Math.min(row,col)+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//当前层</span></span><br><span class="line">    <span class="keyword">int</span> curr=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历每一层</span></span><br><span class="line">    <span class="keyword">for</span> (;curr&lt;count;curr++)&#123;</span><br><span class="line">        <span class="comment">//从左向右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = curr; i &lt; col - curr; i++) &#123;</span><br><span class="line">            res.add(matrix[curr][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = curr+<span class="number">1</span>; i &lt; row-curr; i++) &#123;</span><br><span class="line">            res.add(matrix[i][col-<span class="number">1</span>-curr]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = col-<span class="number">1</span>-curr-<span class="number">1</span>; i &gt;= curr&amp;&amp;(row-<span class="number">1</span>-curr!=curr); i--) &#123;</span><br><span class="line">            res.add(matrix[row-<span class="number">1</span>-curr][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>-curr-<span class="number">1</span>; i &gt;= curr+<span class="number">1</span>&amp;&amp;(col-<span class="number">1</span>-curr!=curr); i--) &#123;</span><br><span class="line">            res.add(matrix[i][curr]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——跳跃游戏</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="NO-55-跳跃游戏-中等"><a href="#NO-55-跳跃游戏-中等" class="headerlink" title="NO.55 跳跃游戏 中等 "></a>NO.55 跳跃游戏 <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2020/03/03/34FoeP.png" alt="34FoeP.png"></p>
<p><strong><font color=red>思路一：贪心算法</font></strong> NO.45跳跃游戏II的姊妹题，思路一样可以结合学习，题解参考<a href="https://blog.csdn.net/qq_42758551/article/details/104562003" target="_blank" rel="noopener">徒手挖地球二三周目</a>。</p>
<p>每次都在本次跳跃范围内找到下一跳最远的位置。如果最后最远的都为都不能到结尾，则false。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//end当前跳跃范围，maxPosition记录当前跳跃范围内下一跳最远的位置</span></span><br><span class="line">    <span class="keyword">int</span> end=<span class="number">0</span>,maxPosition=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//记录当前范围内下一跳最远的位置</span></span><br><span class="line">        maxPosition=Math.max(maxPosition,nums[i]+i);</span><br><span class="line">        <span class="comment">//走到当前跳跃最远点</span></span><br><span class="line">        <span class="keyword">if</span> (i==end)&#123;</span><br><span class="line">            <span class="comment">//跳到最远的位置</span></span><br><span class="line">            end=maxPosition;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end&gt;=nums.length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(n)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——通配符匹配</title>
    <url>/2020/03/14/%5BLeetCode%5D%E2%80%94%E2%80%94%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="NO-44-通配符匹配-困难"><a href="#NO-44-通配符匹配-困难" class="headerlink" title="NO.44 通配符匹配 困难 "></a>NO.44 通配符匹配 <font color=#ff0099>困难</font> <a id="more"></a></h1><p><img src="https://s2.ax1x.com/2020/02/13/1O3D54.png" alt="1O3D54.png"></p>
<p><img src="https://s2.ax1x.com/2020/02/13/1O3sPJ.png" alt="1O3sPJ.png"></p>
<p>这道题和NO.10正则表达式匹配看起来很像，正则匹配的题解可以参考<a href="https://blog.csdn.net/qq_42758551/article/details/104286793" target="_blank" rel="noopener">徒手挖地球十六周目</a>中的记录。</p>
<p>这两道题目的区别在于’*’的处理不同，正则中的星号是星号前的字符可以出现0次、1次或多次，而本题中通配符中的星号则是可以匹配任意字符。但是正则中的’.’和通配符中的’?’作用是一样的。</p>
<p>所以说这道题的难点一样是对于’*’的处理。</p>
<p><strong><font color=red>思路一：双指针贪心算法</font></strong> 重点就是我们如何充分的利用’*’。</p>
<p>我们用i和j分别标记s和p的第一个字符下标，即都初始化为0。用istart和jstart分别标记s和p中’*’匹配过的位置，即初始化为-1。</p>
<p>和普通字符串匹配的思路差不多，<code>已经匹配成功的部分就不再考虑了</code>，所以要用i和j标记当前正在比较的字符；但是<code>最近匹配过的&#39;*&#39;</code>可能会被<code>重复使用去匹配更多的字符</code>，所以我们要用istart和jstart分别标记<code>s和p中最近匹配过&#39;*&#39;的位置</code>。可以参考<a href="https://blog.csdn.net/qq_42758551/article/details/104286793" target="_blank" rel="noopener">徒手挖地球十六周目</a>NO.正则表达式匹配的思路一是如何从普通情况延伸到特殊字符的。</p>
<p>s和p匹配过程中可能会遇到的情况：</p>
<ol>
<li>如果<code>i和j标记的字符正好相等或者j字符是&#39;?&#39;</code>匹配成功，则”移除”i和j元素，即<code>自增i、j</code>。</li>
<li>否则如果<code>j字符是&#39;*&#39;</code>依然可以匹配成功，<code>则用istart和jstart分别标记i元素和j元素</code>之后<code>自增j</code>。</li>
<li>再否则如果<code>istart&gt;-1</code>说明之前匹配过’*‘，因为’*‘可以匹配多个字符，所以这里要再次利用这个最近匹配过的’*‘匹配更多的字符，<code>移动i标记istart的下一个字符，再让istart重新标记i元素</code>同时<code>移动j标记jstart的下一个字符</code>。</li>
<li>上述三种情况都不满足，则匹配失败，<code>返回false</code>。</li>
</ol>
<p>最后当s中的字符都判断完毕，则认为s为空，此时需要p为空或者p中只剩下星号的时候，才能成功匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span>||p.isEmpty())<span class="keyword">return</span> s==<span class="keyword">null</span>||s.isEmpty();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,istart=-<span class="number">1</span>,jstart=-<span class="number">1</span>,slen=s.length(),plen=p.length();</span><br><span class="line">    <span class="comment">//判断s的所有字符是否匹配</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;slen)&#123;</span><br><span class="line">        <span class="comment">//三种匹配成功情况以及匹配失败返回false</span></span><br><span class="line">        <span class="keyword">if</span> (j&lt;plen&amp;&amp;(s.charAt(i)==p.charAt(j)||p.charAt(j)==<span class="string">'?'</span>))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (j&lt;plen&amp;&amp;p.charAt(j)==<span class="string">'*'</span>)&#123;</span><br><span class="line">            istart=i;</span><br><span class="line">            jstart=j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (istart&gt;-<span class="number">1</span>)&#123;</span><br><span class="line">            i=++istart;</span><br><span class="line">            j=jstart+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s中的字符都判断完毕，则认为s为空，此时需要p为空或者p中只剩下星号的时候，才能成功匹配。</span></span><br><span class="line">    <span class="comment">//如果p中剩余的都是*，则可以移除剩余的*</span></span><br><span class="line">    <span class="keyword">while</span> (j&lt;plen&amp;&amp;p.charAt(j)==<span class="string">'*'</span>)j++;</span><br><span class="line">    <span class="keyword">return</span> j==plen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(mn)      m、n分别是s和p的长度。</p>
<p><strong><font color=red>思路二：动态规划法</font></strong> 分析步骤依然按照<a href="https://blog.csdn.net/qq_42758551/article/details/104286793" target="_blank" rel="noopener">徒手挖地球十六周目</a>NO.正则表达式匹配思路二的步骤来。</p>
<p>dp数组的含义：dp[i][j]意思是s的前i个元素能否被p的前j个元素成功匹配。</p>
<p>知道了dp数组的含义之后，我们就知道了初始化细节：</p>
<ol>
<li><code>boolean类型</code>的dp数组，大小是<code>[s.length+1][p.length+1]</code>，因为存在s前0个字符和p前0个字符的情况。</li>
<li><code>dp[0][0]一定是true</code>，因为s空串和p空串是可以匹配成功的；<code>dp[1][0]~dp[s.length][0]一定都是false</code>，因为s不为空串而p为空串是不能匹配成功的。</li>
<li><code>dp[0][1]~dp[0][p.length]</code>当s为空串的时候，而p不是空串的时候，当且仅当p的j字符以及前面都为’*’才为true。</li>
<li><code>dp[s.length][p.length]</code>就得到了s和p最终的匹配情况。</li>
</ol>
<p>有了上述理解之后，就可以初始化dp数组了。</p>
<p>然后填写dp数组剩余部分即可，状态转移方程：</p>
<ol>
<li>当<code>s[i]==p[j]或者p[j]==&#39;?&#39;</code>，则<code>dp[i][j]=dp[i-1][j-1]</code>。可以理解为当前字符成功匹配后，只需要考虑之前的字符串是否匹配即可；也可以理解为当前字符匹配成功之后，”移除”当前元素(即不需要再考虑当前元素)。</li>
<li>当<code>p[j]==&#39;*&#39;</code>，则<code>dp[i][j]=dp[i-1][j]||dp[i][j-1]</code>。可以理解为当字符为’*‘的时候会出现两种情况，第一种是’<em>‘需要作为一个字母与s[i]进行匹配；第二种是’\</em>‘需要作为空字符(即不需要’*‘可以直接”移除”)，所以dp[i][j-1]；用逻辑或将两种情况连接，是因为只要有一种情况可以匹配成功则当前匹配成功，有点暴力算法的感觉。</li>
<li>最后当<code>s[i]!=p[j]&amp;&amp;p[j]!=&#39;*&#39;</code>，<code>dp[i][j]=false</code>。这步可以省略，因为dp数组元素的默认值就是false，所以不必要进行显式的赋值为false。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p==<span class="keyword">null</span>||p.isEmpty())<span class="keyword">return</span> s==<span class="keyword">null</span>||s.isEmpty();</span><br><span class="line">    <span class="keyword">int</span> slen = s.length(),plen=p.length();</span><br><span class="line">    <span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[slen+<span class="number">1</span>][plen+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化dp数组,dp[1][0]~dp[s.length][0]默认值flase不需要显式初始化为false</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//dp[0][1]~dp[0][p.length]只有p的j字符以及前面所有字符都为'*'才为true</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=plen;j++)dp[<span class="number">0</span>][j]=p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span>&amp;&amp;dp[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//填写dp数组剩余部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++) &#123;</span><br><span class="line">            <span class="keyword">char</span> si = s.charAt(i - <span class="number">1</span>),pj=p.charAt(j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (si==pj||pj==<span class="string">'?'</span>)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pj==<span class="string">'*'</span>)&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j]||dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(mn)    m、n分别是s和p的长度。</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
        <tag>双指针</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——两数相加</title>
    <url>/2019/10/01/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h2 id="NO-2-两数相加-中等"><a href="#NO-2-两数相加-中等" class="headerlink" title="NO.2 两数相加    中等 "></a>NO.2 两数相加    <font color=orange>中等</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMw8XR.png" alt="QMw8XR.png"></p>
<p><font color=red><strong>思路一：转换法</strong></font>    1.将两个链表先转化成int或long类型数值x和y。2.x和y相加后的值再转换成链表。</p>
<p><strong>缺点</strong>：当参数中两个链表足够长时，得到的结果很有可能会超出int或long类型的范围发生溢出。</p>
<p>可以将x和y用BigDecimal类型来存储尽可能避免发生溢出，<strong><u>需要注意的是题目中链表都是逆序的</u></strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        String s1=<span class="string">""</span>;</span><br><span class="line">        String s2=<span class="string">""</span>;</span><br><span class="line">        ListNode q=l1,p=l2;</span><br><span class="line"><span class="comment">//        将两个链表转化为字符串</span></span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s1=q.val+s1;</span><br><span class="line">            q=q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            s2=p.val+s2;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        BigDecimal x=<span class="keyword">new</span> BigDecimal(s1);</span><br><span class="line">        BigDecimal y=<span class="keyword">new</span> BigDecimal(s2);</span><br><span class="line">        BigDecimal z=x.add(y);</span><br><span class="line"><span class="comment">//        将结果转换成链表</span></span><br><span class="line">        <span class="keyword">char</span>[] chars=z.toString().toCharArray();</span><br><span class="line">        ListNode result=<span class="keyword">new</span> ListNode(Integer.parseInt(String.valueOf(chars[chars.length-<span class="number">1</span>])));</span><br><span class="line">        ListNode t=result;</span><br><span class="line"><span class="comment">//        因为链表是逆序的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=chars.length-<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            ListNode temp=<span class="keyword">new</span> ListNode(Integer.parseInt(String.valueOf(chars[i])));</span><br><span class="line">            t.next=temp;</span><br><span class="line">            t=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>思路二：初等数学法</strong></font>    1.因为链表本身就是逆序的，所以从后向前按位依次加。2.用一个int变量carry来记录前一位相加后得到的进位。3.如果一个链表已经遍历完毕，在后续的按位相加时，该链表的节点值就是0。4.每次按位相加之后更新进位值carry，并将进位之后的数值加入结果链表。5.<u>两个链表遍历相加结束之后，需要再次判断进位值，防止遗漏最高位的进位。</u></p>
<p><strong><u>需要注意的是每次按位相加时，不要忘记加上进位值carry。</u></strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        用哑节点来简化代码，如果没有使用哑节点就需要额外的代码来初始化表头的值</span></span><br><span class="line">        ListNode dummyHead=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode q=l1,p=l2,curr=dummyHead;</span><br><span class="line"><span class="comment">//        进位标志carry</span></span><br><span class="line">        <span class="keyword">int</span> carry=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (q!=<span class="keyword">null</span>||p!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//          获取节点值，如果节点为空，值就为0</span></span><br><span class="line">            <span class="keyword">int</span> x=q==<span class="keyword">null</span>?<span class="number">0</span>:q.val;</span><br><span class="line">            <span class="keyword">int</span> y=p==<span class="keyword">null</span>?<span class="number">0</span>:p.val;</span><br><span class="line"><span class="comment">//          两个节点值和进位相加</span></span><br><span class="line">            <span class="keyword">int</span> sum=x+y+carry;</span><br><span class="line"><span class="comment">//          获取相加之后的进位值</span></span><br><span class="line">            carry=sum/<span class="number">10</span>;</span><br><span class="line"><span class="comment">//          将相加后结果加入结果链表</span></span><br><span class="line">            curr.next=<span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);</span><br><span class="line"><span class="comment">//          移动到下一个节点</span></span><br><span class="line">            curr=curr.next;</span><br><span class="line">            <span class="keyword">if</span> (q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                q=q.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                p=p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        最后判断是否仍有进位，防止进位被遗漏</span></span><br><span class="line">        <span class="keyword">if</span> (carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            curr.next=<span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        因为第一个节点是哑节点，</span></span><br><span class="line">        <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O(max(m,n))</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode——计算质数</title>
    <url>/2019/10/01/%5BLeetCode%5D%E2%80%94%E2%80%94%20%E8%AE%A1%E7%AE%97%E8%B4%A8%E6%95%B0/</url>
    <content><![CDATA[<h2 id="NO-204-计算质数-简单"><a href="#NO-204-计算质数-简单" class="headerlink" title="NO.204 计算质数    简单 "></a>NO.204 计算质数    <font color=green>简单</font> <a id="more"></a></h2><p><img src="https://s2.ax1x.com/2019/12/03/QMwlp4.png" alt="QMwlp4.png"></p>
<p><font color=red><strong>思路一：暴力法</strong></font>    双层for循环。1.第一层循环遍历逐个判断[2,n)。2.第二层循环判断参数是否为素数。：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime(i))</span><br><span class="line">            count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度:O(n^2)</p>
<p><strong>可改进点：</strong>例如，12=2*6、12=3*4、12=sqrt(12)*sqrt(12)、12=4*3、12=6<em>2，可以观察到后面就是前面两个数反过来，说明查找可以整除12的因子时只需要找到“一半”的位置即可，如果前“一半”没有可以整除的因子，那么后“一半”也没有，这个临界点“一半”就是sqrt(12)。所以上述isPrime()方法的循环条件可以写为“i\</em>i&lt;n”即可，该方法时间复杂度降到了O(sqrt(n))。</p>
<p><font color=red><strong>思路二：厄拉多塞筛法</strong></font>    不难想象，所有质数的倍数都不是质数。例如，2是质数，2的倍数4、6、8、10、12。。。都不是质数；3是质数，3的倍数6、9、12、15。。。都不是质数；可以看一下维基百科中一个厄拉多塞筛的gif图：</p>
<p><img src="https://s2.ax1x.com/2019/12/03/QMw11J.gif" alt="QMw11J.gif"></p>
<p>这种方法大概就是“排除法”，每确定一个质数，就可以排除一批非质数，那么算法就可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isPrimes[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrimes,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//		将所有质数的倍数设置为false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j&lt;n;j+=i)&#123;</span><br><span class="line">                isPrimes[j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//      统计所有质数，即isPrimes[i]==true的为质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述算法还存在两处冗余：</p>
<ol>
<li>在本题的暴利算法下说的：只需要判断到sqrt(n)即可。</li>
<li>例如，12不是质数，所以会被设置为false，但是12既是2的倍数，也是3的倍数，所以它被标记了两次。</li>
</ol>
<p>解决上述两处冗余后的算法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isPrimes[]=<span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        Arrays.fill(isPrimes,<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//        只需要判断小于sqrt(n)的数是否为质数即可，所以i*i&lt;n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i*i&lt;n;i++)&#123;</span><br><span class="line"><span class="comment">//            这样可以把质数i的整数倍都标记为false，但是仍然存在计算冗余。</span></span><br><span class="line"><span class="comment">//            比如n=25，i=4时算法会标记4×2=8，4×3=12等等数字，</span></span><br><span class="line"><span class="comment">//            但是这两个数字已经被i=2和i=3的2×4和3×4标记了。所以使用j=i*i减少此计算的冗余。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i*i;j&lt;n;j+=i)&#123;</span><br><span class="line">                isPrimes[j]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//      统计所有质数，即isPrimes[i]==true的为质数</span></span><br><span class="line"><span class="comment">//        这里要注意从2开始，因为0,1不是质数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isPrimes[i])count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>厄尔拉塞筛法的时间复杂度：O(nloglogn)</p>
<hr>
<p>本人菜鸟，有错误请告知，感激不尽！</p>
<p>更多题解和学习记录博客:<a href="https://blog.csdn.net/qq_42758551" target="_blank" rel="noopener">博客</a>、<a href="https://github.com/Jerrymouse1998/learning-record-of-leetcode" target="_blank" rel="noopener">github</a> </p>
]]></content>
      <categories>
        <category>题解笔记</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>厄拉多塞筛</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC中的集合参数绑定</title>
    <url>/2019/06/09/SpringMVC%E4%B8%AD%E7%9A%84%E9%9B%86%E5%90%88%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>绑定数组参数和集合参数<a id="more"></a></p>
<h2 id="1-绑定数组参数"><a href="#1-绑定数组参数" class="headerlink" title="1. 绑定数组参数"></a>1. 绑定数组参数</h2><p><u>语言匮乏，组织不好语言。。。直接上例子。。</u></p>
<p>例子：页面中多个checkbox<strong>组件</strong>的<strong>name</strong>都是ids。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath &#125;/queryItem.action"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">查询条件：</span><br><span class="line">&lt;table width=<span class="string">"100%"</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;商品id&lt;input type="text" name="item.id" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;商品名称&lt;input type="text" name="item.name" /&gt;&lt;/td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">商品列表：</span><br><span class="line">&lt;table width=<span class="string">"100%"</span> border=<span class="number">1</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;选择&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品名称&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品价格&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;生产日期&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;商品描述&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;操作&lt;/td&gt;</span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123;itemList &#125;"</span> <span class="keyword">var</span>=<span class="string">"item"</span>&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">	&lt;td&gt;&lt;input type="checkbox" name="ids" value="$&#123;item.id&#125;"/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.name &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.price &#125;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;&lt;fmt:formatDate value="$&#123;item.createtime&#125;" pattern="yyyy-MM-dd HH:mm:ss"/&gt;&lt;/td&gt;</span><br><span class="line">	&lt;td&gt;$&#123;item.detail &#125;&lt;/td&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;td&gt;&lt;a href="$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;"&gt;修改&lt;/a&gt;&lt;/td&gt;</span><br><span class="line"></span><br><span class="line">&lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>controller方法可以用一个数组做形参，MVC的处理器适配器就会自动绑定参数。</p>
<p>对应以上的例子，controller方法的形参可以是<strong>Integer[ ]</strong> 类型，表单提交后被选中的checkbox的<strong>value</strong>就会被自动绑定到方法的形参中去。</p>
<h2 id="2-绑定集合参数"><a href="#2-绑定集合参数" class="headerlink" title="2.  绑定集合参数"></a>2.  绑定集合参数</h2><p>依然是上面的jsp文件，controller方法的形参直接改为<strong>List&lt;Integer&gt;</strong>,表单提交后会报错！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">报错信息：Failed to instantiate [java.util.List]: Specified class is an interface</span><br></pre></td></tr></table></figure>

<p>此时需要一个pojo对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemVo</span> </span>&#123;</span><br><span class="line">	。</span><br><span class="line">    。</span><br><span class="line">    。</span><br><span class="line">	<span class="keyword">private</span> List&lt;Integer&gt; ids;</span><br><span class="line">	</span><br><span class="line">	getter/setter。。。</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>将controller方法的形参改为ItemVo类型，会自动将表单提交来的参数，按参数名绑定到pojo类的集合属性中。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller方法的返回值</title>
    <url>/2019/06/09/Controller%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<h3 id="1-返回ModelAndView"><a href="#1-返回ModelAndView" class="headerlink" title="1. 返回ModelAndView"></a>1. 返回ModelAndView<a id="more"></a></h3><p>最开始学习的时候就是返回这个类，可以给这个类添加model数据和指定view。</p>
<h3 id="2-返回void"><a href="#2-返回void" class="headerlink" title="2. 返回void"></a>2. 返回void</h3><p>返回值为空，那么model数据和view怎么办呢？</p>
<p>可以在形参中使用request和response，完成域对象存取数据、重定向、转发。。。（这里就有点像最初的servlet了）</p>
<h3 id="3-返回字符串"><a href="#3-返回字符串" class="headerlink" title="3. 返回字符串"></a>3. 返回字符串</h3><p>controller方法返回字符串可以指定<strong>逻辑视图名</strong>，通过<strong>视图解析器</strong>解析为<strong>物理视图地址</strong>。（类似于指定view）</p>
<p>可以在字符串前加<strong>Redirect</strong>或者<strong>forward</strong>完成<strong>重定向</strong>或<strong>转发</strong>。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>@RequestMapping注解的作用</title>
    <url>/2019/06/09/@RequestMapping%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-URL路径映射"><a href="#1-URL路径映射" class="headerlink" title="1. URL路径映射"></a>1. URL路径映射<a id="more"></a></h3><p>最常用，用的最多的属性value</p>
<p>@RequestMapping(value=”item”)或@RequestMapping(“/item”）</p>
<p>value的值是数组，可以将多个url映射到同一个方法</p>
<h3 id="2-添加在类上面"><a href="#2-添加在类上面" class="headerlink" title="2. 添加在类上面"></a>2. 添加在类上面</h3><p>在<strong>class</strong>上添加<strong>@RequestMapping(url)</strong>指定<strong>通用请求前缀</strong>， <u>限制此类下的所有方法请求url必须以请求前缀开头</u>。</p>
<p><font color="red"><strong>可以使用此方法对url进行分类管理。</strong></font></p>
<h3 id="3-请求方法限定"><a href="#3-请求方法限定" class="headerlink" title="3. 请求方法限定"></a>3. 请求方法限定</h3><p>method属性，可以限制请求的方法GET、POST。。。</p>
<p>并且该方法也是一个数组，可以指定多个请求的方法。</p>
]]></content>
      <categories>
        <category>Spring学习笔记</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
